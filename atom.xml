<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有才的博客</title>
  
  <subtitle>不孤独，无自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="yanchongsheng.github.io/"/>
  <updated>2018-10-17T12:03:11.631Z</updated>
  <id>yanchongsheng.github.io/</id>
  
  <author>
    <name>Yan ChongSheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 入门总结(九)</title>
    <link href="yanchongsheng.github.io/2018/10/12/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B9%9D)/"/>
    <id>yanchongsheng.github.io/2018/10/12/Linux入门总结(九)/</id>
    <published>2018-10-12T11:55:12.000Z</published>
    <updated>2018-10-17T12:03:11.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(九) —— Linux 常用命令 </blockquote><a id="more"></a><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>1、帮助命令 man<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 manual；命令所在路径：/usr/bin/man；作用：获得帮助信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    man [命令或配置文件]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看命令的帮助信息</span><br><span class="line">    man ls</span><br><span class="line"></span><br><span class="line">    # 查看配置文件的帮助信息</span><br><span class="line">    man services</span><br></pre></td></tr></table></figure></p><p>manual 英文意思手册，指南；使用 man 命令相当于调用了一个 less 的浏览方式。</p><p>如何看命令的帮助信息？1、知道命令是干什么用的，通过查看帮助信息的第一行即 NAME 行。2、知道命令的选项是干什么用的，通过「/+关键字」的方式可以快速定位到你要找的内容，通过 n 键向下继续查找。</p><p>如何查看配置文件的帮助信息？1、这个配置文件是干什么用的，通过查看帮助信息的第一行即 NAME 行；2、这个配置文件的格式是什么样的，在 Linux 中任何配置文件都是有规律的，即格式，可以在配置文件的帮助文档中查看到。</p><p>注意在使用 man 来查看配置文件帮助的时候，不可以写成「man + 配置文件绝对路径」！！！此时你得到的并不是帮助信息，而是配置文件的内容。查看配置文件帮助的时候只要使用「man + 配置文件名称」即可。通过查看第一行即 NAME 行，它会告诉你这个配置文件是一个什么样的文件。</p><p>man 命令的帮助类型：「1」表示命令的帮助，「5」表示配置文件的帮助。eg：如 passwd 既对应一个命令又对应一个配置文件，使用 man 会优先显示命令的帮助。要想查看配置文件的帮助，则 <code>man 5 passwd</code> 加一个数字 5 声明你要查看配置文件的帮助。</p><p>执行指令 man services 等查看配置文件帮助文档的时候出现「没有 services 的手册页条目」。解决办法：安装 man 帮助文档包。指令为：<code>yum install man-pages</code>。</p><p>「whatis + 命令名称」它可以直接读取到这个命令 NAME 部分的信息。</p><p>「apropos + 配置文件的名称」只想查看一个配置文件的简短信息。</p><p><code>命令 --help</code> 只想查看命令的选项，不想看到其他的描述语言。</p><p>命令 info 即 infomation，也可以获得帮助信息，其作用跟 man 大同小异，只是在帮助信息的显示有所差别，包括方式上支持一些跳转。</p><p>2、帮助命令 help<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：Shell 内置命令；作用：获得 Shell 内置命令的帮助信息</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看 umask 命令的帮助信息</span><br><span class="line">    help umask</span><br></pre></td></tr></table></figure></p><p>Shell 其实就是一个命令解释器，找不到命令所在路径的命令都是 Shell 内置命令，eg：cd、umask。这些命令不能使用 man 来查看帮助，它会列出 Shell 所有的帮助信息。可以使用 help 来获取 Shell 内置命令的帮助信息。</p><p>3、Linux 中的命令大致可分为两类，内部命令和外部命令。内部命令：也称 Shell 内嵌命令；外部命令：存放在一个文件中，使用时需要去文件中查找，这些文件被定义在 $PATH 中。<strong>type 命令可以查看命令类型，以区别是内部命令还是外部命令，格式 <code>type 命令名称</code>。</strong></p><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><p>1、用户管理命令 useradd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/sbin/useradd；作用：添加新用户</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    useradd 用户名</span><br></pre></td></tr></table></figure></p><p>useradd 命令只有 root 用户可以使用。</p><p>useradd 命令在添加的时候只是添加了用户的基本信息，例如家目录、相关的命令解释器的分配等，并没有给它设置一个验证密码。</p><p>2、用户管理命令 passwd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/passwd；作用：设置用户密码</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    passwd 用户名</span><br></pre></td></tr></table></figure></p><p>注意：更改密码的时候只有管理员可以随意更改密码，普通用户必须要满足密码原则才可以更改密码成功。每个普通用户只能用 passwd 更改自己的密码，而管理员 root 可以用 passwd 更改任何人的密码。</p><p>3、用户管理命令 who<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/who；作用：查看登录用户信息</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/Command_who_show.png" alt="who 命令显示内容" title="who 命令显示内容"><br>who 命令显示内容解释：登录用户名（一个用户可以多次登录）、登录的终端（tty 表示本地终端，即在 Linux 机器本身上登录，tty 又叫本地登录）（pts 表示远程终端，即远程登录）、登录时间、括号里的内容是登录的主机的 IP 地址，如果没有写就表示本机登录。</p><p>4、用户管理命令 w<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/w；作用：查看登录用户详细信息</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/Command_w_show.png" alt="w 命令显示内容" title="w 命令显示内容"></p><p>w 命令的第一行信息解释：当前系统时间、系统连续运行多久、当前一共有几个用户登录、负载均衡指数（这个指数有 3 个数值，分别记录了过去的 1 分钟、5 分钟和 15 分钟，系统的一个负载情况，一般来讲系统的负载值主要指的就是 cup 和内存的负载情况）。IDLE 表示该用户登录过来已经空闲多久了；PCPU 指的是该用户当前登录过来执行的操作占用的 cpu 的时间（下面的数字指的是当前执行的命令占用的 cpu 时间，因为进程在执行的时候是排队依次执行，每个进程在一个 cpu 循环周期里面会分配一定的 cpu 时间，如果一个进程在 cpu 循环周期里多次，它就会占用多个 cpu 时间）；WHAT 指的是他当前执行了什么操作；JCPU 累计占用的 cpu 时间。</p><h2 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h2><p>1、压缩命令 gzip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/gzip；作用：压缩文件；压缩后文件格式：.gz</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    gzip [文件]</span><br></pre></td></tr></table></figure></p><p>解压命令 gunzip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/gunzip；作用：解压缩 .gz 的压缩文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    gunzip [选项] 压缩文件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -S    指定后缀以取代 .gz，suffix</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/gzip_gunzip.png" alt="gzip&amp;gunzip" title="gzip&amp;gunzip"></p><p>注意：gzip 只能压缩文件，不能压缩目录。而且使用 gzip 压缩是不保留源文件的，使用 gunzip 解压缩也是不保留源文件的。解压缩命令：gunzip（即在 gzip 压缩命令中间加入 un）或者使用 gzip -d 命令，两种命令的效果是一样的。gzip 的压缩比约为 5:1。</p><p>2、压缩解压命令 tar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/tar；作用：打包目录；压缩后文件格式：.tar.gz</span><br><span class="line"></span><br><span class="line">格式：tar [选项] [压缩后文件名] [文件或目录]    </span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c  打包，create</span><br><span class="line">    -x  解包，extract</span><br><span class="line">    -v  显示详细信息，verbose</span><br><span class="line">    -f  指定文件名，file</span><br><span class="line">    -z  打包的同时用 gzip 或 gunzip 压缩或解压</span><br></pre></td></tr></table></figure></p><p>tar 本身的意思是打包，它可以把一个目录打包成一个文件，同时也可以在打包的同时做一个压缩。tar -cvzf 的压缩比约为 5:1。<strong>使用此组命令会保留源文件。</strong></p><p><strong>注意：在使用 tar 的压缩解压命令的时候，-f 后面一定要紧跟它要指定的文件，否则可能会报错。如果 -f 后面没有紧跟它要指定的文件，则 tar 命令的选项中不能加「-」，否则会报错 <code>Cannot stat: No such file or directory</code>。</strong></p><p>3、压缩命令 zip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/zip；作用：压缩文件或目录；压缩后文件格式：.zip</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    zip [选项] [压缩后文件名] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  压缩目录</span><br></pre></td></tr></table></figure></p><p>解压命令 unzip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/unzip；作用：解压 .zip 的压缩文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    unzip [压缩文件]</span><br></pre></td></tr></table></figure></p><p>一般来讲，Linux 里面的压缩包的格式 windows 的压缩软件几乎都支持。但反过来就要看具体情况了。默认在使用的过程中，只有一种压缩格式 windows 和 Linux 双方都不需要再额外装什么软件都可以进行解压缩处理的就是 .zip 格式。<strong>使用 zip 命令：会保留源文件，可以压缩目录。</strong> 压缩比没有 gzip 那么可观，所以使用的会比较少。使用 unzip 命令进行解压缩的时候，不分压缩文件是目录还是文件，都可以进行解压缩。</p><p>4、压缩命令 bzip2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/bzip2；作用：压缩文件；压缩后文件格式：.bz2</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    bzip2 [选项] [文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -k  产生压缩文件后保留原文件，keep</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 压缩</span><br><span class="line">    bzip2 -k test</span><br><span class="line"></span><br><span class="line">    # 跟 tar 命令结合使用，采用 bzip2 的方式压缩</span><br><span class="line">    tar -cjf test.tar.bz2 test</span><br></pre></td></tr></table></figure></p><p>这是一个 gzip 的升级版本。值得注意的是 bzip2 的压缩比是非常惊人的，一般往往用来压缩大的文件。还可以跟 tar 一起来使用：即用 tar 命令里的 z（z 表示 tar 命令中的压缩方式）替换为 j（j 表示 bzip2 的压缩方式）。注意 bzip2 只能处理文件，不能处理目录。</p><p>解压命令 bunzip2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/bunzip2；作用：解压缩</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    bunzip2 [选项] [压缩文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -k    解压缩后保留原文件，keep</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 解压</span><br><span class="line">    bunzip2 -k test.bz2</span><br><span class="line"></span><br><span class="line">    # 跟 tar 命令结合使用，解压 bzip2 方式的压缩</span><br><span class="line">    tar -xjf test.tar.bz2</span><br></pre></td></tr></table></figure></p><p>如果该目录下有跟解压后的文件同名的文件则该命令会拒绝解压缩，不会像其他命令询问你是否覆盖等。要想解压则必须先删除或更改同名文件。在解压缩 .tar.bz2 文件的时候同样适用 tar 命令，注意把 z 替换为 j 即可。</p><p>小结：</p><ol><li>.gz 类型的压缩文件 gzip 进行压缩 gunzip（或 gzip -d）进行解压缩。不能压缩目录，不能保留源文件。</li><li>.tar 类型的文件 可以生成打包文件 tar -cf 打包，-xf 解包，可以利用此命令进行压缩目录。</li><li>.tar.gz 类型的压缩文件 tar -zcf 打包并压缩，tar -zxf 解包并解压缩。</li><li>.zip 类型的压缩文件 zip 压缩文件 zip -r 压缩目录，unzip 解压缩文件或者目录（压缩比不是特别高，windows 和 Linux 通过格式）。</li><li>.bz2 类型的压缩文件 bzip2 进行压缩，bunzip2（或者是 bzip2 -d）进行解压缩。</li><li>.tar.bz2 类型的压缩文件 tar -cjf 生成压缩包，tar -xjf 进行解压缩。</li></ol><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><p>1、网络命令 write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/write；作用：给用户发信息，以 Ctrl + D 保存 结束</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    write 用户名</span><br></pre></td></tr></table></figure></p><p>注意：在 write 命令的输入界面，按退格键是不行的，需要按 Ctrl + 退格键或者按 Delete 键，表示退格的意思。内容输入结束后按回车，然后使用 Ctrl + D 保存并结束。<strong>特别注意的是只能给在线用户发送，如果用户不在线消息是发不出去的。</strong></p><p>2、网络命令 wall<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 write all；命令所在路劲：/usr/bin/wall；作用：发广播信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    wall 消息</span><br></pre></td></tr></table></figure></p><p>给当前所有在线用户发送信息。在使用该命令发送广播信息的时候，自己也会受到一条发的广播信息。本地终端也会收到广播信息。<strong>注意只有在线用户可以收到消息。</strong></p><p>3、网络命令 ping<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/ping；作用：测试网络连通性</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ping [选项] IP地址</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c   指定发送次数</span><br></pre></td></tr></table></figure></p><p>现在使用最多的远程探测命令，工作机制：给远程主机发送一个信息包，判断你是否存在即看看你是否回应我，只要你回应，就证明咱们两个之间网络是通的。注意在使用 ping 命令的时候，重点看 package loss 即丢包率这个属性。如果丢包率非常高，即使你 ping 通了，证明你的网状态其实也非常差 。</p><p>4、网络命令 ifconfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 interface configure；命令所在路径：/sbin/ifconfig；作用：查看和设置网卡信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ifconfig 网卡名称 IP地址</span><br></pre></td></tr></table></figure></p><p>Linux 系统中默认有两块网卡，eth0 代表的是本地的真实网卡，lo 回环网卡，用来本机通信和测试的，地址也是固定的，都是 127.0.0.1，不插网线甚至网卡驱动不安装，都可以 ping 通。</p><p><img src="/upload_image/ifconfig_command_show.png" alt="ifconfig" title="ifconfig"></p><ol><li>eth0:网卡接口名称；flags：标志位，UP 表示网卡启用激活状态； mtu：maximum transmission unit，网卡最大传输单元为 1500 字节；</li><li>inet：IPv4 地址； netmask：子网掩码；broadcast：广播地址；</li><li>inet6：IPv6 地址；</li><li>ether(HWaddr)：以太网地址；txqueuelen 1000  (Ethernet)：以太网传输队列长度；网卡的硬件地址即我们所说的 MAC 地址，它是用十六进制表示的，48 位的地址，表示我的网卡的物理地址。MAC 地址是固化在网卡的只读存储器中的一个地址，位于网卡的芯片上，理论上来讲一般是不能改的。</li><li>RX packets 13245  bytes 1989908 (1.8 MiB)：此次网卡激活后接搜到的报文数量，总大小；</li><li>RX errors：接收时错误的个数；dropped：丢包个数；overruns：溢出个数；frame：帧。</li><li>TX packets 162  bytes 18461 (18.0 KiB)：传输的报文数量，总大小；</li><li>TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0：传输时错误、丢包、溢出、搬运、碰撞的个数。</li></ol><p>5、网络命令 mail<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/mail；作用：查看发送电子邮件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mail [用户名]</span><br></pre></td></tr></table></figure></p><p>mail 命令比 write 命令有一个好处，就是不管对方在不在线，都可以给对方发送邮件。Linux 的纯字符界面也可以进行邮件的收发，它利用的并不是真正的搭建好的邮件服务器，而是如果是本机用户给本机用户发信，它利用的是本地的内存。</p><p>mail 命令编辑完邮件后点击 Ctrl + D 保存结束。使用 mail 命令直接按回车，用来接受邮件，N 表示 new，即这是新收到的邮件还未阅读。想看第几分信，邮件前面有一个序列号，输入序列号回车就能看到这份邮件的具体内容，使用 h 键可以回到刚才的邮件列表，发现 N 消失了，表示邮件已读，要想删除邮件则「d 邮件序列号」，再按 h 查看邮件发现没有邮件了，q 键退出。</p><p>学习 mail 命令主要是有的时候系统会给 root 发一些系统信息的邮件，当你在用 root 登录以后系统会提示你有新的邮件需要接受，这个时候就需要我们知道怎么样来收到系统发给你（root）的信息。系统给 root 发送的信息都是非常重要的，例如日志的统计信息、系统的报错信息，当我们发现 root 有这样的邮件的时候，千万不可以忽略它，应该仔细的查看它，因为这说明你对的系统当中可能出现了一些问题，有可能会影响到你的系统的安全。</p><p>6、网络命令 last<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/last；作用：列出目前与过去登入系统的用户信息</span><br></pre></td></tr></table></figure></p><p>该命令会统计我的计算机的所有用户的登陆的时间信息，包括计算机重启时间也会被记录下来。这是一个重要的日志查询点，可以查看系统是否有异常登陆重启等信息。该命令是一个非常有效，非常重要，非常常用的日志查询命令，在服务器上可能会多次使用这样的命令。只想知道用户最后一次登陆的时间，不想知道所有的登陆信息，则可以使用另外一条命令：lastlog。last 统计的是只要有人登陆它就会记录，包括你多次登陆的信息。而 lastlog 会先把所有的用户都列出来，包括一些不能登陆的系统用户。</p><p>7、网络命令 lastlog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/lastlog；作用：检查某特定用户上次登录的时间</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # -u 指的是用户的 UID，查看特定用户的最后一次登陆的时间</span><br><span class="line">    lastlog -u 500</span><br></pre></td></tr></table></figure></p><p>8、网络命令 traceroute<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/traceroute；作用：显示数据包到主机间的路径</span><br></pre></td></tr></table></figure></p><p>作用：探测到达某一个指定网站（某一个主机）的路径。这条命令非常有用，可以事先探测好你访问某网站的路径，然后当你访问该网站出现问题的时候，可以对照然后得出哪里出现了问题。我们 traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了返回信息，所以我们得不到什么相关的数据包返回数据。</p><p>9、网络命令 netstat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/netstat；作用：显示网路相关信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    netstat [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -t   查询 TCP 协议的网络信息</span><br><span class="line">    -u   查询 UDP 协议的网络信息</span><br><span class="line">    -l   查看监听的端口，listening</span><br><span class="line">    -r   查看路由即查看网关，route</span><br><span class="line">    -n   用 IP 地址和端口号显示查询结果，而不是用域名或服务的名称，这样更快，因为省略了解析过程，numeric</span><br><span class="line">    -a   all</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看本机监听的端口，即查询当前计算机下，我开了哪些计算机端口</span><br><span class="line">    netstat -tuln</span><br><span class="line"></span><br><span class="line">    # 查看本机所有的网络连接</span><br><span class="line">    netstat -an</span><br><span class="line"></span><br><span class="line">    # 查看本机路由表，即查询路由列表</span><br><span class="line">    netstat -rn</span><br></pre></td></tr></table></figure></p><p>net 网络的意思，stat 即 state 状态的意思，查询网络状态的命令。这条命令的用途在服务器上非常广泛的。TCP 是传输控制协议的简称；UDP 用户数据报协议的简称。一般情况下服务的端口号是固定的，我们可以通过判断本机开了哪些监听端口来判断我的计算机开启了哪些服务。注意：TCP 协议才可以直接接受访问，所以它有 listen，代表状态是监听的。而 UDP 是没有的，它可以直接发送，不监听即不顾你在不在线。访问服务的时候不管访问的是 22 还是访问其他的服务，你的发起端口即源端口是 1024 以上的随机端口，只有目标端口是固定的。</p><p><img src="/upload_image/netstat_an.png" alt="netstat -an" title="netstat -an"><br>发现该命令的输出分了两大类，一类是上面的这些网络服务，除了有监听的协议之外，状态还出现了 ESTABLISHED 表示正在连接的。另一类就是下面的除了服务状态计算机中会有很多网络程序，它也会使用网络协议，使用网络端口，你可以看到这些程序所占用的端口，这个对我们意义不大。主要看到还是上面的信息。它跟 netstat -tlun最大的区别在于 netstat -tlun 只能查看监听，而它可以查看到正在连接的网络程序。</p><p><img src="/upload_image/netstat-rn.png" alt="netstat -rn" title="netstat -rn"><br>Destination 为 0.0.0.0 那行是当前计算机的默认路由列表，其实就是自己的网关。可以通过该命令查询当前计算机的网关。还可以通过 <code>route -n</code> 或 <code>cat /etc/resolv.conf</code> 查看当前计算机的网关。</p><p>10、网络命令 setup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/setup；作用：配置网络</span><br></pre></td></tr></table></figure></p><p>setup 是 redhat 开发的一个管理工具集合，它在其它的版本的 Linux 中不存在，这是 redhat 系类专有的。注意在配置完成后一点要重启网络服务：service network restart。使用 setup 配置的 IP 地址是永久生效的。该命令简单了解即可。</p><h2 id="挂载命令-mount"><a href="#挂载命令-mount" class="headerlink" title="挂载命令 mount"></a>挂载命令 mount</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/mount</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mount [-t 文件系统] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    mount -t iso9660 /dev/sr0 /mnt/cdrom</span><br></pre></td></tr></table></figure><p>该命令的作用是把我的设备连接到我给它分配的挂载点（可以理解为 windows 中的盘符，只是我们的挂载点是目录，而 windows 中的是 CDEF）。分区都是自动挂载的，只要安装了，分区了，每次启动不需要手动参与直接就可以挂载。但是 Linux 的 U 盘、光盘、移动硬盘等外接存储设备不能实现自动挂载，每次开机都只能手工来挂载。</p><p>挂载步骤：</p><ol><li>先创建挂载点：mkdir  /mnt/cdrom。</li><li>开始实现挂载：mount -t （-t 后面指定光盘的文件系统）iso9660（光盘的文件系统是固定的） /dev/sr0（设备文件名称，其来源是系统默认指定的，Linux 系统在 redhat centOS6.0 以上的系统中，设备文件名默认就叫 sr0，只要记住就可以了，不需要知道它是怎么来的，当然也可以写 cdrom，实际上就是一个软连接，通过命令：ll  /dev/cdrom 可以查看到）。这条命令中其实 -t iso9660 是可以省略的，因为该命令的这个选项或者说分区的光盘的文件系统是默认的，系统就知道它就叫  iso 9660，不写也可以。</li></ol><p>挂载其实就是找到这个硬件，给它分配一个设备文件名，再给它找一个盘符（即目录），把它的设备文件名和盘符连接起来，就是挂载。（挂载的本质：就是把设备文件名连接到挂载点上）。如果之前你的这个挂载点上做过挂载，那么你需要把它卸载以后再进行挂载：umonut  /dev/sr0。正常挂载完，mount 命令是没有任何提示的，这里提示的作用是报错，它尝试把它挂成写权限，但是光驱是只读的，所以被迫挂成了只读的，光盘绝大多数都是只读的。（windows 是光盘符下访问，而 Linux 中的盘符是目录）挂载完成后通过 cd（即cd  /mnt/cdrom）切换到盘符目录下去访问它的数据。（/dev/sr0 是一个文件，cd 命令是进不去的）。注意：必须要执行卸载命令，才可以弹出光盘。切记不可以在光盘挂载点下面卸载，因为系统会认为光盘正在使用，不允许卸载。你需要退出挂载点，直接 cd 即可返回到自己的宿主目录。在卸载的时候，因为 /dev/sr0 和 /mnt/cdrom 它们两个通过 mount 命令已经连接了，所以后面加其中任何一个都是可以的，但是只能跟一个，要是跟两个它就会卸载两遍，第二遍它就会报错。直接回车没有任何提示表示卸载成功，再回到 /mnt/cdrom 执行 ls 命令发现变成了空目录了。</p><h2 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h2><p>1、shutdown 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：shutdown [选项] 时间</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c   取消前一个关机命令，cancel</span><br><span class="line">    -h   关机，halt</span><br><span class="line">    -r   重启，reboot</span><br></pre></td></tr></table></figure></p><p>除了 shutdown 命令之外还有其他命令可以实现关机或重启，只是早期的时候只有 shutdown 命令会在关机和重启之前正确的保存它正在启动的服务，尽管现在 Linux 中绝大多数的关机重启命令都已经实现了正确的关闭服务和保存数据，只是我们已经习惯了 shutdown 命令了。虽然其他命令也可以做到，但是 shutdown 命令更安全一点，我们更信任它。</p><p>2、其他关机命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 关机</span><br><span class="line">halt</span><br><span class="line"></span><br><span class="line"># 关机</span><br><span class="line">power off</span><br><span class="line"></span><br><span class="line"># 关机</span><br><span class="line">init 0</span><br></pre></td></tr></table></figure></p><p>注意：poweroff 相当于直接断电，谨慎使用！！！</p><p>3、其他重启命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重启</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">init 6</span><br></pre></td></tr></table></figure></p><p>4、系统运行级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0   关机</span><br><span class="line">1   单用户</span><br><span class="line">2   不完全多用户，不含 NFS 服务</span><br><span class="line">3   完全多用户</span><br><span class="line">4   未分配</span><br><span class="line">5   图形界面</span><br><span class="line">6   重启</span><br></pre></td></tr></table></figure></p><p>单用户类似于 windows 中的安全模式，其实就是启动最小的服务，其他多余的东西、附加的程序都不要，甚至连网都不要，只启动最核心的程序，进去是用来做修复的。只能是 root 登录进去，其他用户都不行，顾名思义即为单用户。运行级别 1 是没有图形界面的，不光 1 级别没有图形界面，1、2、3 这 3 个运行级别都是没有图形界面的，4 是没有使用的，即可以自己定义，5 是标准的图形界面。2、3 其实都是命令行，区别是：3 是完全的命令行，而 2 是不包含 NFS 服务的命令行，即它也是命令行只是不完整（2 级别也没有网络服务）。NFS 服务：（network file system）网络文件系统，使用 NFS 是实现两个 Linux 之间的文件共享或者是 Linux 和 Unix 之间的文件共享的服务。由于 NFS 用户验证的机制比较弱，即可能不是太安全，有它自己的安全隐患在里面，所以不太建议使用 NFS 来进行文件共享，当然使用它进行文件共享确实很简单方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看系统默认运行级别</span><br><span class="line">cat /etc/inittab</span><br><span class="line"></span><br><span class="line"># 修改系统默认运行级别，注意：id 最后是有冒号的「:」，千万不可以丢！！！</span><br><span class="line">id:3:initdefault:</span><br><span class="line"></span><br><span class="line"># 查看系统运行级别</span><br><span class="line">runlevel</span><br></pre></td></tr></table></figure><p>注意：0 和 6 不能设为系统默认运行级别。在 Linux 中用 X11 代表图形界面，大写的 X 指的是 Xwindow，一般来讲，在 Linux 中看到类似于这样的表示（包括只有一个大写的 X）都表示 Linux 的一个图形环境的意思。</p><p>执行 runlevel 命令之后会有「N  3」这样的显示，3 表示当前运行的级别号，N 代表上一个运行级别，即进入 3 级别之前我在哪个级别（由于我们是开机之后直接进来的，所以是 N 表示 null 的意思）。</p><p><code>init 5</code> 表示切换到运行级别 5 即图形界面，由于我没有装图形界面它不会执行，且远程工具上是不会报错的，但是在 Linux 本地上会有报错提示，它尝试去启动 5 级别，但是没有启动成功。但是系统以为你进去了，所以执行 runlevel 命令的时候会有显示 <code>5 3</code>。</p><p>5、退出登录命令 logout<br>退出一个登录 Shell。注意：在使用完 Linux 后，一定要 logout！！！否则后果很严重！！！</p><p>6、Linux 中的管道符<br>利用 Linux 所提供的管道符「|」将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="http://blog.51cto.com/9762617/1678917" target="_blank" rel="noopener">centOS 7 安装 man 中文版手册</a><br><a href="https://blog.csdn.net/qq_36838191/article/details/80314101" target="_blank" rel="noopener">Linux 中的内部命令和外部命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(九) —— Linux 常用命令 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(八)</title>
    <link href="yanchongsheng.github.io/2018/10/09/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AB)/"/>
    <id>yanchongsheng.github.io/2018/10/09/Linux入门总结(八)/</id>
    <published>2018-10-09T11:59:38.000Z</published>
    <updated>2018-10-11T11:55:23.874Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(八) —— Linux 常用命令 </blockquote><a id="more"></a><h2 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h2><p>1、命令格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    命令 [-选项] [参数]</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">    1. 个别命令使用不遵循此格式</span><br><span class="line">    2. 当有多个选项时，可以写在一起</span><br><span class="line">    3. 简化选项与完整选项，eg：-a 等于 --all</span><br></pre></td></tr></table></figure></p><p>关于选项：在大多数的命令中，选项前面会有一个小横杆，用来标记这是一个选项；选项的作用：使用命令的时候用来做不同的操作，使命令结果呈现不同的形式或者信息内容，就可以加上不同的选项来实现，即选项是用来调整命令功能的。我们使用的选项都是简化选项，完整选项需要两个「-」 来调用，选项的顺序一般都是可以调整的。[] 里的内容是选择性加入的。加了选项是调整功能，加了参数是指定操作对象。</p><p>2、目录处理命令 ls<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 list；命令所在路径：/bin/ls；作用：显示目录文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ls [选项] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a  a 表示 all</span><br><span class="line">    -l  l 表示 long</span><br><span class="line">    -d  d 表示 directory，显示当前目录本身，而不显示目录下的数据</span><br><span class="line">    -h  h 表示 human，人性化显示文件大小</span><br><span class="line">    -i  i 表示 iNode，显示 i 结点号</span><br></pre></td></tr></table></figure></p><p>在 Linux 中，以「.」开头的是隐藏文件。隐藏文件的初衷是为了告诉用户这是一个系统文件，没有特殊情况一般不要修改它。在 Linux 中要想把一个文件隐藏，则需要给它改名，改成以点开头的文件名即可隐藏。</p><p>3、ls -l 显示结果分析<br><img src="/upload_image/ls_Analyse_Result.png" alt="ls -l" title="ls -l"></p><ol><li>x 表示执行权限，是 execute 的缩写；可执行文件 .exe 的缩写也来源于这个单词。</li><li>引用计数，代表这个文件曾经被引用或者调用过几次。这个引用计数对文件和目录来讲只在硬链接中才有作用。</li><li>文件大小默认单位是字节。可以使用 -h 选项来调整。</li><li>上图中的时间表示该文件最后被修改的时间；如果没有被修改过，则就是它的创建时间。需要注意的是 Linux 中没有创建时间这个概念，它只有文件的最后一次访问时间，文件的状态修改时间，文件的数据修改时间这三个时间。</li><li>i 节点，在 Linux 系统中每个文件或者目录都有它自己的一个唯一标识编号，系统靠这个 i 节点号搜索或者查找文件或者目录。</li></ol><p>4、目录处理命令 mkdir<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 make directories；命令所在路径：/bin/mkdir；作用：创建新目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mkdir [选项] 目录名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -p  p 表示 parents，如果新创建的目录的父目录不存在，则自动递归创建父目录</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可同时创建多个目录，多个目录之间以空格进行分割</span><br><span class="line">    mkdir /tmp/test1 /tmp/test2 /tmp/test3</span><br></pre></td></tr></table></figure></p><p>目录在 windows 中又称为文件夹。不要轻易在根目录下创建新的目录或者文件。可以在 /tmp 目录下进行练习，该目录是用来存放临时文件的。</p><p>5、目录处理命令 cd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change directory；命令所在路径：shell 内置命令；作用：切换目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cd [目录]</span><br></pre></td></tr></table></figure></p><p>「.」 表示当前目录，「..」表示当期目录的上一级目录。</p><p>注意：在 Dos 窗口下 cd.. 中间是可以不加空格的，但是在 Linux 中，中间必须有空格。</p><p>6、目录处理命令 pwd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 print working directory；命令所在路径：/bin/pwd；作用：显示当前所在目录的绝对路径</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></p><p>7、目录处理命令 rmdir<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 remove empty directories；命令所在路径：/bin/rmdir；作用：删除空目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    rmdir [空目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可同时删除多个空目录，多个空目录之间以空格进行分割</span><br><span class="line">    rmdir /tmp/test1 /tmp/test2 /tmp/test3</span><br></pre></td></tr></table></figure></p><p>注意：rmdir 只能删除空的目录！！！要想使用 rmdir 删除目录，必须先把该目录下的所有子目录和文件都删除掉，才可以使用。实际操作中此命令用的并不是很多。</p><p>8、目录处理命令 cp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 copy；命令所在路径：/bin/cp；作用：复制文件或目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cp [选项] [原文件或目录] [目标目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  复制目录，copy directories recursively</span><br><span class="line">    -p  保留文件属性，same as --preserve=mode,ownership,timestamps</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 将 /tmp 下 test1、test2、test3 目录一次性复制到 /root 下，并保持目录属性</span><br><span class="line">    cp -rp /tmp/test1 /tmp/test2 /tmp/test3 /root</span><br></pre></td></tr></table></figure></p><p>在 cp 复制文件的时候是不需要加选项的；但是要复制目录的话要增加选项 -r；cp 可以同时复制多个文件或者目录。</p><p>当把一个文件或目录复制到另一个地方的时候，相当于在另一个地方创建了一个新的文件或目录，所以复制出来的文件或目录的最后更改时间就是当前时间。如果希望复制出来的文件或目录的最后更改时间跟源文件一样，则使用 -p 选项。</p><p>在 Linux 中，复制文件或者目录的同时，可以更改目录或者文件的名字。</p><p>9、目录处理命令 mv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 move；命令所在路径：/bin/mv；作用：剪切文件、改名</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mv [原文件或目录] [目标目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # /tmp 下 test1、test2、test3 目录一次性剪切到 /root 目录</span><br><span class="line">    # 当一次剪切多个目录或文件的时候就不能改名了，改名操作只支持一次一个，不支持一次多个文件或目录进行改名</span><br><span class="line">    mv /tmp/test1 /tmp/test2 /tmp/test3 /root</span><br><span class="line">改名：</span><br><span class="line">    mv 要改名的文件名 新的文件名</span><br></pre></td></tr></table></figure></p><p>在 Linux 中剪切和改名是同一个命令。在执行复制剪切等命令的时候，如果你的位置是在当前目录的话，可以省略绝对路径，但是在不清楚当前目录的情况下要写绝对路径。mv 命令是不需要加 -r 选项的，直接使用 mv 可以同时剪切一个或多个目录或者文件的，而且在剪切的同时可以改名。</p><p>10、目录处理命令 rm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 remove；命令所在路径：/bin/rm；作用：删除文件或目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    rm [选项] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  删除目录，recursive</span><br><span class="line">    -f  强制删除，force</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 同时删除目录 test1 test2 文件 h1.txt h2.txt</span><br><span class="line">    rm -rf test1 test2 h1.txt h2.txt</span><br></pre></td></tr></table></figure></p><p>注意：Linux 中是没有回收站这一说的，文件一旦删除，就没有了。</p><p>在删除文件的时候每次都会询问你是否删除，如果你不想有这个提示的话，则可以加 -f 选项。</p><p>小结：mkdir 创建一个新的目录，选项 -p 递归创建目录；cd 切换目录；pwd 查看当前的工作目录；rmdir 删除一个空目录；cp 复制文件 -r 复制目录 -p 复制的时候保持文件的属性；mv 剪切或者给一个文件改名；rm 删除文件 -r 删除目录 -f 删除目录或者文件的同时不希望询问确认。</p><h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><p>1、文件处理命令 touch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/touch；作用：创建空文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    touch [文件名]</span><br></pre></td></tr></table></figure></p><p>注意：在 Linux 的命令里面，如果这个命令的参数没有详细的指定它的绝对路径，就表示要在当前目录下执行这个操作。要想在其他目录下执行这个操作，一定要指明它的绝对路径。</p><p>在 Linux 的文件命名里，除了「/」不能使用外，其它特殊符号都是合法的文件名，其后缀名是可以随便起的，这跟 windows 不一样。注意空格这个特殊符号，在 Linux 中并不建议将空格作为文件名组成部分，由于 Linux 系统把空格作为分隔符，要想使用空格作为文件名则必须用引号扩起来，这样虽然可以用空格作为文件名，但是对以后该文件的查找、修改、复制等操作造成麻烦，所以不建议这样使用。</p><p>2、文件处理命令 cat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/cat；作用：一次性显示整个文件内容</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cat [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n  显示行号，number</span><br></pre></td></tr></table></figure></p><p>cat 命令适合看简短的文件。cat 不适合浏览比较长的文件。cat 命令会一次性列出文件所有内容</p><p>3、文件处理命令 tac<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/tac；作用：一次性显示整个文件内容（反向列示）</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    tac [选项] [文件名]</span><br></pre></td></tr></table></figure></p><p>4、文件处理命令 more<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/more；作用：分页显示文件内容</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    more [文件名]</span><br><span class="line"></span><br><span class="line">快捷键：</span><br><span class="line">    空格或 f   翻页</span><br><span class="line">    Enter     换行</span><br><span class="line">    q 或 Q    退出</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    more /etc/services</span><br></pre></td></tr></table></figure></p><p>more 命令是一个常用的分页显示文件内容的命令。该命令不可以往上翻。</p><p>5、文件处理命令 less<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/less；作用：分页显示文件内容（可向上翻页）</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    less [文件名]</span><br></pre></td></tr></table></figure></p><p>使用 less 命令，不仅可以像 more 命令一样进行浏览，还可以往上翻，使用 PgUp 表示一页一页往上翻，使用向上的剪头表示一行一行往上翻。还可以进行搜索：直接在 less 的浏览状态里面按一个「/」+ 你要搜索的关键词，就会把行里所有包含这个关键词的进行反白显示，同时如果在你当前查看的页里没有你要得到的搜索的关键词所在行的信息，可以按 n 表示 next 接着往下找。</p><p>6、文件处理命令 head<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/head；作用：显示文件前面几行</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    head [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n   指定行数</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    head -n 20 /etc/services</span><br></pre></td></tr></table></figure></p><p>如果只想看文件的前几行，则可以使用此命令。如果不用 -n 指定要显示的行数，则默认显示的是前 10 行。</p><p>7、文件处理命令 tail<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">      命令所在路径：/usr/bin/tail；作用：显示文件后面几行</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    tail [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n   指定行数</span><br><span class="line">    -f   动态显示文件末尾内容</span><br></pre></td></tr></table></figure></p><p>显示文件最后面几行内容，默认是 10 行。-f 动态显示文件末尾的内容。使用该命令以后它会显示文件最末尾的位置，但是它并没有回到命令行，如果这时你这个文件的内容进行了变化，在这个命令操作状态下它也会实时变化的。一般来说用的也不会太多，一般用来监控一些日志。</p><p>小结：touch 创建一个文件；cat 查看文件的内容（浏览一些短文件），-n 用来显示行号；tac 反向显示文件内容（反向显示并不支持 -n 这个选项）；more 分页显示文件内容（主要指一些长的文件，不可以向上翻）；less 分页显示文件内容（可以向上/下翻，使用 「/ + 要搜索的关键词」在浏览的过程中遍历整个的文件进行搜索，可以用 n 键查找下一个匹配的位置）；head 查看一个文件的前几行，-n 指定要查看前几行，默认为 10 行；tail 查看一个文件的最后几行，-n 指定要查看后几行，-f 动态显示文件最后的内容，默认为 10 行。</p><p>8、文件处理命令 ln<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 link；命令所在路径：/bin/ln；作用：生成链接文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ln [选项] [原文件] [目标文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -s  创建软链接，s 代表 symbolic，make symbolic links instead of hard links，即创建符号链接而不是硬链接</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 创建 /etc/issue 的软链接 /root/issue.soft</span><br><span class="line">    ln -s /etc/issue /root/issue.soft</span><br><span class="line"></span><br><span class="line">    # 创建文件 /etc/issue 的硬链接 /root/issue.hard</span><br><span class="line">    ln /etc/issue /root/issue.hard</span><br></pre></td></tr></table></figure></p><p>9、软链接特征<br>类似 windows 快捷方式。作用：方便快捷的让你找到你最常使用的一些东西，便于规划，方便管理。  </p><ol><li>在 Linux 系统里面，它前面的 10 个文件权限的标识全部都是 lrwxrwxrwx，意味着所有的人都有全部的操作权限，每个用户在对这个软链接进行操作的时候，到底他能具有什么样的权限，是由这个文件对应的源文件的权限最终决定的。</li><li>软链接文件大小很小，因为它只是一个符号链接。</li><li>有一个箭头指向到它所对应的源文件（硬链接是没有箭头指向的）。</li></ol><p>10、硬链接特征</p><ol><li>拷贝「cp -p」+ 同步更新。cp -p 是拷贝文件并且保留文件的属性不变；同步更新即不管是修改原文件还是硬链接文件，两者的内容始终会自动保持一致，即同步更新。</li><li>通过 i 结点识别，硬链接的 i 节点与源文件的 i 节点一样。</li><li>不能跨分区。</li><li>不能针对目录使用。</li></ol><p>软链接与硬链接的区别：硬链接就类似于拷贝，但是可以同步更新，源文件即使不在了，硬链接照样可以访问，因为是类似拷贝的。如果软链接源文件不在了，则它会报错找不到源文件。一个文件一定有一个 i 节点，但是一个 i 节点不一定只对应一个文件，硬链接就是一个特殊案例，一个 i 节点映射到了多个文件。注意硬链接在 Linux 中用的非常少！</p><h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><p>1、权限管理命令 chmod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change the permissions mode of a file；命令所在路径：/bin/chmod；作用：改变文件或目录权限</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chmod [选项] [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [文件或目录]</span><br><span class="line">    chmod [选项] [mode] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -R   递归修改</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可以同时做多个授权，中间用「,」逗号分隔</span><br><span class="line">    chmod u+rwx,g+rw,o=r test.txt</span><br></pre></td></tr></table></figure></p><p><strong>一个文件或目录的权限只有两个人可以更改：一个是该文件或目录的所有者，另一个就是管理员 root。</strong></p><p>权限数字表示：r=4，w=2，x=1。</p><p>2、文件目录权限总结<br><img src="/upload_image/File_Directories_Permission.png" alt="文件目录权限总结" title="文件目录权限总结"></p><p>注意：读写执行权限对目录的含义！！！要想删除一个文件，你必须有这个文件所在的目录的写权限。对于目录，r（查看目录内容）、x（进入目录）权限一般都是一起出现的。</p><p>3、权限管理命令 chown<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change file ownership；命令所在路径：/bin/chown；作用：改变文件或目录的所有者</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chown [用户] [文件或目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 改变文件 test.txt 的所有者为 root</span><br><span class="line">    chown root test.txt</span><br></pre></td></tr></table></figure></p><p><strong>在 Linux 系统中，改变一个文件或者目录的所有者，只有管理员 root 可以做这样的操作。</strong><br>可以使用 useradd 命令来添加一个用户，使用 passwd 为该用户设置一个密码。</p><p>4、权限管理命令 chgrp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change file group ownership；命令所在路径：/bin/chgrp；作用：改变文件或目录的所属组</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chgrp [用户组] [文件或目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 改变文件 test.txt 的所属组为 family</span><br><span class="line">    chgrp family test.txt</span><br></pre></td></tr></table></figure></p><p><strong>在 Linux 系统中，改变一个文件或者目录的所属组，只有管理员 root 可以做这样的操作。</strong></p><p>添加用户组命令：groupadd。</p><p>所有者：谁创建的文件谁就是文件的所有者；所属组：一个用户可以属于多个组，但是他总有个缺省组（缺省，即系统默认状态，意思与「默认」相同），每个用户创建文件的时候，它（该文件）的所属组就是该用户的缺省组，每个用户只能有一个缺省组。所以在创建一个文件的时候，它的所有者就是他自己即文件的创建者，它的所属组就是这个文件创建者的缺省组（了解即可）。</p><p>5、权限管理命令 umask<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 the user file-creation mask（mask 掩码的意思）；命令所在路径：Shell 内置命令；作用：显示、设置文件的缺省权限</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    umask [-S]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -S   以 rwx 形式显示新建文件缺省权限（注意 S 大写）</span><br></pre></td></tr></table></figure></p><p>在 Linux 权限管理有一个最基本的定义：缺省创建的文件是不能具有可执行权限的。所以在 Linux 系统中任何新建的文件都会把可执行权限去掉。这样做的目的是为了安全。<strong>注意只针对文件，对目录没有这样的限制。</strong></p><p>直接执行 umask 命令会得到一个 4 位的数字：0022。第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认的权限 rwxr-xr-x。而 Linux 系统中任何新建的文件都会把可执行权限去掉，所以你新建的任何一个文件的权限就是：rw-r–r–。</p><p>要想更改缺省权限，则需要先写出你要更改权限的数字，eg：rwxr-xr– 即 754，然后用 777-754=023，最后 umask 023 将缺省创建的权限改为 rwxr-xr–。虽然缺省创建的权限是可以更改的，但是并不建议这样去做。</p><h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><p>注意：尽量减少搜索这个操作，因为搜索它会占用大量的系统资源。在服务器高峰期里面，是不建议用搜索这个命令的。原则：不要在服务器使用高峰期的时候使用 find 命令来进行查找；在查找的过程中搜索的范围越小越好；搜索的条件越精准越好。</p><p>1、文件搜索命令 find<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/find；作用：文件搜索</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    find [搜索范围] [匹配条件]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 在目录 /etc 中查找文件 init</span><br><span class="line">    find /etc -name init</span><br><span class="line"></span><br><span class="line">    # -iname 不区分大小写</span><br><span class="line">    find /etc -iname init</span><br><span class="line"></span><br><span class="line">    # （注意数据块概念）在根目录下查找大于 100MB 的文件；+n 大于</span><br><span class="line">    # -n 小于，n 等于</span><br><span class="line">    find / -size +204800</span><br><span class="line"></span><br><span class="line">    # 在 /etc 下查找大于 80MB 且小于 100MB 的文件</span><br><span class="line">    # -a 两个条件同时满足，and</span><br><span class="line">    # -o 两个条件满足任意一个即可，or</span><br><span class="line">    find /etc -size +163840 -a -size -204800</span><br><span class="line"></span><br><span class="line">    # 在根目录下查找所有者为 root 的文件</span><br><span class="line">    find / -user root</span><br><span class="line"></span><br><span class="line">    # 在根目录下查找所属组为 root 的文件</span><br><span class="line">    find / -group root</span><br><span class="line"></span><br><span class="line">    # 在 /etc 下查找 5 分钟内被修改过属性的文件和目录</span><br><span class="line">    # -amin 访问时间 access；-cmin 文件属性 change；-mmin 文件内容 modify</span><br><span class="line">    # +n 大于多长时间，-n 多长时间以内，n 等于</span><br><span class="line">    find /etc -cmin -5</span><br><span class="line"></span><br><span class="line">    # -type 根据文件类型查找</span><br><span class="line">    # f 文件；d 目录；l 软链接文件</span><br><span class="line">    find /etc -type f</span><br><span class="line"></span><br><span class="line">    # -inum 根据 i 节点查找</span><br><span class="line">    find /etc -inum 12345</span><br><span class="line"></span><br><span class="line">    # 在当前目录中查找 iNode 为 666 的文件或目录并删除</span><br><span class="line">    find . -inum 666 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>注意利用 -name 搜索的话，它只会搜索文件名是 init的文件，而不像 windows 里面那样只要文件名包含 init 就都会被搜素到，可以理解为这是一种非常精准的搜索。要想像 windows 一样，可以做一个模糊的搜索即只要是包含 init 这 4 个连续的字母，就可以被搜素到，则：find /etc -name <em>init</em>，「<em>」号表示通配符，意思是只要文件名里有 init 就会被搜索到。init</em> 表示以 init 开头的；init??? 表示 init 以后有 3 个字符，问号匹配单个字符。Linux 中常用的两种通配符：* 号可以匹配任意字符，? 号可以匹配某个单个字符。</p><p>注意：在 Linux 系统中，一个数据块默认是 512 字节即 0.5kb；数据块是 Linux 系统中存储文件的最小单位。而 -size 的大小是用数据块换算的，所以 100MB 的文件所对应的就是 204800 个数据块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在 /etc 下查找 inittab 文件并显示其详细信息</span><br><span class="line"># 「-exec/-ok 命令 &#123;&#125; \;」对搜索结果执行操作</span><br><span class="line">find /etc -name inittab -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>前面还是正常写 find 要执行的查找的命令，找到这个结果以后，可以使用 -exec/-ok 直接连接一个命令即对 find 查找的结果做一些操作，再加上固定格式「{} \;」。{} 表示的是 find 查找的结果，表示对 find 查找的结果做一个替换，因为 find 查找的结果可能有多个，所有使用 {} 表示。「\」表示转义符，「;」表示结束。<br>注意：「;」分号，不要丢掉，而且「\」和「;」之间没有空格分隔！！！ -exec 和 -ok 的区别：-exec 直接执行，-ok 会一个个询问你是否执行（即会有询问确认环节）。</p><p>find -inum 使用场景，确定一个文件是否有硬链接。查看一个文件是否有硬链接：首先查看该文件的 i 节点，然后在整个它所在的分区里面（硬链接不能跨分区）做一个搜索，找 i 节点是你这个指定数字的文件，它就会把它的硬链接文件找到。</p><p>小结：find 命令 -name 根据文件名来查找；-iname 查找的时候不区分大小写；使用的通配符：* 匹配任意字符，? 匹配单个字符；-size 根据文件大小来查找，+ 大于多少，- 小于多少；-user 根据所有者来查找；-group 根据所属组来查找；-amin 根据访问时间来查找；-cmin 根据文件属性的更改查找；-mmin 根据文件内容更改来查找；-type 根据文件类型来查找，f 文件，d 目录，l 软链接；-inum 根据 i 节点来查找；-a 连接两个条件，表示两个条件都满足；-o 表示两个条件只有满足一个就可以；-exec 或者-ok 对搜索的结果直接进行操作，二者的区别只有一个就是 -ok 会询问确认，固定格式「{} \;」。</p><h2 id="其他搜索命令"><a href="#其他搜索命令" class="headerlink" title="其他搜索命令"></a>其他搜索命令</h2><p>1、文件搜索命令 locate<br><a href="https://blog.csdn.net/feifeilyj/article/details/52238209" target="_blank" rel="noopener">centos locate 命令安装</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/locate；作用：在文件资料库中查找文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    locate 文件名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    locate inittab</span><br></pre></td></tr></table></figure></p><p>该命令在查找的时候不像 find 来遍历你所搜索的范围，而是建立了一个文件资料库（该资料库会定期更新），它在找的时候不是在硬盘上找，而是在资料库里面找你有搜索的文件，所以速度很快。虽然使用 locate 命令查找的速度非常快，但是新建的文件使用该命令是找不到的，因为 locate 的文件资料库并没有更新。手动更新文件资料库命令：updatedb。</p><p>注意：/tmp 临时文件目录，并不在文件资料库所收录的文件范围之中，如果你要找的文件在 /tmp 目录下面，使用该命令是找不到的。如果希望 locate 命令在查找的时候不区分大小写，可以使用选项「-i」。</p><p>2、文件搜索命令 which<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/which；作用：搜索命令所在目录及别名信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    which 命令</span><br></pre></td></tr></table></figure></p><p>which 提供了一种快速查找一个命令所在的绝对路径的方法。除了可以找到命令所在的目录还可以找到该命令的别名，查看该命令本身是否有别名相关的信息。    实际上在 Linux 系统中，本身是没有询问确认的机制，之所以现在在 Linux 系统中有询问确认的选项，是因为它加了一个 -i 的选项，eg：在使用 rm 命令的时候，系统在找的时候找到的是一个别名而不是一个命令，它的别名等于「rm -i」，「-i」这个选项实际上就是一个询问确认的选项，所以这是别名的作用。</p><p>3、文件搜索命令 whereis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/whereis；作用：搜索命令所在目录及帮助文档路径</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    whereis [命令名称]</span><br></pre></td></tr></table></figure></p><p>whereis 除了可以找到命令所在的绝对路径，还可以找到这个命令它相关的帮助文档所在的位置，这个帮助文档就是 man 命令所展示的文件。</p><p>4、文件搜索命令 grep<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/grep；作用：在文件中搜寻字符匹配的行并输出，属于精确匹配</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    grep [选项] [指定字串] [文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -i   不分区大小写</span><br><span class="line">    -v   显示排除指定字串的行</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 列出在 /etc/issue 文件中包含 hello 字串的行，且忽略大小写</span><br><span class="line">    grep -i hello /etc/issue</span><br><span class="line"></span><br><span class="line">    # 列出 /etc/issue 文件中所有不包含 Hello 字串的行</span><br><span class="line">    grep -v Hello /etc/issue</span><br></pre></td></tr></table></figure></p><p>「-v  #」表示把 # 号所在的行都去掉，不管 # 号在什么位置，只要该行有 # 号，就都去掉。这样做是不太合理的，可能 # 位于中间，前面是有有效代码的。所以要想把行首以 # 开始的注释行去掉，要在 # 前面加一个表示行首的「^」即「^#」。使用 grep 命令查找文件中除注释以外的内容：<code>grep -v ^# 文件名</code>，需要注意的是针对 Shell 脚本的首行 # 号，应该做特殊处理。</p><p>小结：locate 快速定位到一个文件所在的路径（文件资料库），updatedb 更新文件资料库（有个别目录下的文件并不被收录到文件资料库中 /tmp），-i 不区分大小写；which 或者 whereis 查找命令所在的绝对路径；grep 在文件内容中查找，-i 不区分大小写，-v 排除查找。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(八) —— Linux 常用命令 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端基础(一)</title>
    <link href="yanchongsheng.github.io/2018/10/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
    <id>yanchongsheng.github.io/2018/10/09/前端基础-一/</id>
    <published>2018-10-09T06:45:29.000Z</published>
    <updated>2018-10-09T07:51:02.546Z</updated>
    
    <content type="html"><![CDATA[<p>1、注释</p><ul><li>HTML 的注释方法 <!--注释内容--></li><li>CSS 的注释方法 /<em>注释内容</em>/</li><li>JavaScript 的注释方法 /<em> 多行注释方式 </em>/ //单行注释方式</li></ul><p>2、BFC<br>块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、注释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML 的注释方法 &lt;!--注释内容--&gt;&lt;/li&gt;
&lt;li&gt;CSS 的注释方法 /&lt;em&gt;注释内容&lt;/em&gt;/&lt;/li&gt;
&lt;li&gt;JavaScript 的注释方法 /&lt;em&gt; 多行注释方式 &lt;/em&gt;/ //单行注释方式&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(七)</title>
    <link href="yanchongsheng.github.io/2018/09/28/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%83)/"/>
    <id>yanchongsheng.github.io/2018/09/28/Linux入门总结(七)/</id>
    <published>2018-09-28T13:22:24.000Z</published>
    <updated>2018-10-09T10:26:06.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(七) —— Shell 编程 </blockquote><a id="more"></a><h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><p>1、正则表达式与通配符<br><strong>正则表达式</strong>用来在<strong>文件中</strong>匹配符合条件的<strong>字符串</strong>，正则是<strong>包含匹配</strong>。grep、awk、sed 等命令可以支持正则表达式。</p><p><strong>通配符</strong>用来匹配符合条件的<strong>文件名</strong>，通配符是<strong>完全匹配</strong>。ls、find、cp 这些命令不支持正则表达式，所以只能使用 Shell 自己的通配符来进行匹配了。</p><p>注意：通配符和正则表达式这种区分，仅限于 Linux 的 Shell 当中。</p><p><img src="/upload_image/Basic_Regex.png" alt="基础正则表达式" title="基础正则表达式"></p><p>注意：这里是基础正则表达式，还存在扩展正则表达式。</p><p>注意：「^」位于中括号里面表示取反，位于外面表示行首。</p><p>test.txt 内容如下，将适用于以下所有用到 test.txt 的地方：</p><table><thead><tr><th>ID</th><th>Name</th><th>Gender</th><th>Score</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>male</td><td>86</td></tr><tr><td>2</td><td>lisi</td><td>female</td><td>90</td></tr><tr><td>3</td><td>wangwu</td><td>male</td><td>83</td></tr></tbody></table><ol><li><p>「*」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 匹配所有内容，包括空白行（即 a 出现了 0 次）</span><br><span class="line">grep &quot;a*&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配至少包含一个 a 的行</span><br><span class="line">grep &quot;aa*&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配至少包含两个 a 的行</span><br><span class="line">grep &quot;aaa*&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「.」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># s..d 匹配在 s 和 d 之间一定有两个字符的所在行</span><br><span class="line">grep &quot;s..d&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配在 s 和 d 之间有任意字符，把 .* 当做一个整体看，表示除换行符外任意一个字符出现任意次</span><br><span class="line">grep &quot;s.*d&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配所有内容</span><br><span class="line">grep &quot;.*&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「^」行首、「$」行尾示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 以 M 开头的行</span><br><span class="line">grep &quot;^M&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 以 n 结尾的行</span><br><span class="line">grep &quot;n$&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配空白行</span><br><span class="line">grep -n &quot;^$&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「[]」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 匹配 s 和 i 之间，要么是 a、要么是 o。注意：一个中括号只匹配一个字符</span><br><span class="line">grep &quot;s[ao]id&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配任意一个数字</span><br><span class="line">grep &quot;[0-9]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配以小写字母开头的行</span><br><span class="line">grep &quot;^[a-z]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配不用小写字母开头的行</span><br><span class="line">grep &quot;^[^a-z]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配不用字母开头的行</span><br><span class="line">grep &quot;^[^a-zA-Z]&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><p>注意：中括号里面是不能匹配换行符的。</p><ol><li>「\」示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 匹配使用「.」结尾的行</span><br><span class="line">grep &quot;\.$&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><p>注意：「.」在正则里面表示任意一个字符，所以这里要加转义符。</p><ol><li>其他示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># a 连续出现 3 次</span><br><span class="line">grep &quot;a\&#123;3\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 包含连续的 3 个数字的字符串所在行</span><br><span class="line">grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配最少用连续三个数字开头的行</span><br><span class="line">grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配在 s 和 i 之间，最少有一个 a，最多有三个 a</span><br><span class="line">grep &quot;sa\&#123;1,3\&#125;i&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h2><p>1、cut 字段提取命令「默认列之间的分隔符为 tab 键」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">格式：cut [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">    -f列号  提取第几列</span><br><span class="line">    -d分隔符  按照指定分隔符分割列</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 提取第二列</span><br><span class="line">    cut -f 2 test.txt</span><br><span class="line"></span><br><span class="line">    # 提取第二、第三列，注意不是范围，是指定的列，中间以逗号分隔</span><br><span class="line">    cut -f 2,3 test.txt</span><br><span class="line"></span><br><span class="line">    # 指定列之间的分隔符为「:」，默认为 tab 键</span><br><span class="line">    cut -d &quot;:&quot; -f 1,3</span><br></pre></td></tr></table></figure></p><p>注意：grep 命令表示在指定的文件中提取匹配的行，cut、awk 命令用来提取匹配的列。cut 命令中列之间的默认分割符为制表符即 tab 键。命令 grep -v [内容]，表示列出不包含指定的内容的行。grep 确认行，cut 确认列，利用这两个命令可以做一些操作，比如，获取所有普通用户的用户名：<code>cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1</code>。</p><p>cut 命令有一个局限就是「无法」识别空格（指识别起来超级麻烦扩展性还差）。对于空格的判断我们使用 awk 命令，但是因为 awk 比较复杂，所以能用 cut 的尽量不要用 awk，因为 cut 简单，但是存在局限性。</p><p>2、printf 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">格式：printf &apos;输出类型输出格式&apos; 输出内容</span><br><span class="line">输出类型：</span><br><span class="line">      %ns     输出字符串。n 是数字，指代输出几个字符</span><br><span class="line">      %ni     输出整数。n 是数字，指代输出几个数字</span><br><span class="line">      %m.nf   输出浮点数。m 和 n 是数字，指代输出的整数位数和小数位数。</span><br><span class="line">              eg：%8.2f 代表共输出 8 位数，其中 2 位是小数，6 位是整数</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">      \a   输出警告音</span><br><span class="line">      \b   输出退格键，即 Backspace 键</span><br><span class="line">      \f   清除屏幕</span><br><span class="line">      \n   换行</span><br><span class="line">      \r   回车，即 Enter 键</span><br><span class="line">      \t   水平输出 Tab 键</span><br><span class="line">      \v   垂直输出 Tab 键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 注意以下命令中是否加了单引号或双引号</span><br><span class="line">    printf %s 1 2 3 4 5 6</span><br><span class="line">    printf %s %s %s 1 2 3 4 5 6</span><br><span class="line">    printf &apos;%s %s %s&apos; 1 2 3 4 5 6</span><br><span class="line">    printf &apos;%s %s %s\n&apos; 1 2 3 4 5 6</span><br></pre></td></tr></table></figure></p><p>printf 是格式化输出命令，类似于 echo 命令。注意：printf 后面不能直接加文件名，也不能接受管道符的内容。但是可以使用 <code>printf &#39;%s&#39; $(cat 文件名)</code> 的形式输出命令执行结果，需要注意的是 printf 没有对格式进行任何调整。</p><p>printf 命令没有 cat 和 echo 的自动格式化功能，为什么还要学习 printf 命令，是因为在 awk 命令中不能调用系统命令 cat 或者 echo，只能使用 printf。</p><p>在 awk 命令的输出中支持 print 和 printf 命令：</p><blockquote><p>print：print 会在每个输出之后自动加入一个换行符（Linux 默认没有 print 命令）。<br>printf：printf 是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符。</p></blockquote><p>注意：print 只能在 awk 中使用。printf 命令在 Linux 系统中直接使用的几率不大，主要是在 awk 命令中使用。</p><p>3、awk 命令，注意单引号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line">    awk &apos;条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ...&apos; 文件名</span><br><span class="line"></span><br><span class="line">条件：</span><br><span class="line">    一般使用关系表达式作为条件</span><br><span class="line">    x &gt; 10</span><br><span class="line">    x &lt;= 10</span><br><span class="line"></span><br><span class="line">动作：</span><br><span class="line">    格式化语句</span><br><span class="line">    流程控制语句</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # $2 表示第 2 列，$4 表示第 4 列</span><br><span class="line">    awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br><span class="line"></span><br><span class="line">    df -h | awk &apos;&#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&apos;</span><br><span class="line"></span><br><span class="line">典例：获取系统中根分区硬盘的使用率，可以用来报警，如果超过80则给管理员提示。</span><br><span class="line">    df -h | grep 只有根分区才存在的字符串 | awk &apos;&#123;printf $5&#125;&apos; | cut -d &quot;%&quot; -f 1</span><br></pre></td></tr></table></figure></p><p>注意：awk 命令虽然是列提取命令，但是它处理数据的时候，是先读入一行数据，然后把这行数据所有的内容都复制给对应的变量，$1 代表第一列，依次类推，然后再判断条件是否符合，对满足条件的执行相应的动作。</p><p>注意：awk 默认是以空格或者制表符作为分割符的。</p><p>注意：BEGIN 必须大写。它位于大括号前，表示它是一个条件，只有满足了这个条件，其后的动作才会被执行。BEGIN 的作用是：在所有的数据读取之前，执行其后面相对应的动作。注意所有的动作都要用单引号括起来。</p><ol><li><p>BEGIN 表示最先执行 BEGIN 条件后面的动作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在进行整正的数据读取之前，即 awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt，打印「This is a transcript.」这句话</span><br><span class="line">awk &apos;BEGIN&#123;printf &quot;This is a transcript. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br></pre></td></tr></table></figure></li><li><p>FS 内置变量<br>FS 的作用是指定分隔符的。注意：awk 命令在处理的时候是先读入第一行数据，然后再执行相应的动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出结果中，第一行数据没有按照预期输出</span><br><span class="line">awk &apos;&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd</span><br><span class="line"></span><br><span class="line"># 改进：读取第一条数据之前，先把分隔符变成「:」</span><br><span class="line">awk &apos;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>END 表示最后执行 END 条件后面的动作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 表示在输出 &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125; 动作中的内容之后，输出 &#123;printf &quot;The end. \n&quot;&#125; 动作中的内容</span><br><span class="line">awk &apos;END&#123;printf &quot;The end. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br></pre></td></tr></table></figure></li><li><p>关系运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取成绩大于 87 的用户名，grep -v Name 的作用是去掉标题行</span><br><span class="line">cat test.txt | grep -v Name | awk &apos;$4 &gt;= 87 &#123;printf $2 &quot;\n&quot;&#125;&apos;</span><br></pre></td></tr></table></figure></li></ol><p>4、sed 命令<br>sed 是一种几乎包括在所有 Unix 平台（包括 Linux）的轻量级<strong>流编辑器</strong>。sed 主要是用来将数据进行选取、替换、删除、新增的命令。</p><p>sed 其实不是截取命令，其实是一个流的编辑器。相当于一个编辑器。既然已经学了 vim，为什么还有学习 sed 呢？因为 vim 命令只能修改文件，不能直接修改命令结果里的内容。要想使用 vim 修改命令的输出，则需要先把输出保存到文件当中，然后再用 vim 修改文件。sed 不光可以修改文件，因为其是一个流编辑器，所以可以从管道符接受数据来进行修改，即 sed 支持管道符操作。实际操作中主要用在对命令的结果进行操作，但是在 shell 编程中，sed 是一个重要的流数据处理编辑器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    sed [选项] &apos;[动作]&apos; 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n  一般 sed 命令会把所有数据都输出到屏幕，如果加入此选项，则只会把经过 sed 命令处理的行输出到屏幕</span><br><span class="line">    -e  允许对输入数据应用多条 sed 命令编辑</span><br><span class="line">    -i  用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出，不光输出的数据会更改，源数据文件也会被更改。</span><br><span class="line"></span><br><span class="line">动作：</span><br><span class="line">    a \:    追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    c \:    行替换，用 c 后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    i \:    插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    d:      删除，删除指定的行</span><br><span class="line">    p:      打印，输出指定的行</span><br><span class="line">    s:      字符串替换，用一个字符串替换另外一个字符串。格式为「行范围/s/就字符串/新字符串/g」</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看文件的第二行，会输出全部内容</span><br><span class="line">    sed &apos;2p&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 只显示经过 sed 命令处理的行</span><br><span class="line">    sed -n &apos;2p&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 针对管道符结果操作</span><br><span class="line">    df -h | sed -n &apos;2p&apos;</span><br><span class="line"></span><br><span class="line">    # 删除第二到第四行的数据，但不修改文件本身</span><br><span class="line">    sed &apos;2,4d&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第二行后追加 hello</span><br><span class="line">    sed &apos;2a hello&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第二行前插入两行数据</span><br><span class="line">    sed &apos;2i hello \</span><br><span class="line">    world&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 数据替换</span><br><span class="line">    sed &apos;2c No such person&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第三行中，把 90 替换成 99</span><br><span class="line">    sed &apos;3s/90/99/g&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # sed 操作的数据直接写入文件</span><br><span class="line">    sed -i &apos;3s/90/99/g&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 同时把 zhangsan 和 lisi 替换为空</span><br><span class="line">    sed -e &apos;s/zhangsan//g;s/lisi//g&apos; test.txt</span><br></pre></td></tr></table></figure><h2 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h2><p>1、排序命令 sort<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    sort [选项] 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -f    忽略大小写</span><br><span class="line">    -n    以数值型进行排序，默认使用字符串型排序</span><br><span class="line">    -r    反向排序</span><br><span class="line">    -t    指定分割符，默认分隔符是制表符</span><br><span class="line">    -k n[,m]    按照指定的字段范围排序。从第 n 字段开始，m 字段结束（默认到行尾）</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 排序用户信息文件</span><br><span class="line">    sort /etc/passwd</span><br><span class="line"></span><br><span class="line">    # 反向排序</span><br><span class="line">    sort -t /etc/passwd</span><br><span class="line"></span><br><span class="line">    # 指定分隔符「:」。用第三字段开头，第三字段结尾排序，就是只用第三字段排序（类比数据库 order by 后面可以跟多个字段）</span><br><span class="line">    sort -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line"></span><br><span class="line">    # -n 表示将提取的字段当成数字来对待</span><br><span class="line">    sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br></pre></td></tr></table></figure></p><h2 id="条件判断（即测试一个条件是否成立）"><a href="#条件判断（即测试一个条件是否成立）" class="headerlink" title="条件判断（即测试一个条件是否成立）"></a>条件判断（即测试一个条件是否成立）</h2><p>1、按照文件类型进行判断（记住蓝色的就行，其它的了解）<br><img src="/upload_image/Judge_File_Type.png" alt="按照文件类型进行条件判断" title="按照文件类型进行条件判断"></p><p>2、两种判断格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式一:</span><br><span class="line">  # 注意该命令执行后没有任何输出，要想知道该命令的输出结果，可以使用 $? 来获取结果，「echo $?」打印结果</span><br><span class="line">  # $? 的作用是判断上一条命令是否正确执行，正确执行返回 0，否则返回其他数字</span><br><span class="line">  test -e /root/install.log</span><br><span class="line"></span><br><span class="line">格式二:</span><br><span class="line">  # 注意两端必须有空格</span><br><span class="line">  [ -e /root/install.log ]</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line">  # 第一个判断命令如果正确执行，则打印 yes，否则打印 no</span><br><span class="line">  [ -d /root ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br></pre></td></tr></table></figure></p><p>这种判断主要用在 Shell 脚本当中，而在脚本当中最常用的判断格式是用中括号。</p><p>3、按照文件权限进行判断<br><img src="/upload_image/Judge_File_Permission.png" alt="按照文件权限进行条件判断" title="按照文件权限进行条件判断"></p><p>注意：以上权限部分不区分所有者、所属组、其他人，只要该文件有这个权限，就为真。</p><p>4、两个文件之间进行比较<br><img src="/upload_image/Two_File_Compare.png" alt="两个文件之间进行比较" title="两个文件之间进行比较"></p><p>5、两个整数之间比较<br><img src="/upload_image/Two_Integer_Compare.png" alt="两个整数之间比较" title="两个整数之间比较"><br>-ne ：  (not equal) 不相等<br>-gt ：  (greater than) 大于<br>-lt ：  (less than) 小于<br>-ge ：  (greater than or equal) 大于或等于<br>-le ：  (less than or equal)小于或等于</p><p>6、字符串的判断<br><img src="/upload_image/Judge_String.png" alt="字符串的判断" title="字符串的判断"><br>注意：== 会把参数当成字符串</p><p>7、多重条件判断<br><img src="/upload_image/Judge_Many_Condition.png" alt="多重条件判断" title="多重条件判断"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(七) —— Shell 编程 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(六)</title>
    <link href="yanchongsheng.github.io/2018/09/25/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AD)/"/>
    <id>yanchongsheng.github.io/2018/09/25/Linux入门总结(六)/</id>
    <published>2018-09-25T13:45:15.000Z</published>
    <updated>2018-10-09T08:35:25.246Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(六) —— Shell 基础 </blockquote><a id="more"></a><h2 id="Shell-概述"><a href="#Shell-概述" class="headerlink" title="Shell 概述"></a>Shell 概述</h2><p>1、Shell 是什么？<br>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统程序，用户可以用 Shell 来启动、挂起、停止甚至编写一些程序。</p><p>Shell 还是一个功能相当强大的编程语言。Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。</p><p>2、Shell 的分类<br>Bourne Shell：从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh。</p><p>C Shell：C Shell 主要在 BSD (Berkeley Software Distribution，是一个操作系统的名称，衍生自 Unix，被称为伯克利 Unix) 版的 Unix 系统中使用，其语法和 C 语言相类似而得名。</p><p>Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh、ksh、Bash、psh、zhs；C 家族主要包括：csh、tcsh。</p><p>Bash (Bourne Again Shell): Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。</p><p>3、Linux 支持的 Shell<br>在 「/etc/shells」文件中保存着当前系统支持的 Shell。注意：只要是系统支持的 Shell，我们就可以通过输入对应的 Shell 名字来进行切换。</p><p>4、echo 输出命令<br>echo 是反射、回声的意思。是用来输出的命令。格式：<code>echo [选项][输出内容]</code>；选项：<code>-e</code>，支持反斜杠控制的字符转换。<br>eg：<code>echo &#39;Hello World!&#39;</code>  注意：感叹号在 Shell 中有特殊的作用，所以这里使用单引号。</p><p>5、Linux 中常见的转义符<br><img src="/upload_image/Escape_Character.png" alt="Linux 中常见的转义符" title="Linux 中常见的转义符"></p><p>eg：<code>echo -e &quot;ab\bc&quot;</code> 删除左侧字符；输出结果：<code>ac</code>；分析：<code>\b</code> 代表的是退格键。<br>eg：<code>echo -e &quot;a\tb\tc\nd\te\tf&quot;</code> 制表符与换行符。<br>eg: <code>echo -e &quot;\e[1;31m abcd \e[0m&quot;</code> 带颜色输出内容；输出结果：<code>红色的 abcd</code>；分析：31m=红色；「\e[1;」表示开启颜色输出，「\e[0m」    表示结束颜色输出。</p><p>6、第一个 Shell 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/Bash</span><br><span class="line"><span class="meta">#</span>The first program</span><br><span class="line"><span class="meta">#</span>Author: YanChongsheng E-mail: yanchongsheng@gmail.com</span><br><span class="line">echo -e "YanChongsheng is the most handsome man in China."</span><br></pre></td></tr></table></figure><p>注意：「#!/bin/Bash」这句话不是注释，而是标称，标称以下内容是 Shell 脚本。在 Linux 中以 # 号开头的是注释。</p><p>7、脚本执行</p><ul><li>方式一：赋予执行权限，直接运行 <code>赋予权限：chmod 755 hello.sh 运行脚本：./hello.sh</code></li><li>方式二：通过 Bash 调用执行脚本：<code>bash hello.sh</code></li></ul><p>注意：使用 base 执行脚本的时候，脚本甚至可以没有执行权限。它的意思是通过这个 Shell 来解释这个 shell 脚本文件，所以只要里面的内容是正确的，连执行权限都可以不用给就可以执行，但是最习惯的执行方法还是第一种。</p><p>cat 命令给其加上选项 -A ：表示查看所有的文件内容，包括隐藏字符，例如回车符就属于文件中的隐藏字符。在 Linux 中，回车符识别为「$」号。但是 Windows 中的回车符是「^M$」，表示这个 shell 是在 windows 中编辑完成的，要想在 Linux 中执行，就需要进行转换，利用命令: dos2unix [文件名]。注意：如果 dos2unix 命令没有则需要安装：<code>yum -y install dos2unix</code>。</p><h2 id="Bash-的基本功能"><a href="#Bash-的基本功能" class="headerlink" title="Bash 的基本功能"></a>Bash 的基本功能</h2><p>1、历史命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：histor [选项][历史命令保存文件]</span><br><span class="line">选项：</span><br><span class="line">    -c  清空历史命令</span><br><span class="line">    -w  把缓存中的历史命令写入历史命令保存文件「~./bash_histor」</span><br></pre></td></tr></table></figure></p><p>注意：每次登陆之后所敲的命令都会放在 history 即内存中，并不会放入 ~/.bash_history 文件，而是等正常退出以后，才会将内存中的历史命令写入到 ~/.bash_history 文件中的。注意：-c 会清除内存中和文件中的所有的历史命令。</p><p>历史命令默认会保存 1000 条，可以在环境变量配置文件「/etc/profile」中进行修改 <code>HISTSIZE=1000</code> 注意：重新登录以后才会生效。如果超过 1000，则删除第 1 条命令，保存第 1001 条命令。</p><p>历史命令的调用：</p><ol><li>使用上、下箭头调用以前的历史命令</li><li>使用「!n」调用第 n 条历史命令</li><li>使用「!!」执行上一条命令</li><li>使用「!字符」执行最后一条以该字符串开头的命令</li></ol><p>2、命令别名：<br>设定命令别名：alias 别名=’原命令’。注意：用命令行方式定义的别名它只会临时生效，一旦系统重启，这个别名就会消失。<br>查询命令别名：alias 别名</p><p>3、命令执行顺序</p><ol><li>第一顺位：执行用绝对路径或相对路径执行的命令。</li><li>第二顺位：执行别名。</li><li>第三顺位：执行 Bash 的内部命令。</li><li>第四顺位：执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令。</li></ol><p>输出环境变量：<code>echo $PATH</code></p><p>让别名永久生效：<code>vim /root/.bashrc</code> 注意：修改的是用户对应家目录下的「./bashrc」文件。rc 可以简单的理解为 user config 的简写，取 user 的最后一个字母 r 和 config 的第一个字母 c 组成 rc。</p><p>删除别名：<code>unalias 别名</code></p><p>4、Bash 常用快捷键<br><img src="/upload_image/Bash_Shortcut_Key.png" alt="Bash 常用快捷键" title="Bash 常用快捷键"></p><p>5、标准输入输出</p><table><thead><tr><th>设备</th><th>设备文件名</th><th>文件描述符</th><th>类型</th></tr></thead><tbody><tr><td>键盘</td><td>/dev/stdin</td><td>0</td><td>标准输入</td></tr><tr><td>显示器</td><td>/dev/stdout</td><td>1</td><td>标准输出</td></tr><tr><td>显示器</td><td>/dev/stderr</td><td>2</td><td>标准错误输出</td></tr></tbody></table><p>6、输出重定向<br><img src="/upload_image/Output_redirect.png" alt="输出重定向" title="输出重定向"></p><p>注意：不是所有的命令都可以使用输出重定向的，这个命令必须得有输出才可以。<br>注意：错误输出中，2 和 大于号之间不能有空格。</p><p><img src="/upload_image/Output_All.png" alt="正确输出和错误输出同时保存" title="正确输出和错误输出同时保存"></p><p>注意：「/dev/null」是 Linux 中的一个特殊文件，可以把它当成垃圾箱，相当于不保存任何输出。</p><p>7、输入重定向「注意：输入重定向了解即可」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：wc [选项][文件名]</span><br><span class="line">选项：</span><br><span class="line">    -c  统计字节数 (byte) print the byte counts</span><br><span class="line">    -m  统计字符数 (character) print the character counts</span><br><span class="line">    -w  统计单词数 (word)</span><br><span class="line">    -l  统计行数 (line)</span><br></pre></td></tr></table></figure></p><p>注意：wc 可以统计键盘输入，输入的行数、单词数、字节数，输入完成之后按 ctrl + d，结束并进行统计。注意回车换行符也会被当成字节进行统计。</p><p>把文件作为命令的输入：<code>命令&lt;文件</code>。eg：<code>wc &lt; anaconda-ks.cfg</code></p><p>8、多命令顺序执行<br><img src="/upload_image/Execute_Many_Command.png" alt="多命令顺序执行" title="多命令顺序执行"></p><p>eg：<code>ls; date; cd /user; pwd</code><br>eg: <code>命令 &amp;&amp; echo yes || echo no</code></p><p><img src="/upload_image/Example_Many_Command.png" alt="例子" title="例子"><br>命令 dd 是磁盘或者说是数据复制的命令，但是它不是 cp，cp 命令只能复制文件，但是 dd 命令能复制特殊文件，也能复制分区甚至整个硬盘，不仅复制分区或硬盘的数据，还复制分区或硬盘的文件系统。dd 主要是用来进行磁盘复制。</p><p>9、管道符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：命令1 | 命令2</span><br></pre></td></tr></table></figure></p><p><code>命令1</code> 的<code>正确输出</code>作为<code>命令2</code> 的<code>操作对象</code>。</p><p>注意：命令1 必须正确输出，否则命令2 不会正常执行。</p><p>10、grep 命令，在文件中搜索符合条件的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：grep [选项] &quot;搜索内容&quot;</span><br><span class="line">选项：</span><br><span class="line">    -i  忽略大小写</span><br><span class="line">    -n  输出行号</span><br><span class="line">    -v  反向查找 (注意：-v 查找的是不匹配的行，即反向查找)</span><br><span class="line">    --color=auto  搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure></p><p>通配符<br><img src="/upload_image/Wildcard.png" alt="通配符" title="通配符"></p><p>Bash 中的特殊符号<br><img src="/upload_image/Special_Character.png" alt="Bash 中的特殊符号" title="Bash 中的特殊符号"></p><p>注意：通配符是用来匹配文件名的，起码在 Linux 系统当中是用来匹配文件名的。</p><p>$ 和 $() 的区别是：$ 是用于调用变量的值；而 $() 是用来引用系统命令。</p><h2 id="Bash-的变量"><a href="#Bash-的变量" class="headerlink" title="Bash 的变量"></a>Bash 的变量</h2><p>1、变量设置规则  </p><ol><li><p>变量名称可以由字母、数字、下划线组成，但是不能以数字开头。</p></li><li><p>在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。</p></li><li><p>变量用等号连接值，<strong>等号左右两侧不能有空格</strong>。</p></li><li><p>变量的值如果有空格，需要使用单引号或双引号包括。</p></li><li><p>在变量的值中，可以使用「\」转义符。</p></li><li><p>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名” 或用 ${变量名} 包含。</p></li><li><p>如果是把命令的结果作为变量值赋值给变量，则需要使用反引号或 $() 包含<strong>命令</strong>。</p></li><li><p>环境变量名建议大写，便于区分。</p></li></ol><p>环境变量名大写，目的是为了区分。因为环境变量会让 Linux 当中所有的 Shell 都能使用，Linux 的系统命令也是在所有的 Shell 中都能使用，但是系统命令都是小写，为了让系统命令和环境变量区分开，建议把环境变量都写成大写。</p><p>2、变量分类</p><ol><li>用户自定义变量</li><li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。</li><li>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</li><li>预定义变量：是 Bash 中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li></ol><p>其实位置参数变量是预定义变量的一种，由于位置参数变量相对来说较多，所以我们习惯上将位置参数变量单独作为一个分类。所以这两种变量的限制是一样的，只能更改值。</p><p>3、本地变量<br>用户自定义变量又称为本地变量。「$变量名」的作用是调用变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 定义变量</span><br><span class="line">aa=123</span><br><span class="line"></span><br><span class="line"># 变量叠加</span><br><span class="line">aa=&quot;$aa&quot;456 # 结果：123456</span><br><span class="line">aa=$&#123;aa&#125;789 # 结果：123456789</span><br><span class="line"></span><br><span class="line"># 变量调用</span><br><span class="line">echo $name</span><br><span class="line"></span><br><span class="line"># 变量查看</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># 变量删除</span><br><span class="line">unset name</span><br></pre></td></tr></table></figure></p><p>set 命令：表示查看系统的所有变量，包括系统的环境变量，以及系统变量，自定义的变量。<br>总结：变量的定义、叠加、调用、查看、删除；变量的概念、变量的规则、变量的分类。</p><p>4、环境变量是什么？<br>用户自定义变量只在当前 Shell 中生效。（使用命令行定义的）环境变量会在当前 Shell 和这个 Shell 的所有子 Shell 当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的 Shell 中生效。</p><p>5、设置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 声明变量</span><br><span class="line">export 变量名=变量值</span><br><span class="line"></span><br><span class="line"># 查询变量</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"># 删除变量</span><br><span class="line">unset 变量名</span><br><span class="line"></span><br><span class="line"># 将已经定义好的本地变量变为环境变量</span><br><span class="line">export 变量名</span><br></pre></td></tr></table></figure></p><p>注意：系统当前本身就是在一个 Shell 里面，我们可以直接输入 csh、或 bash 表示进入对应的 Shell，而系统本身的 shell 就是 csh 或者 bash 的父 Shell，这样就创建了一个子 Shell，当然子 Shell 里面还可以有子子 Shell。</p><p>如何查询和确定 Shell 呢？<br>使用命令 <code>pstree</code>，它的作用是确定进程数。</p><p>6、系统常见环境变量<br>PATH：系统查找命令的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出 PATH</span><br><span class="line">echo $PATH</span><br><span class="line"></span><br><span class="line"># PATH 变量叠加</span><br><span class="line">PATH=&quot;$PATH&quot;:/root/sh</span><br></pre></td></tr></table></figure></p><p>PS1：定义系统提示符的变量</p><p><img src="/upload_image/PS1_Character.png" alt="定义系统提示符" title="定义系统提示符"></p><p>eg：<code>PS1=[\u@\h \W]\$</code>。注意习惯在 $ 最后加一个空格，要不然你的命令会紧挨着提示符 # 或者 $。这种写法只是临时生效。</p><p>注意：env 是专门用来查看当前系统的环境变量的。严格来说 PS1 并不是环境变量，因为 env 命令查看不到，必须使用 set 命令查看。虽然它不是环境变量，但是它是系统预留专门用作定义系统操作环境的一个变量。它是环境变量的一个子分支。</p><p><strong>注意：Linux 以冒号为分割符号。</strong></p><p>7、位置参数</p><p><img src="/upload_image/Location_Param.png" alt="位置参数" title="位置参数"></p><p>位置参数变量最大的作用就是向程序中传递需要的值。它的好处是可以在命令执行的同时接受参数。</p><p>注意：位置参数变量的名称和作用都是固定的。我们能做的只是在里面传入不同的值。</p><p>注意：要想进行数值运算，必须加 $(()) 双小括号括起来，它才能进行数值计算，这是 Linux Shell 的标准格式。</p><p>注意：$# 不会计算命令本身，它计算的仅仅只是参数。</p><p><code>$*</code> 和 $@ 的区别：<code>$*</code> 中的所有参数看成是一个整体。$@ 中的每个参数看成是独立的。</p><p>8、预定义变量<br><img src="/upload_image/Predefined_Variable.png" alt="预定义变量" title="预定义变量"></p><p>其实位置参数变量就是预定义变量当中的一个分类，其特点是不能改变变量名，变量的作用也是固定的。</p><p>$? 用来接收和判断上一条命令是否正确执行。注意：&amp;&amp; || 利用的就是 $? 来判断上一条命令是否正确执行的。</p><p>9、接受键盘输入，read 会把键盘输入的数据赋值给后面的变量中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：read [选项] [变量名]</span><br><span class="line">选项：</span><br><span class="line">    -p &quot;提示信息&quot;：在等待 read 输入时，输出提示信息</span><br><span class="line">    -t 秒数：read 命令会一直等待用户输入，使用此选项可以指定等待时间</span><br><span class="line">    -n 字符数：read 命令只接受指定的字符数，就会执行</span><br><span class="line">    -s：隐藏输入的数据，适用于机密信息的输入</span><br></pre></td></tr></table></figure></p><p>注意：如果不加 -n 选项，read 命令在回车以后才会结束，如果加了 -n 选项，则字符数达到 -n 执行的数字，则自动结束 read 并执行。</p><h2 id="Bash-的运算符"><a href="#Bash-的运算符" class="headerlink" title="Bash 的运算符"></a>Bash 的运算符</h2><p>注意：Linux 的 Shell 中变量的类型默认都是字符串型。</p><p>1、declare 声明变量类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：declare [+/-][选项] 变量名</span><br><span class="line">选项：</span><br><span class="line">    -：给变量设定类型属性</span><br><span class="line">    +：取消变量的类型属性</span><br><span class="line"></span><br><span class="line">    -i：将变量声明为整型（integer）</span><br><span class="line">    -x：将变量声明为环境变量</span><br><span class="line">    -p：显示指定变量的被声明的类型</span><br></pre></td></tr></table></figure></p><p>2、数值运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line"></span><br><span class="line"># 方法1</span><br><span class="line">declare -i cc=$aa+$bb</span><br><span class="line"></span><br><span class="line"># 方法2</span><br><span class="line"># 利用 expr 或 let 数值运算工具。注意：「+」号左右两侧必须有空格。</span><br><span class="line">cc=$(expr $aa + $bb)</span><br><span class="line"></span><br><span class="line"># 方法3</span><br><span class="line"># $((运算式)) 或 $[运算式]</span><br><span class="line">cc=$(($aa+$bb))</span><br><span class="line">cc=$[$aa+$bb]</span><br></pre></td></tr></table></figure></p><p>3、运算符<br><img src="/upload_image/Linux_Operator.png" alt="运算符" title="运算符"></p><p>注意：此处数字越大，优先级越高。</p><p>4、变量测试与内容替换<br><img src="/upload_image/Variable_Alternative_Test.png" alt="变量测试与内容替换" title="变量测试与内容替换"></p><p>主要作用：通过 x 的值来确定 y 的情况。这块内容了解即可，完全可以 if 语句来替代，只是系统提供的更简洁、高效一点，用到的时候查一下能看懂就行，不要可以去记忆。</p><h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><p>1、source 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：source 配置文件</span><br><span class="line">或</span><br><span class="line">格式：. 配置文件</span><br></pre></td></tr></table></figure></p><p>注意：source 命令的作用是让你的配置文件生效，即让系统重新读取一遍配置文件。（正常情况下配置文件生效需要重新登录一次，但是利用 source 命令可以直让配置文件生效）。<br>注意：点「.」和配置文件之间有空格，点「.」其实就是 source 的缩写。</p><p>2、环境变量配置文件简介<br>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如 PATH、HISTSIZE、PS1、HOSTNAME 等默认环境变量。</p><p>系统中主要的 5 类环境变量配置文件：</p><ol><li>/etc/profile 的作用：USER 变量、LOGNAME 变量、MAIL 变量、PATH 变量、HOSTNAME 变量、HISTSIZE 变量、umask、调用 /etc/profile.d/*.sh 文件。</li><li>~/.bash_profile 的作用：调用了 ~/.bashrc 文件、在 PATH 变量后面加入了 「:$HOME/bin」这个目录。</li><li>~/.bashrc 的作用：定义默认别名、调用 /etc/bashrc。</li><li>/etc/bashrc 的作用：PS1 变量、umask、PATH 变量、调用 /etc/profile.d/*.sh 文件。</li><li>/etc/profile.d/*.sh</li></ol><p>注意：只要是保存在 /etc 目录中的，表示对所有登录到该 Linux 系统的用户都生效。~/ 表示当前用户的家目录，「.」表示该文件是隐藏文件，这些配置文件针对的是当前用户。「~」表示家目录的意思。</p><p>3、环境变量配置文件作用</p><p><img src="/upload_image/Profile_Invoke_Order.png" alt="环境变量配置文件调用顺序" title="环境变量配置文件调用顺序"></p><p>注意：环境变量默认赋值的时候分两种情况<br>1.一种是用户通过输入用户名和密码的正常登陆。<br>2.一种是用户通过命令切换到子 Shell 的登陆，这种情况是没有输入用户名密码过程的。<br>这两种不同的登陆方法，它读取的配置文件是不一样的。</p><p>注意：环境变量配置文件它们之间是有优先级的。越后面读取的配置文件，其优先级越高，因为后面定义的变量会覆盖前面的变量。</p><p>需要输入用户名密码的正常登录情况配置文件的读取顺序：<br>/etc/profile「 ——&gt; …… ——&gt; /etc/sysconfig/i18n (新版的 Linux 为 /etc/locale.conf) 这些都是 /etc/profile 文件中调用的子文件或子子文件」当完成 /etc/profile 的所有调用以后 /etc/profile 就会将它的调用传递给下一个环境变量配置文件即 ~./bash_profile，然后照着上图依次往下传递。</p><p>发现 /etc/profile 和 /etc/bashrc 中有很多内容是重复的，如 PATH、umask、PS1，注意这个不是单单只是重复。你会发现 /etc/bashrc 中重复定义变量的地方有这样的注释「We’re not a login shell」即该文件定义的是没有登录情况的 Shell 的环境变量。</p><p>4、注销时生效的环境变量配置文件<br>~/.bash_logout 默认为空，可以在里面写一些退出登录时候的操作，比如清空历史命令等操作。</p><p>5、其他配置文件<br>~/.bash_history 历史命令保存的地方。一般不要清空，但是有一种情况例外，比如你给某个服务设置密码，如 mysql，mysql 设置密码的时候使用的是明文（注意：是明文）系统命令，它会把密码记录在历史文件中，所以要清空明文密码记录。</p><p>6、Shell 登录信息<br>1.<strong>本地</strong>终端欢迎信息：/etc/issue<br><img src="/upload_image/Local_Terminal_Character.png" alt="本地终端转义符" title="本地终端转义符"></p><p>注意：欢迎信息不要写 welcome 之类的，应该写的是警告信息。注意：针对的是本地登录。</p><p>2.<strong>远程</strong> 终端欢迎信息：/etc/issue.net<br>注意：转义符在 /etc/issue.net 文件中不能使用，即本地终端的转义符在这里都不能使用，这里只能写纯文本信息。是否显示此欢迎信息由 ssh 的配置文件 /etc/ssh/sshd_config 决定，加入「Banner /etc/issue.net」行才能显示。（记得重启 ssh 服务）。重启 ssh 服务：<code>service sshd restart</code></p><p>3.<strong>本地和远程</strong>登录后欢迎信息：/etc/motd<br>不管是本地登录，还是远程登录，都可以显示此欢迎信息。但是，它是登录后的欢迎信息。刚才那两个文件是登录前的提示信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(六) —— Shell 基础 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="yanchongsheng.github.io/2018/09/21/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>yanchongsheng.github.io/2018/09/21/工厂模式/</id>
    <published>2018-09-21T07:45:07.000Z</published>
    <updated>2018-09-21T11:10:57.172Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"> 工厂模式 </blockquote></p><p>&lt;! – more –&gt;</p><p>1、工厂模式（Factory Pattern），属于创建型模式，它提供了一种创建对象的最佳方式。<strong>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象</strong>。即告诉对象工厂我需要一个什么样的对象，然后就可以坐等对象工厂返回你需要的对象了。</p><p>2、简单工厂模式<br>到底要实例化哪个类，将来会不会增加实例化对象的种类，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>[大话设计模式]<br>[菜鸟教程]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt; 工厂模式 &lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;! – more –&amp;gt;&lt;/p&gt;
&lt;p&gt;1、工厂模式（Factory Pattern），属于创建型模式，它提供了一种创建对象的最佳方
      
    
    </summary>
    
      <category term="设计模式" scheme="yanchongsheng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="yanchongsheng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>推荐阅读</title>
    <link href="yanchongsheng.github.io/2018/09/20/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/"/>
    <id>yanchongsheng.github.io/2018/09/20/推荐阅读/</id>
    <published>2018-09-20T08:41:53.000Z</published>
    <updated>2018-09-20T08:52:09.530Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 记录在工作学习个人认为优秀的博客 </blockquote><a id="more"></a><p>1、<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a></p><p>2、<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></p><p>3、<a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux 命令大全</a></p><p>4、<a href="https://coolshell.cn/" target="_blank" rel="noopener">左耳朵耗子</a></p><p>5、<a href="https://legacy.gitbook.com/explore?lang=zh" target="_blank" rel="noopener">GitBook</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 记录在工作学习个人认为优秀的博客 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人思考" scheme="yanchongsheng.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
    
      <category term="个人思考" scheme="yanchongsheng.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(七)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%83)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Java入门总结(七)/</id>
    <published>2018-09-19T11:45:19.000Z</published>
    <updated>2018-09-21T07:27:59.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(七) —— 随机 </blockquote><a id="more"></a><p>1、Random 类的构造方法可以接受一个 long 类型的种子参数。种子决定了随机产生的序列，种子相同，产生的随机数序列就是相同的。</p><p>2、为什么要指定种子？指定种子是为了实现可重复的随机。</p><p>3、Random 产生的随机数不是真正的随机数，相反，它产生的随机数一般称之为伪随机数，真正的随机数比较难以产生，计算机程序中的随机数一般都是伪随机数。</p><p>4、伪随机数都是基于一个种子数的，然后每需要一个随机数，都是对当前种子进行一些数学运算，得到一个数，基于这个数得到需要的随机数和新的种子。</p><p>5、Random 类是线程安全的，也就是说，多个线程可以同时使用一个 Random 实例对象，不过，如果并发性很高，会产生竞争，这时，可以考虑使用多线程库中的 ThreadLocalRandom 类。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5808954.html" target="_blank" rel="noopener">Java编程的逻辑 —— 随机</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(七) —— 随机 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(六)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AD)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Java入门总结(六)/</id>
    <published>2018-09-19T11:45:19.000Z</published>
    <updated>2018-09-20T03:18:47.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(六) —— 剖析日期和时间 </blockquote><a id="more"></a><p>1、关于时区<br>英国格林尼治是 0 时区，北京是东八区，也就是说格林尼治凌晨 1 点，北京是早上 9 点。0 时区的时间也称为 GMT+0 时间，GMT 是格林尼治标准时间，北京的时间就是 GMT+8:00。</p><p>2、时刻和 Epoch Time(纪元时)<br>所有计算机系统内部都用一个整数表示时刻，这个整数是距离格林尼治标准时间 1970年1月1日0时0分0秒 的毫秒数。格林尼治标准时间 1970年1月1日0时0分0秒 也被称为 Epoch Time (纪元时)。这个整数表示的是一个时刻，与时区无关，世界上各个地方都是同一个时刻。而对于 1970 年以前的时间则使用负数表示。</p><p>3、年历<br>公历和农历都是年历。年历就是对一年有多少月，每月有多少天，甚至一天有多少小时的规则定义。</p><p>时刻是一个绝对时间，对时刻的解读，如年月日周时分秒等，则是相对的，与年历和时区相关。</p><p>Date：表示时刻，即绝对时间，与年月日无关。</p><p>Calendar：表示年历，Calendar 是一个抽象类，其中表示公历的子类是 GregorianCalendar。</p><p>DateFormat：表示格式化，能够将日期和时间与字符串进行相互转换，DateFormat 也是一个抽象类，其中最常用的子类是 SimpleDateFormat。</p><p>TimeZone: 表示时区。Locale: 表示国家和语言。</p><p>4、Date 表示时刻，内部主要是一个 long 类型的值 <code>private transient long fastTime;</code> 几乎所有的未过时的方法都是对该值进行操作的。</p><p>5、Calendar 类是日期和时间操作中的主要类，它表示与 TimeZone 和 Locale 相关的日历信息，可以进行各种相关的运算。</p><p>Calendar.MONTH：表示月，一月份是 0。Calendar.DAY_OF_MONTH：表示日，每月的第一天是 1。Calendar.DAY_OF_WEEK：表示星期几，周日是 1，周一是 2，周六是 7。</p><p>内部，Calendar 会将表示时刻的毫秒数，按照 TimeZone 和 Locale 对应的年历，计算各个日历字段的值，存放在 fields 数组中，Calendar.get 方法获取的就是 fields 数组中对应字段的值。</p><p>内部，根据字段设置或修改时间时，Calendar 会更新 fields 数组对应字段的值，但一般不会立即更新其他相关字段或内部的毫秒数的值，不过在获取时间或字段值的时候，Calendar 会重新计算并更新相关字段。</p><p>6、DateFormat 类主要在 Date 和字符串表示之间进行相互转换。</p><p>7、DateFormat/SimpleDateFormat 不是线程安全的，因为 DateFormat 内部使用了一个 Calendar 实例对象，多线程同时调用的时候，这个 Calendar 实例的状态可能就会紊乱。</p><p>8、总结：Date 表示时刻，与年月日无关，Calendar 表示日历，与时区和 Locale 相关，可进行各种运算，是日期时间操作的主要类，DateFormat/SimpleDateFormat 在 Date 和字符串之间进行相互转换。</p><p>9、Joda 的主要工作都是在毫秒和年月日等年历信息之间进行相互转换。</p><p>10、Joda-Time 中的主要类都被设计为了不可变类，不可变类有一个很大的优点，那就是简单、线程安全，所有看似的修改操作都是通过创建新对象来实现的。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5774483.html" target="_blank" rel="noopener">Java编程的逻辑 —— 剖析日期和时间</a><br><a href="http://www.cnblogs.com/swiftma/p/5794390.html" target="_blank" rel="noopener">Java编程的逻辑 —— Joda-Time</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(六) —— 剖析日期和时间 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(五)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%94)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Linux入门总结(五)/</id>
    <published>2018-09-19T06:36:12.000Z</published>
    <updated>2018-10-11T02:45:21.694Z</updated>
    
    <content type="html"><![CDATA[<p>1、在 Linux 中，umask 的默认值为 022，用来定义默认新建文件的缺省权限。直接执行 umask 命令会得到一个 4 位的数字：0022 第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认的权限 rwxr-xr-x。</p><p>注意：在 Linux 权限管理有一个最基本的定义：缺省创建的文件是不能具有可执行权限的。在 Linux 系统中任何新建的文件都会把可执行权限去掉。所以新建文件实际的权限为 777-022-111 = 644，即rw-r–r–。</p><p>2、RHEL 的全称是 Red Hat Enterprise Linux 红帽企业版 Linux。</p><p>3、「n1,n2d」删除 n1 到 n2 行。例如：删除 1 到 10 行「:1,10d」。「n，$d」删除从某行开始至文本末尾。例如：删除第 8 行至末尾「:8,$d」。在 vim 中，0 表示行首，$ 表示行尾。</p><p>4、在内存小于 2G 的情况下，交换分区应为内存的 2 倍，超过 2G 的话，交换分区为物理内存加上 2G。</p><p>Red Hat 官方文库中有一段话：目前 Red Hat（红帽官方）推荐交换分区的大小应当与系统物理内存的大小保持线性比例关系。不过在小于 2GB 物理内存的系统中，交换分区大小应该设置为内存大小的两倍，如果内存大小多于 2GB，交换分区大小应该是物理内存大小加上 2GB。其原因在于，系统中的物理内存越大，对于内存的负荷可能也越大。</p><p>5、内核分为：进程管理子系统、内存管理子系统、I/O 管理子系统、文件管理系统 4 部分。</p><p>6、UNIX 系统由内核、shell、文件系统和应用程序 4 部分组成。</p><p>7、系统调用有 5 个分别为：open、write、read、close、ioctl。</p><p>所谓系统调用，就是内核提供的、功能十分强大的一系列的函数。这些系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。  </p><p>整个系统调用的过程总结如下：    </p><ol><li>执行用户程序(如: fork)  </li><li>根据 glibc 中的函数实现，取系统调用号并执行 int $0x80 产生中断。  </li><li>进行址空间的转换和堆栈的切换，执行 SAVE_ALL（进行内核模式）。  </li><li>进行中断处理根据系统调用表调用内核函数。  </li><li>执行内核函数。  </li><li>执行RESTORE_ALL并返回用户模式。  </li></ol><p>8、cat 有三个功能：  </p><ol><li>一次显示整个文件。「cat filename」  </li><li>从键盘创建新文件，但是不能编辑已有文件。「cat &gt; filename」  </li><li>将几个文件合并为一个文件。「cat file1 file2 &gt; file」  </li></ol><p>9、Linux下进程通信的八种方法：管道(pipe)，命名管道(FIFO)，内存映射(mapped memeory)，消息队列(message queue)，共享内存(shared memory)，信号量(semaphore)，信号(signal)，套接字(Socket)。</p><p>10、ssh 用于远程登录；scp 是 secure copy 的缩写，用于远程数据传输。</p><p>11、MMU(Memory Management Unit) 内存管理单元，是中央处理器用来管理虚拟内存和物理内存寄存器的控制线路，同时也负责虚拟内存映射为物理内存等。即在 CPU 和物理内存之间进行地址转换，将地址从逻辑空间映映射到物理地址空间。</p><p>12、压缩解压命令 tar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：tar [选项] [压缩后文件名] [目录]</span><br><span class="line">选项：</span><br><span class="line">  -c(create)  打包</span><br><span class="line">  -x(extract)  解包</span><br><span class="line">  -v(verbose)  显示详细信息</span><br><span class="line">  -f(file)  指定文件名</span><br><span class="line">  -z(gzip)  打包同时压缩/解压缩</span><br></pre></td></tr></table></figure></p><p>13、内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file 对象，file 对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的 file 对象。需要注意的是，file 对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的 file 对象，从而共享这个打开的文件。file 对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为 0 时，内核才销毁 file 对象，因此某个进程关闭文件，不影响与之共享同一个 file 对象的进程。</p><p>14、查找当前目录不包括子目录命令：<code>find . -name &quot;*.c&quot; -maxdepth 1</code>。最大深度为 1，表示当前目录。如果为 0，则表示只对命令行参数有效。</p><p>注意：符号「&gt;」是定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空；</p><p>可以把一块网卡设置多个IP地址，eg：eth0:1表示加了一个虚拟网卡，意思是给网卡绑定多一个IP地址。</p><p>7、<br>wc -l        # 统计行数<br>wc -w      # 统计单词数量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在 Linux 中，umask 的默认值为 022，用来定义默认新建文件的缺省权限。直接执行 umask 命令会得到一个 4 位的数字：0022 第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认
      
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(五)</title>
    <link href="yanchongsheng.github.io/2018/09/18/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%94)/"/>
    <id>yanchongsheng.github.io/2018/09/18/Java入门总结(五)/</id>
    <published>2018-09-18T10:54:55.000Z</published>
    <updated>2018-09-18T11:03:01.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(五) —— Arrays 类 </blockquote><a id="more"></a><p>1、Java 中的 Arrays 类中包含一些对数组操作的静态方法。</p><p>2、Arrays 的 toString 方法可以方便的输出一个数组的字符串形式。</p><p>3、数组排序之基本类型，对指定类型的数组按升序进行排序。sort 方法还可以指定排序范围 [fromIndex, toIndex)。</p><p>4、数组排序之对象类型，sort 还可以直接接受对象类型，但对象需要实现 Comparable 接口。</p><p>5、数组排序之自定义比较器，sort 还可以接受一个比较器作为参数。Comparator 就是比较器，它是一个接口，最主要的是 compare 这个方法，它比较两个对象，返回一个表示比较结果的值，-1 表示 o1 小于 o2，0 表示相等，1表示 o1 大于 o2。排序是通过比较来实现的，sort 方法在排序的过程中，需要对对象进行比较的时候，就调用比较器的 compare 方法。</p><p>6、需要注意的是 binarySearch 针对的必须是已排序数组，如果指定了 Comparator，需要和排序时指定的 Comparator 保持一致，另外，如果数组中有多个匹配的元素，则返回哪一个是不确定的。</p><p>7、在创建多维数组时，除了第一维的长度需要指定外，其他维的长度不需要指定，甚至，第一维中，每个元素的第二维的长度可以不一样。</p><p>8、多维数组到底是什么呢？其实，可以认为，多维数组只是一个假象，只有一维数组，只是数组中的每个元素还可以是一个数组，这样就形成二维数组，如果其中每个元素还都是一个数组，那就是三维数组。</p><p>9、Arrays 类的 sort 实现原理：  </p><blockquote><ul><li>基本数据类型数据：双枢轴快速排序(Dual-Pivot Quicksort)；是一种对快速排序（不稳定）进行优化后的算法；  </li><li>引用数据类型数据：TimSort；是一种对归并排序（稳定）进行优化后的算法；</li></ul></blockquote><p>它们之所以没有采用相同的排序算法，跟排序算法的稳定性有关。快速排序更快，但不稳定，而归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没有关系。但对于对象类型，相同只是比较结果一样，它们还是不同的对象，其他实例变量也不见得一样，稳定不稳定可能就很有关系了，所以采用归并排序。</p><p>10、Comparator 接口和 Comparable 接口？<br><a href="https://blog.csdn.net/zolalad/article/details/30060499" target="_blank" rel="noopener">Comparable 接口和 Comparator 接口的比较</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5747942.html" target="_blank" rel="noopener">Java编程的逻辑 —— 剖析 Arrays</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(五) —— Arrays 类 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/17/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/17/Linux入门总结(四)/</id>
    <published>2018-09-17T11:53:18.000Z</published>
    <updated>2018-09-20T12:30:39.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(四) —— Vim 编辑器 </blockquote><a id="more"></a><h2 id="Vim-简介"><a href="#Vim-简介" class="headerlink" title="Vim 简介"></a>Vim 简介</h2><hr><p>Vim 有三种命令模式。可以使用 vim 加上任何一个已经存在或者你想创建的文件名就可以进入 Vim 默认的命令模式。vi 和 vim 都是命令，两个的效果一模一样，一个是早期的一个是 Vi 的增强版（全名 Vi imporove 简称 Vim） 。Vim 命令默认进入的是命令模式，在该模式下，你敲的任何一个字符系统都会当成命令来处理。要想进入文本的插入模式，你需要输入插入命令，比较常用的有 i、a、o 就会进入到插入模式，要想退出插入模式，则可以使用 Esc 键，表示退出插入模式，但是此时进入到的是命令模式，此时你输入的任何内容都会被当成命令。在命令模式里面按「：」冒号就会进入到编辑模式，此时输入的就是编辑模式的命令了，即你输入的内容都会被当成是编辑模式的命令。比如设置行号命令：set number（简写：set nu）。编辑模式的命令执行完成以后它会自动的回到命令模式，所以冒号后面输入的内容才是编辑模式的命令。保存退出命令模式：「:wq」。</p><p><img src="/upload_image/Vim_Model.png" alt="Vim 工作模式" title="Vim 工作模式"></p><h2 id="命令模式和编辑模式常用命令"><a href="#命令模式和编辑模式常用命令" class="headerlink" title="命令模式和编辑模式常用命令"></a>命令模式和编辑模式常用命令</h2><hr><p><img src="/upload_image/Insert_Command.png" alt="插入命令" title="插入命令"><br>注意：在使用小 a 的时候光标会自动往后跳一格，例如：we 光标现在在 w 上，按  a以后光标自动跳到 e 上，然后在 e 的前面插入，实际上就是在 w 的后面插入。</p><p><img src="/upload_image/Position_Command.png" alt="定位命令" title="定位命令"><br>注意：上图中前面有冒号的表示编辑模式命令，没有冒号的表示命令模式命令。</p><p><img src="/upload_image/Delete_Command.png" alt="删除命令" title="删除命令"></p><p><img src="/upload_image/Copy_Move_Command.png" alt="复制和剪切命令" title="复制和剪切命令"></p><p><img src="/upload_image/Replace_Cancel_Command.png" alt="替换和取消命令" title="替换和取消命令"></p><p><img src="/upload_image/Explore_Replace_Command.png" alt="搜索和搜索替换命令" title="搜索和搜索替换命令"><br>Linux 中的查找是严格区分大小写的，但是我们可以设置忽略大小写。<br>「:%s 表示全局替换」「g 表示替换的时候不询问」「c表示替换的时候要询问」</p><p><img src="/upload_image/Save_Exit_Command.png" alt="保存和退出命令" title="保存和退出命令"></p><h2 id="Vim-使用技巧"><a href="#Vim-使用技巧" class="headerlink" title="Vim 使用技巧"></a>Vim 使用技巧</h2><hr><p>「:r 文件名」可以导入一个文件的内容到当前 vim 编辑的文件之中。eg：「:r /etc/issue」导入的位置为刚才你光标所在的位置。</p><p>「:!命令」可以在不退出 vim 的情况下，执行系统响应的操作命令。eg：「:!which ls」</p><p>「:r!命令」将一个命令的执行结果导入到当前的 vim 文件里面。eg：「:r!date」</p><p>自定义快捷键「:map 快捷键 触发命令」。eg：「:map ^p I#<esc>」^p 表示 ctrl + p 的快捷键，该快捷键代表的命令是：跳到行首并进入插入模式，插入 # 号，然后退出。eg：「:map ^b 0x」表示用快捷键 ctrl + b 表示删除行首字母。</esc></p><p>注意：设置快捷键的方式是，使用 ctrl + v + 所需字母；或者先按 ctrl + v，再按 ctrl + 所需字母，效果是一样的。这种是构造 ctrl + 字母的快捷键的方法。</p><p>连续行注释：「n1,n2s/^/#/g」表示从 n1 行开始到 n2 行，每行的行首都增加 # 号，并且替换的时候不询问。<br>去掉连续行注释：「n1,n2s/^#//g」表示从 n1 行开始到 n2 行，每行的行首的 # 号都替换为空，并且替换的时候不询问。<br>如果注释符是「//」则需要转义：「:n1,n2s/^/\/\//g」表示从 n1 行开始到 n2 行，每行的行首都增加 // 号，并且替换的时候不询问。<br>注意：「^」表示行首的意思。注意：在 Linux 中「\/」中「\」表示转义符的意思「/」它才是真正的符号。</p><p>替换命令：「:ab 旧内容 新内容」即「:ab a b」这个命令可以简单的理解为：当你输入 a，它会自动的帮你转换成 b。eg: 「:ab sb hello」 当前输入 sb 的时候，会自动的替换成 hello。</p><p>注意：以上定义的快捷键重启以后都不存在，要想永久生效，你需要将其定义在每个用户的宿主（家）目录中的配置文件里面。以 root 为例：vi /root/.vimrc (注意这个配置文件叫 .vimrc)这里面只能放一些<strong>编辑模式</strong>的命令：比如设置行号、设置快捷键、ab 命令（前面可以没有冒号「:」）。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href=""></a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(四) —— Vim 编辑器 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/12/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/12/Linux入门总结(三)/</id>
    <published>2018-09-12T12:28:43.000Z</published>
    <updated>2018-09-13T06:25:19.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(三) —— Linux 网络 </blockquote><a id="more"></a><p>mkdir(make directories) cd(change direcotry) pwd(print working directory) rmdir(remove empty directories) cp(copy) -r(directory) -p(property) mv(move) rm(remove) -r(directory) -f(force)<br>mkdir 创建一个新的目录 -p 创建一个新的目录的同时用 -p 再递归创建一个子目录；cd 切换目录；pwd查看当前的工作目录；rmdir 删除一个空目录；cp 复制文件 -r 复制目录 -p复制的时候保持文件的属性；mv 剪切或者给一个文件改名；rm 删除文件 -r 删除目录 -f删除目录或者文件的同时不希望询问确认；</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(三) —— Linux 网络 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(二)</title>
    <link href="yanchongsheng.github.io/2018/09/12/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/12/求实英语(二)/</id>
    <published>2018-09-12T11:27:16.000Z</published>
    <updated>2018-09-12T12:17:05.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(二) —— 主谓宾 </blockquote><a id="more"></a><p>1、他整天没地方去也没事儿干。<br>He goes nowhere and has nothing to do every day.</p><p>2、她天天在哪儿吃午饭？<br>Where does she have lunch every day?</p><p>3、你怎么不常和他们一块儿来？<br>Why don’t you often come with them?</p><p>4、王芳有姐姐吗？<br>Does WangFang have any sisters?</p><p>5、为什么他总听你的而不听我的？我不知道。<br>Why does he always listen to you but doesn’t listen to me? I don’t know.</p><p>6、他了解你多少？你非常了解他吗？<br>How much does he know you? Do you know him very well?</p><p>7、你们每周怎么去那儿?<br>How do you get there every week?</p><p>8、李梅不知道那事儿，但我知道。<br>LiMei doesn’t know that but me.</p><p>9、每天下班后，Tod 都载我回家。<br>Tod picks me up home after work every day.</p><p>10、这些小狗都叫什么？它的名字是 TianTian,那只叫 LeLe。<br>What are these dogs’ names? Its name is TianTian, that is called LeLe.</p><p>11、他准时上学并及时做作业。<br>He goes to school on time and does his homework in time.</p><p>12、没人相信他，因为他经常撒谎。他太丢人了。<br>Nobody believes him because he often tell lies. He is very shameful.</p><p>13、你妈把我的手表放什么里边了？<br>what does your mother put my watch in?</p><p>14、我像他，但却不喜欢他。<br>I am like hime, but I don’t like him.</p><p>15、你这么辛苦工作是为了什么？<br>what do you work hard for?</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>on time 准时<br>in time 及时</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(二) —— 主谓宾 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(三)</title>
    <link href="yanchongsheng.github.io/2018/09/12/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/12/求实英语(三)/</id>
    <published>2018-09-12T11:27:16.000Z</published>
    <updated>2018-09-21T03:15:34.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(三) —— 过去时 </blockquote><a id="more"></a><p>1、你去年经常拜访他们吗？<br>Did you ofter visit them last year?</p><p>2、三年前你对这种工作有多少经验？<br>我的：How much experience did you have for this job three years ago?<br>答案：How much experience in this kind of work did you have three years age?  </p><p>3、我没及时告诉她，因为我病了。<br>我的：I don’t tell her in time, because i was ill.<br>答案：I din’t tell her in time, because i was ill.</p><p>4、我上周就认知他了，可他却一点儿也不了解我。<br>我的：I knew him last week, but he don’t know me little.<br>答案：I knwe him last wekk, but he didn’t know me at all.</p><p>5、昨天你和王先生在哪儿？<br>where were you with Mr. Wang yesterday?</p><p>6、你见过那个新来的老板了吗？<br>我的：Do you have seen the new boss?<br>答案：Have you seen that new boss?</p><p>7、去年她像妈妈，可今年谁也不像。(此处 like 当介词)<br>我的：She was like her mother last year, but she isn’t like anyone this year.<br>答案：She was like her mother last year, but she is like no noe this year.</p><p>8、 谁问有关我学习的事儿来着？<br>我的：Who was asked me about my study？<br>答案：Who has asked something about my study?</p><p>9、爸爸昨晚没有责怪我。<br>Our father did’t scold me last night.</p><p>10、昨天你在哪儿听到的那个消息？我是从报纸上看到的。<br>where did you hear that news yesterday？I read it from the paper.</p><p>11、我的电脑又出毛病了。<br>我的：My computer has broken again.<br>答案：Something was wrong again with my computer.</p><p>12、昨天我很紧张，你呢？<br>I was very nervous yesterday, and how were you?</p><p>13、你们的值日生昨天擦黑板了吗？<br>Did your students on duty clean the blackboard yesterday?</p><p>14、今天上午李先生出什么事了？<br>我的：What did happend with Mr.Li this forenoon？<br>答案：What happended to Mr. Li this morning?</p><p>15、由于贫穷他去年就辍学了，我们去看看他吧。<br>我的：Because of poverty he droped out school last year, we are looking  at him tomorrow.<br>答案：He quit school last year because of being poor, Let’s go to see him tomorrow.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(三) —— 过去时 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker 入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/11/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/11/Docker入门总结(四)/</id>
    <published>2018-09-11T13:33:57.000Z</published>
    <updated>2018-09-12T08:41:27.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Docker 入门总结(四) </blockquote><a id="more"></a><p>1、Docker 包括三个基本概念：<br>镜像（Image）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>容器（Container）：容器的实质是进程。镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p><p>仓库（Repository）：一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>2、<code>$ docker run -it --rm ubuntu:16.04 bash</code><br>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</p><p>3、<code>$ docker system df</code><br>通过以上命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><p>4、docker image ls 选项：<br>默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。<br>docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。<br>-q 只列出镜像的 ID。</p><p>5、Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>1、FROM 指定基础镜像，一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p><p>2、RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><blockquote><p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。<br>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</p></blockquote><p>3、COPY 复制文件</p><blockquote><p>COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</p></blockquote><p>4、ADD 更高级的复制文件<br>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。这个功能其实并不实用，而且不推荐使用。</p><p>5、CMD 容器启动命令</p><blockquote><p>shell 格式：CMD &lt;命令&gt;<br>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]<br>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</p></blockquote><p>6、ENTRYPOINT 入口点<br>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。</p><p>7、ENV 设置环境变量</p><blockquote><p>ENV <key> <value><br>ENV <key1>=<value1> <key2>=<value2>…</value2></key2></value1></key1></value></key></p></blockquote><p>8、VOLUME 定义匿名卷</p><blockquote><p>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]<br>VOLUME &lt;路径&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Docker 入门总结(四) &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求实英语(一)</title>
    <link href="yanchongsheng.github.io/2018/09/11/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%80)/"/>
    <id>yanchongsheng.github.io/2018/09/11/求实英语(一)/</id>
    <published>2018-09-11T11:31:00.000Z</published>
    <updated>2018-09-12T12:17:05.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(一) —— 主系表 </blockquote><a id="more"></a><p>1、我姐姐在那儿吗？她和谁在一起呢？</p><blockquote><p>我的：Is my sister at there? whom is my sister with?<br>答案：Is my sister there? whom is she with?</p></blockquote><p>解析：there 在这里是名词，表示哪个地方的意思，所以不用 at。问句中用她来指代我姐姐。</p><p>2、我妈妈没在家，她和街坊出去了。</p><blockquote><p>我的：My mother is not at home, she is with neighborhood out.<br>答案：My mother is not at home, she is out with some neighbors.</p></blockquote><p>解析：out 在 这里是形容词，表示外面的。</p><p>3、那本书怎么样？它在你的手里吗？</p><blockquote><p>我的：How is that book? Is it in your hand?<br>答案：</p></blockquote><p>4、这是给我的，那些是给谁的？</p><blockquote><p>我的：This is for me, whom are those for?<br>答案：</p></blockquote><p>5、Sam Sterm 根本就没在这儿，他每天在二楼办公。</p><blockquote><p>我的：Sam Sterm is not here at all, he is at second floor everday.<br>答案：Sam Sterm is not here at all, he is at work on the 2nd floor ever day.</p></blockquote><p>解析：在工作用 at work 表示，在二楼用 at 2nd floor 表示，everday 是形容词每天的，而不是每天，这个是副词。</p><p>6、他是干什么的？他不是经理吗？</p><blockquote><p>我的：What is he? Is not he a manager?<br>答案：</p></blockquote><p>7、你的小狗在哪儿？它在什么里边？</p><blockquote><p>我的：Where is your dog? What is it in?<br>答案：</p></blockquote><p>8、这是谁的办公室？里边有人吗？哪间办公室是你的？</p><blockquote><p>我的：Whom is this office? Who is in the office? Which is your  office?<br>答案：Whose office is this? Is anyone in? Which office is yours?</p></blockquote><p>9、我的电话出了毛病，手机在哪儿？</p><blockquote><p>我的：My phone is wrong, where is cell phone?<br>答案：Something is wrong with my telephone,where is the cellphone?</p></blockquote><p>10、电视开着呢，把它关上吧！</p><blockquote><p>我的：The TV is on, turn it off!<br>答案：</p></blockquote><p>11、我的备份没在你的电脑里吗？</p><blockquote><p>我的：Is not my copy in your computer?<br>答案：</p></blockquote><p>12、这是干什么用的？</p><blockquote><p>我的：What is this for?<br>答案：</p></blockquote><p>13、我的手机昨天就在这儿放着呢!</p><blockquote><p>我的：My cellphone was right here yesterday!<br>答案：</p></blockquote><p>14、这个书包是谁的？那是谁的书包？我的在这儿！她的呢？  </p><blockquote><p>我的：Whose bag is this? Whose bag is that? My bag is here! Where is her bag?<br>答案：Whose is this bag? Whose bag is that? Mine is here! where is hers?</p></blockquote><p>15、这本字典不像我的，但那本像。  </p><blockquote><p>我的：This dictionary is not like mine,bug that is like.<br>答案：This dictionary is not like mine,bug that one is.</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、注意区分以下两种形式：<br>Whose is this bag？这个包是谁的？ This bag is whose.<br>Whose bag is this？这是谁的包？   This is whose bag.</p><p>2、区分 我、你、他 这些代词的各种形式：  </p><table><thead><tr><th>主格</th><th>宾格</th><th>属格</th><th>属格(名词性)</th></tr></thead><tbody><tr><td>I</td><td>me</td><td>my</td><td>mine</td></tr><tr><td>you</td><td>your</td><td>your</td><td>yours</td></tr><tr><td>he</td><td>him</td><td>his</td><td>his</td></tr><tr><td>she</td><td>her</td><td>her</td><td>hers</td></tr><tr><td>it</td><td>its</td><td>its</td><td>its</td></tr><tr><td>they</td><td>them</td><td>their</td><td>theirs</td></tr></tbody></table><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://zhidao.baidu.com/question/140269" target="_blank" rel="noopener">英语代词有哪些？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(一) —— 主系表 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/10/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/10/Java入门总结(四)/</id>
    <published>2018-09-10T13:14:54.000Z</published>
    <updated>2018-09-10T11:15:18.823Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/10/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/10/Java入门总结(三)/</id>
    <published>2018-09-10T12:35:49.000Z</published>
    <updated>2018-09-10T11:02:30.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(三) —— NIO </blockquote><a id="more"></a><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>1、在 Java 中，已有的 IO 操作大部分都属于阻塞的操作。为了提升服务器操作的性能，在 JDK1.4 之后增加了 NIO，在整个 NIO 的操作中，基本上都是使用缓冲区完成的。</p><p>2、<code>public abstract class Bufferextends Object</code> 抽象类 Buffer 是一个用于<strong>特定基本类型数据的容器</strong>。</p><p>3、<strong>缓冲区是特定基本类型元素的线性有限序列</strong>。除内容外，缓冲区的基本属性还包括容量、限制和位置：</p><blockquote><p>缓冲区的 容量(capacity) 是它所包含的元素的数量。缓冲区的容量不能为负并且不能更改。<br>缓冲区的 限制(limit) 是第一个不应该读取或写入的元素的索引。缓冲区的限制不能为负，并且不能大于其容量。<br>缓冲区的 位置(position) 是下一个要读取或写入的元素的索引。缓冲区的位置不能为负，并且不能大于其限制。  </p></blockquote><p>对于每个非 boolean 基本类型，此类都有一个子类与之对应。</p><p>4、标记、位置、限制和容量值遵守以下不变式： <code>0 &lt;= 标记 &lt;= 位置 &lt;= 限制 &lt;= 容量</code> 。</p><p>5、清除、反转和重绕   </p><blockquote><p>clear() 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为<strong>容量大小</strong>，将位置设置为 0。<br>flip() 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为<strong>当前位置</strong>，然后将位置设置为 0。<br>rewind() 使缓冲区为重新读取已包含的数据做好准备：它使<strong>限制保持不变</strong>，将位置设置为 0。  </p></blockquote><p>6、直接 与 非直接缓冲区<br>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</p><p>直接字节缓冲区可以通过调用此类的 allocateDirect 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</p><p>直接字节缓冲区还可以通过 mapping 将文件区域直接映射到内存中来创建。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</p><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>1、在 NIO 中，通道是一个可以用来读取和写入数据的一种形式。Channel 接口，用于 I/O 操作的连接。通道表示到实体的开放连接。 通道表示到实体，如硬件设备、文件、网络套接字或可以执行一个或多个不同 I/O 操作（如读取或写入）的程序组件的开放的连接。<strong>通道都是通过操作缓冲区来完成全部功能的。所有的内容都是先读或写到缓冲区之中，再通过缓冲区读或写入到通道中的，即程序不会直接操作通道。</strong><br><img src="/upload_image/Java_Channel.png" alt="Channel 简介" title="Channel 简介"></p><p>2、Java NIO Channel 通道和流非常相似，主要有以下几点区别：  </p><blockquote><p>通道可以读也可以写，流一般来说是单向的（只能读或者写）。<br>通道可以异步读写。<br>通道总是基于缓冲区Buffer来读写。  </p></blockquote><p>3、什么是内存映射？<br>将文件中的某个区域直接映射到内存中；对于较大的文件，这通常比调用普通的 read 或 write 方法更为高效。 在通道中还有一种方式成为内存映射。内存映射是速度最快的，MapperedByteBuffer，使用此种方式读取的内容是最快的，需要将一个输入的操作流绑定在内存映射上。</p><p>内存映射在读取的时候是最快的，但是如果执行的是写入操作则有可能是非常危险的，因为仅仅只是改变数组中的单个元素这样简单的操作就可能直接修改磁盘上的文件，因为修改数据与将数据保存在磁盘上是一样的。</p><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>在 Java NIO 中提供了文件锁的功能，这样当一个线程将文件锁定之后，其他线程是无法操作此文件的，要想进行文件的锁定操作，则要使用 FileLock 类完成，此类的对象需要依靠 FileChannel 进行实例化操作。</p><p>锁定方式：</p><blockquote><p>共享锁：允许多个线程进行文件的读取操作。<br>独占锁：只允许一个线程进行文件的读/写操作。</p></blockquote><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO 浅析</a><br><a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-channel.html" target="_blank" rel="noopener">Java NIO Channel 通道</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(三) —— NIO &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(二)</title>
    <link href="yanchongsheng.github.io/2018/09/06/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/06/Linux入门总结(二)/</id>
    <published>2018-09-06T12:00:23.000Z</published>
    <updated>2018-09-12T12:23:48.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(二) —— Linux 系统安装 </blockquote><a id="more"></a><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>磁盘分区又叫系统分区，是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。从字面意思来讲，磁盘分区指的就是把大的硬盘按照我的需求划分成几个分区，不同类目录与文件可以存储进不同的分区。</p><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><ol><li>主分区：最多只能有 4 个。  </li><li><p>扩展分区「是从主分区的 4 个分区之中拿出 1 个分区作为扩展分区」：</p><blockquote><ul><li>扩展分区最多只能有 1 个（注意：针对一块硬盘来讲，一个硬盘最多只能有一个扩展分区）。</li><li>主分区加扩展分区最多只能有 4 个。</li><li>扩展分区本身不能写入数据也不能格式化，唯一的作用就是用来包含逻辑分区。</li></ul></blockquote></li><li><p>逻辑分区「即扩展分区中的逻辑分区」：可以正确的写入数据和格式化。按照硬盘的限制，一块硬盘最多只能分 4 个分区，即 4 个主分区。这种限制不是 Linux 系统的限制而是硬盘本身的限制，只要硬盘结构不发生变化，这种限制会一直存在。</p></li></ol><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>硬盘正确分区以后还不能写入数据，硬盘还必须经过格式化以后才可以写入数据。</p><p>格式化 (高级格式化) 又称逻辑格式化，它是指根据用户选定的文件系统（如 fat16、fat32、NTFS、ext2、ext3、ext4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。</p><p>在 windows 中可以识别的文件系统有 fat16、fat32、NTFS，在 linux 中可以识别的文件系统有 ext2、ext3、ext4，centOS 默认使用的是 ext4。</p><p>硬盘的格式化最主要的目的就是为了在硬盘当中写入文件系统，写入文件系统最主要的工作就是按照文件系统的规则把硬盘分成等大小的数据块，然后建立 iNode 表，我们把表里的编号称为 i 节点号又名 iNode 号。</p><p>当在查找文件的时候，是通过 iNode 表找到 i 节点号来找到这个文件的条款，从而知道这个文件保存在哪几个数据块之中，从而找到这几个数据块拿出文件，拼凑成我们的文件。这个格子就叫做数据块，又名 block。</p><p>在 centos 当中，默认的文件系统是 ext4，它在进入格式化的时候，它需要把硬盘划分为一个又一个等大小的数据块，这个数据块默认的标准大小为 4kb。假如有一个数据是 10kb，需要占用 3 个格子，最后一个格子只放了 2kb 数据，剩余的 2kb 空闲空间是不能再被其它文件所占用的，这 3 个格子不一定在一块。windows 中有一个磁盘碎皮整理，它的原理就是将保存的同一个文件的格子尽量放到一起，这样更有利于数据的读取。</p><h2 id="硬件设备文件名"><a href="#硬件设备文件名" class="headerlink" title="硬件设备文件名"></a>硬件设备文件名</h2><p>如果是 windows，在进行了分区、格式化之后，给分区分配盘符然后就可以直接使用了。但是 Linux 不行，Linux 在进行了分区、格式化，格式化完成之后，要想给分区分配盘符之前，<strong>还必须给每一个分区起一个设备文件名，或者说给每一个分区起一个硬件设备文件名。</strong></p><p>在 Linux 中所有的硬件设备都是文件。</p><p><img src="/upload_image/Hardware_Name.png" alt="硬件设备文件名" title="硬件设备文件名"></p><p>「/」表示 Linux 中的最高一级目录，也就是根目录。在根目录下有一个 dev 的一级子目录，在 dev 目录中放入的所有的文件都是<strong>硬件文件</strong>。我们将<strong>硬件文件名</strong>，称为<strong>硬件的设备文件名</strong>。</p><p>为什么 Linux 需要「硬件设备文件名」而 windows 不需要？<br>在 windows 中，硬盘分区、格式化之后，然后可以直接分配盘符是因为我们可以在 windows 的图形界面中直接看到这个硬盘在哪（注意：一台机器可能有多个硬盘），所以可以直接分配盘符（windows 有完善的图形界面）。但是 Linux 最早出现的时候，是没有图形界面的，为了让系统知道我要给哪一个硬盘分配盘符，所以被迫需要给每一个硬盘或者硬件设备指定设备文件名。</p><p><strong>硬件设备文件名是固定的，系统自动检测的，我们能看懂就行。</strong> 关于硬盘，我们现在主要使用的是 SATA 硬盘接口，IDE、SCSI 硬盘接口基本被淘汰了。</p><h2 id="分区设备文件名"><a href="#分区设备文件名" class="headerlink" title="分区设备文件名"></a>分区设备文件名</h2><p>硬盘有了「硬件设备文件名」，还要给分区也要分配文件名，这就是「分区设备文件名」。「分区设备文件名」是在硬盘「硬件设备文件名」之后，直接加分区号就可以了。即硬盘有设备文件名，分区也应该有设备文件名，区别是一个是硬件设备文件名，一个是分区设备文件名。</p><p>分区设备文件名：分区文件名是在硬盘文件名之后直接加分区号，1 表示这个硬盘当中的第一个分区，依次类推。<strong>注意分区号有主分区号和逻辑分区号。</strong></p><p>逻辑分区是从 5 开始的，1234 只能给主分区或者扩展分区使用，即使一个硬盘中没有分够 4 个主分区，逻辑分区也不能占用 1234 这 4 个分区号，即不管如何分区 5 都表示逻辑分区的第一个分区。</p><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>windows 中分配盘符的操作在 Linux 中叫做挂载，我们把给分区分配盘符的过程称为挂载，我们把盘符叫做挂载点。在 Linux 中是使用空的目录名称作为盘符，而不是使用 CDEF 作为盘符，理论上任何一个目录都可以作为盘符，实际上有些目录是不可以的。</p><p>对于 Linux 来讲有两个必须分区：根分区、swap 分区（交换分区，大小一般为内存的 2 倍，一般不超过 2GB）。这两个是必须分区，如果不分区，则 Linux 不能安装，只要有这两个分区，Linux 就可以正常使用。还有一个推荐分区，/boot（启动分区，大小一般为 200M)。</p><p>根分区用于存放剩余数据，swap 分区可以理解为虚拟内存，即当我真正的内存不够用的时候可以拿交换分区的硬盘空间来当内存来用，理论上讲 swap分 区应该是内存的两倍，但是最大不超过 2GB，因为虚拟内存到底不是真正的内存，如果给它给的再大，它也不能取代内存，当它达到 2GB 的时候，如果再给大，只会占用我们更多的硬盘空间，但是对我们的系统不会产生更多的影响，所以最大不超过 2GB。</p><p>Boot 分区是专门用来保存启动时候的数据，任何操作系统启动的时候都需要一些硬盘空间，如果不给 boot 分区，万一根分区写满了，系统可能就启动不了了，为了解决这个问题，一般都会给 boot 单独分区。Boot 分区 200MB 足够，不用太大，写完之后不再往 boot 分区写入任何数据，它永远都会有一定的空余空间，就算把根分区写满了，也不会影响 Linux 启动。</p><h2 id="Linux-文件系统结构"><a href="#Linux-文件系统结构" class="headerlink" title="Linux 文件系统结构"></a>Linux 文件系统结构</h2><p><img src="/upload_image/File_System_Structure.png" alt="Linux 文件系统结构" title="Linux 文件系统结构"></p><p>从 Linux 系统上看，boot、home 都是根分区的子目录。但是从硬盘上来看，它们每一个目录都可以有自己独立的硬盘空间，即每一个目录都可以有自己独立的分区，而每个分区又对应某块硬盘空间，所以每个目录都可以有自己独立的硬盘空间。</p><p>挂载点就是分区的盘符，swap 分区即交换分区没有盘符，swap 分区不是给用户用的，是由 Linux 操作系统或者内核直接调用的，所以它根本不需要盘符，有了盘符反而不正确了。swap 对系统性能的影响极小，所以分的空间不用太大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>分区：把大硬盘分为小的逻辑分区；<br>格式化：格式化的目的是为了写入文件系统，当然在写入文件系统的时候会附带的把硬盘当中的数据清空；<br>分区设备文件名：给每个分区定义设备文件名；<br>挂载：给每个分区分配挂载点，这个挂载点必须是目录，而且必须是空的目录才可以进行挂载点分配。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(二) —— Linux 系统安装 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
