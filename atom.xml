<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有才的博客</title>
  
  <subtitle>不孤独，无自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="yanchongsheng.github.io/"/>
  <updated>2019-03-26T09:46:55.141Z</updated>
  <id>yanchongsheng.github.io/</id>
  
  <author>
    <name>Yan ChongSheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>求实英语(七)</title>
    <link href="yanchongsheng.github.io/2019/03/29/English-2019-03-29-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%B8%83/"/>
    <id>yanchongsheng.github.io/2019/03/29/English-2019-03-29-求实英语-七/</id>
    <published>2019-03-29T09:48:09.000Z</published>
    <updated>2019-03-26T09:46:55.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(七) —— 祈使句 </blockquote><a id="more"></a><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、她胆子小，别吓唬她！</p><p>2、递给我那本书，我该学习了。</p><p>3、别不好意思，再虚心点儿！</p><p>4、在你走之前，先到我这儿来一下！</p><p>5、别这么看着我！我很紧张。</p><p>6、呆在这儿！哪儿也别去！</p><p>7、做个好孩子，别跟 Tom 学！</p><p>8、不要放弃你的事业！</p><p>9、别嫌弃你妈妈，她为你不容易。</p><p>10、好好做人，当个人民的好律师。</p><p>11、少说多干！</p><p>12、别犹豫了！快走吧！</p><p>13、这道菜看着挺好，吃着会怎么样？</p><p>14、那个男孩子咋一看倒是挺潇洒。</p><p>15、为什么这首歌听起来像京戏？</p><p>16、你不像你哥哥，至少长得不像。</p><p>17、看上去他一本正经，实际上他什么也不是。</p><p>18、那块布料手感怎么样？</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ol><li><p>Don’t frighten her! She is shy.</p></li><li><p>Pass me that book! It’s time for me to study.</p></li><li><p>Don’t by shy! Be more modest!</p></li><li><p>Come to me before you go!</p></li><li><p>Don’t look at me in this way! I am very nervous.</p></li><li><p>Be here! Don’t go anywhere!</p></li><li><p>Be a good child! Don’t do anything like Tom!</p></li><li><p>Don’t quit your cause!</p></li><li><p>Don’t dislike your mother! She is not easy for you.</p></li><li><p>Behave yourself! Be a competent lawyer for the people.</p></li><li><p>Speak less and do more!</p></li><li><p>Don’t hesitate! Hurry up to go!</p></li><li><p>This dish looks nice, how does it taste?</p></li><li><p>That boy looks handsome at first glance.</p></li><li><p>Why does the song sound like Beijing opera?</p></li><li><p>You are not like your brother, and you don’t look like him at least.</p></li><li><p>He looks serious , but he is nothing in fact.</p></li><li><p>How does that cloth feel?</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(七) —— 祈使句 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(六)</title>
    <link href="yanchongsheng.github.io/2019/03/28/English-2019-03-28-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E5%85%AD/"/>
    <id>yanchongsheng.github.io/2019/03/28/English-2019-03-28-求实英语-六/</id>
    <published>2019-03-28T09:48:09.000Z</published>
    <updated>2019-03-26T09:32:27.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(六) —— 定语 </blockquote><a id="more"></a><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、王芳手里的那本旧书太贵了。</p><p>2、桌子上边的纸箱里装满了碎玻璃。</p><p>3、树上的鸟儿成双对。</p><p>4、昨天的工作没完成，明天的计划又来了。</p><p>5、戴着眼镜的人是来自北京的教授。</p><p>6、他喜欢的收音机旧的都没法听了。</p><p>7、像 Tim 的那个男孩儿昨天来了吗？</p><p>8、家里的电脑比这台容量大。</p><p>9、像这种带有更多插图的书都在阅览室里。</p><p>10、你告诉我的事儿对我而言非常重要。</p><p>11、现在还有带橡皮的铅笔吗？</p><p>12、和我哥哥在一起的人是我姐夫。</p><p>13、你去过他提到的那个城市吗?</p><p>14、没有谁的季节是农民最苦的日子。</p><p>15、她脸上的泪水感动了那里的人。</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ol><li><p>That old book in wangfang’s hand is very expensive.</p></li><li><p>The paper box on the desk is full of broken glass.</p></li><li><p>The birds in trees are in pairs.</p></li><li><p>The work yesterday was not finished, and the plan tomorrow is coming.</p></li><li><p>The person with glasses is the professor from Beijing.</p></li><li><p>The radio he likes is too old to listen to.</p></li><li><p>Did that boy like Tim come yesterday?</p></li><li><p>The computer (at) home has more capacity than this one here.</p></li><li><p>The book with more pictures like this are all in the reading-room.</p></li><li><p>Sth. you told me is vey important for me.</p></li><li><p>Are there any pencils with a rubber at present?</p></li><li><p>The man with my brother is my brother-in-law.</p></li><li><p>Have you been to that city he mentioned?</p></li><li><p>The season without any water is the hardest days for the farmers.</p></li><li><p>Tears on her face moved the people there.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(六) —— 定语 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(五)</title>
    <link href="yanchongsheng.github.io/2019/03/27/English-2019-03-27-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%BA%94/"/>
    <id>yanchongsheng.github.io/2019/03/27/English-2019-03-27-求实英语-五/</id>
    <published>2019-03-27T08:48:09.000Z</published>
    <updated>2019-03-26T08:26:41.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(五) —— there be </blockquote><a id="more"></a><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、地上有水吗？那儿有多少水？</p><p>2、办公室里有几台电脑？</p><p>3、什么里面有邮票？</p><p>4、Tom 的书包里有面包吗？</p><p>5、这里不该有学生，他们这时候应该在教室里学习。</p><p>6、去年家里哪儿有旧书？</p><p>7、什么在桌上？桌上有什么？</p><p>8、明年我校将有 40 个班和 100 个老师。</p><p>9、那儿一定有餐厅吗？</p><p>10、过去这个村庄前边有一条小河。</p><p>11、为什么二月份只有 28 天？</p><p>12、从前有座山，山上有座庙。</p><p>13、哪儿有好老师我就到哪儿去学。</p><p>14、咱们学校什么时候有过实验室呀？</p><p>15、只有不良的教育，没有不好的学生。</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ol><li><p>Is there any water on the ground? How much water is there?</p></li><li><p>How many computers are there in the office?</p></li><li><p>what are there any stamps in?</p></li><li><p>Is there any bread in Tom’s bag?</p></li><li><p>Here shouldn’t be any students. They should be studying in the classroom now.</p></li><li><p>Where were there any old books at home last year?</p></li><li><p>What is on the desk? what is there on the desk?</p></li><li><p>There will be 40 classes and 100 teachers in our school next year.</p></li><li><p>Must there be any restaurants?</p></li><li><p>There used to be a river in front of this village.</p></li><li><p>Why are there only 28 days in Feb.?</p></li><li><p>There was a hill long before, and there was a temple on it.</p></li><li><p>I’ll go to study where there are some good teachers.</p></li><li><p>When have there been any laboratories in our school?</p></li><li><p>There is only a poor education, but there aren’t any poor students.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(五) —— there be &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(四)</title>
    <link href="yanchongsheng.github.io/2019/03/26/English-2019-03-26-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E5%9B%9B/"/>
    <id>yanchongsheng.github.io/2019/03/26/English-2019-03-26-求实英语-四/</id>
    <published>2019-03-26T07:48:09.000Z</published>
    <updated>2019-03-26T08:08:10.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(四) —— 不定式 </blockquote><a id="more"></a><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、一言难尽！（一句话说不清楚)</p><p>2、他昨天忘记带语文作业了。</p><p>3、你喜欢和谁在一起？谁喜欢和你在一起？</p><p>4、谁要做这件荒唐的事儿？</p><p>5、在家读书和写作是我今天的计划。</p><p>6、我还没决定要和谁一起去。</p><p>7、他们知道何时出发吗？</p><p>8、什么时候出发无所谓，问题是去什么地方。</p><p>9、困难的是如何能准时到达那里。</p><p>10、听到要回家乡过年使她非常高兴。</p><p>11、和他在一起工作使我们情绪非常高涨。</p><p>12、天变凉了，睡在这儿太冷。</p><p>13、我决定当一名出色的律师。</p><p>14、难道你没发现她要生气？</p><p>15、男人爱潇洒，女人爱漂亮。</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ol><li><p>It is hard to say .(with one word)</p></li><li><p>He forgot to bring his Chinese homework yesterday.</p></li><li><p>Whom do you like to be with? Who likes to be with you?</p></li><li><p>Who wants to do sth. fantastic?</p></li><li><p>To read and write at home is my plan today.</p></li><li><p>I haven’t decided yet whom to go with.</p></li><li><p>Do they know when to set out?</p></li><li><p>When to set out doesn’t matter, The question is where to go.</p></li><li><p>What is hard is how to get there on time.</p></li><li><p>It makes her very happy to hear to spend the New Year in her hometown.</p></li><li><p>To work with him makes us in high spirits.</p></li><li><p>The weather is getting cool, to sleep here is very cold.</p></li><li><p>I decide to be an excellent lawyer.</p></li><li><p>Don’t you find her to be angry?</p></li><li><p>Men like to be handsome. Woman like to be pretty.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(四) —— 不定式 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法入门10</title>
    <link href="yanchongsheng.github.io/2018/12/05/Algorithm-2018-12-05-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A810/"/>
    <id>yanchongsheng.github.io/2018/12/05/Algorithm-2018-12-05-算法入门10/</id>
    <published>2018-12-05T13:05:40.000Z</published>
    <updated>2018-12-26T04:29:50.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 排序——桶排序、计数排序、基数排序 </blockquote><a id="more"></a><p>1、桶排序（Bucket sort）<br>桶排序，顾名思义，会用到「桶」，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 排序——桶排序、计数排序、基数排序 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法基础" scheme="yanchongsheng.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法基础" scheme="yanchongsheng.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java06</title>
    <link href="yanchongsheng.github.io/2018/12/04/Java-Java-Interview-2018-12-04-Java06/"/>
    <id>yanchongsheng.github.io/2018/12/04/Java-Java-Interview-2018-12-04-Java06/</id>
    <published>2018-12-04T13:27:16.000Z</published>
    <updated>2018-12-04T08:59:36.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">  动态代理是基于什么原理？ </blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;  动态代理是基于什么原理？ &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法入门09</title>
    <link href="yanchongsheng.github.io/2018/12/04/Algorithm-2018-12-04-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A809/"/>
    <id>yanchongsheng.github.io/2018/12/04/Algorithm-2018-12-04-算法入门09/</id>
    <published>2018-12-04T12:10:49.000Z</published>
    <updated>2018-12-26T04:29:47.739Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 排序——快排、归并 </blockquote><a id="more"></a><p>1、归并排序和快速排序都用到了分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。</p><p>2、归并排序（Merge Sort）<br>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p>归并排序不是原地排序算法、是稳定的排序算法；时间复杂度 O(nlogn)，空间复杂度 O(n)；</p><p>3、快速排序算法（Quicksort）<br>如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p><p>快排是一种原地、不稳定的排序算法。时间复杂度 O(nlogn)，空间复杂度 O(1)；</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 排序——快排、归并 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法基础" scheme="yanchongsheng.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法基础" scheme="yanchongsheng.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法入门08</title>
    <link href="yanchongsheng.github.io/2018/12/03/Algorithm-2018-12-03-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A808/"/>
    <id>yanchongsheng.github.io/2018/12/03/Algorithm-2018-12-03-算法入门08/</id>
    <published>2018-12-03T12:44:17.000Z</published>
    <updated>2018-12-04T02:11:36.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 排序——冒泡、插入、选择 </blockquote><a id="more"></a><p>1、排序算法<br>|排序算法|时间复杂度|是否基于比较|<br>|—|—|—|<br>|冒泡、插入、选择|O(n2)|是|<br>|快排、归并|O(nlogn)|是|<br>|桶、计数、基数|O(n)|否|</p><p>2、如何分析一个排序算法？<br>（1）排序算法的执行效率：最好情况、最坏情况、平均情况时间复杂度；间复杂度的系数、常数 、低阶；比较次数和交换（或移动）次数；<br>（2）排序算法的内存消耗<br>（3）排序算法的稳定性  </p><p>3、冒泡排序（Bubble Sort）<br>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><p>冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。</p><p>4、插入排序（Insertion Sort）<br>将数组中的数据分为两个区间，已排序区间和未排序区间。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>5、选择排序（Selection Sort）<br>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 排序——冒泡、插入、选择 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法基础" scheme="yanchongsheng.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法基础" scheme="yanchongsheng.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java05</title>
    <link href="yanchongsheng.github.io/2018/12/03/Java-Java-Interview-2018-12-03-Java05/"/>
    <id>yanchongsheng.github.io/2018/12/03/Java-Java-Interview-2018-12-03-Java05/</id>
    <published>2018-12-03T12:27:13.000Z</published>
    <updated>2018-12-04T08:49:04.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">  String、StringBuffer、StringBuilder有什么区别？ </blockquote><a id="more"></a><p>由于 String 在 Java 世界中使用过于频繁，Java 为了避免在一个系统中产生大量的 String 对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过 new 方法创建的 String 对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给 String 对象引用赋值的情况。</p><p>举例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//通过直接量赋值方式，放入字符串常量池</span><br><span class="line">String str1 = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">//通过new方式赋值方式，不放入字符串常量池</span><br><span class="line">String str2 = new String(&quot;123&quot;);</span><br></pre></td></tr></table></figure></p><p>注意：String 提供了 inter() 方法。调用该方法时，如果常量池中包括了一个等于此 String 对象的字符串（由 equals 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此池中对象的引用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;  String、StringBuffer、StringBuilder有什么区别？ &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java04</title>
    <link href="yanchongsheng.github.io/2018/11/30/Java-Java-Interview-2018-11-30-Java04/"/>
    <id>yanchongsheng.github.io/2018/11/30/Java-Java-Interview-2018-11-30-Java04/</id>
    <published>2018-11-30T13:14:37.000Z</published>
    <updated>2018-12-04T07:44:04.119Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">  强引用、软引用、弱引用、幻象引用有什么区别？ </blockquote><a id="more"></a><h2 id="强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？"><a href="#强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？"></a>强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</h2><p>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;  强引用、软引用、弱引用、幻象引用有什么区别？ &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java03</title>
    <link href="yanchongsheng.github.io/2018/11/30/Java-Java-Interview-2018-11-30-Java03/"/>
    <id>yanchongsheng.github.io/2018/11/30/Java-Java-Interview-2018-11-30-Java03/</id>
    <published>2018-11-30T12:51:45.000Z</published>
    <updated>2018-11-30T07:14:15.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 谈谈final、finally、 finalize有什么不同？ </blockquote><a id="more"></a><h2 id="谈谈-final、finally、-finalize-有什么不同？"><a href="#谈谈-final、finally、-finalize-有什么不同？" class="headerlink" title="谈谈 final、finally、 finalize 有什么不同？"></a>谈谈 final、finally、 finalize 有什么不同？</h2><p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p><p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。</p><p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://ifeve.com/java-7%E4%B8%AD%E7%9A%84try-with-resources/" target="_blank" rel="noopener">Java 7 中的 Try-with-resources</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 谈谈final、finally、 finalize有什么不同？ &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法入门07</title>
    <link href="yanchongsheng.github.io/2018/11/30/Algorithm-2018-11-30-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A807/"/>
    <id>yanchongsheng.github.io/2018/11/30/Algorithm-2018-11-30-算法入门07/</id>
    <published>2018-11-30T12:03:59.000Z</published>
    <updated>2018-12-03T10:44:05.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 递归 </blockquote><a id="more"></a><p>1、去的过程叫「递」，回来的过程叫「归」。</p><p>2、基本上，所有的递归问题都可以用递推公式来表示。</p><p>3、递归需要满足三个条件</p><blockquote><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol></blockquote><p>4、写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p><p>5、对于递归代码，试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p><p>6、递归代码要警惕重复计算</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 递归 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法基础" scheme="yanchongsheng.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法基础" scheme="yanchongsheng.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法入门06</title>
    <link href="yanchongsheng.github.io/2018/11/29/Algorithm-2018-11-29-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A806/"/>
    <id>yanchongsheng.github.io/2018/11/29/Algorithm-2018-11-29-算法入门06/</id>
    <published>2018-11-29T14:30:18.000Z</published>
    <updated>2018-12-03T02:04:48.606Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 队列 </blockquote><a id="more"></a><p>1、队列跟栈一样，也是一种操作受限的线性表数据结构。</p><p>2、用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。</p><p>3、要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。</p><p>4、循环队列入队操作</p><p>队列为空：head == tail<br>队列满了：(tail+1)%n=head</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean enqueue(String item) &#123;</span><br><span class="line">  // 队列满了</span><br><span class="line">  if ((tail + 1) % n == head) return false;</span><br><span class="line">  items[tail] = item;</span><br><span class="line">  // 注意下一个 tail 的值</span><br><span class="line">  tail = (tail + 1) % n;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 队列 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法基础" scheme="yanchongsheng.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法基础" scheme="yanchongsheng.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java02</title>
    <link href="yanchongsheng.github.io/2018/11/29/Java-Java-Interview-2018-11-29-Java02/"/>
    <id>yanchongsheng.github.io/2018/11/29/Java-Java-Interview-2018-11-29-Java02/</id>
    <published>2018-11-29T13:50:42.000Z</published>
    <updated>2018-11-29T08:30:15.332Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Exception 和 Error 有什么区别？ </blockquote><a id="more"></a><h2 id="对比-Exception-和-Error"><a href="#对比-Exception-和-Error" class="headerlink" title="对比 Exception 和 Error"></a>对比 Exception 和 Error</h2><p>在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p><p>Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</p><p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误。</p><h2 id="运行时异常与一般异常有什么区别？"><a href="#运行时异常与一般异常有什么区别？" class="headerlink" title="运行时异常与一般异常有什么区别？"></a>运行时异常与一般异常有什么区别？</h2><p>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</p><p>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Exception 和 Error 有什么区别？ &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java01</title>
    <link href="yanchongsheng.github.io/2018/11/29/Java-Java-Interview-2018-11-29-Java01/"/>
    <id>yanchongsheng.github.io/2018/11/29/Java-Java-Interview-2018-11-29-Java01/</id>
    <published>2018-11-29T12:50:38.000Z</published>
    <updated>2018-11-29T07:37:11.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 谈谈你对 Java 平台的理解？ </blockquote><a id="more"></a><h2 id="1、谈谈你对-Java-平台的理解？"><a href="#1、谈谈你对-Java-平台的理解？" class="headerlink" title="1、谈谈你对 Java 平台的理解？"></a>1、谈谈你对 Java 平台的理解？</h2><p>可以从以下几个方面入手：Java/JVM 生态、基本语言特性、Java 类库、Java 虚拟机、工具。</p><h2 id="2、「Java-是解释执行」，这句话正确吗？"><a href="#2、「Java-是解释执行」，这句话正确吗？" class="headerlink" title="2、「Java 是解释执行」，这句话正确吗？"></a>2、「Java 是解释执行」，这句话正确吗？</h2><p>对于「Java 是解释执行」这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的<strong>解释器</strong>将字节码转换成为最终的机器码。『将字节码解释成机器码』</p><p>但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码<strong>编译成</strong>机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。『将字节码编译成机器码』</p><p>众所周知，我们通常把 Java 分为编译期和运行时。这里说的 Java 的编译和 C/C++ 是有着不同的意义的，Javac 的编译，编译 Java 源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码。</p><p>在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 谈谈你对 Java 平台的理解？ &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java00</title>
    <link href="yanchongsheng.github.io/2018/11/29/Java-Java-Interview-2018-11-29-Java00/"/>
    <id>yanchongsheng.github.io/2018/11/29/Java-Java-Interview-2018-11-29-Java00/</id>
    <published>2018-11-29T11:50:34.000Z</published>
    <updated>2018-11-29T07:38:02.564Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 体验 Java 的魅力 </blockquote><a id="more"></a><h2 id="Java-学习的-5-大模块"><a href="#Java-学习的-5-大模块" class="headerlink" title="Java 学习的 5 大模块"></a>Java 学习的 5 大模块</h2><blockquote><p>Java 基础：我会围绕 Java 语言基本特性和机制，由点带面，让你构建牢固的 Java 技术工底。</p><p>Java 进阶：将围绕并发编程、Java 虚拟机等领域展开，助你攻坚大厂 Java 面试的核心阵地。</p><p>Java 应用开发扩展：从数据库编程、主流开源框架、分布式开发等，帮你掌握 Java 开发的十八般兵器。</p><p>Java 安全基础：让你理解常见的应用安全问题和处理方法，掌握如何写出符合大厂规范的安全代码。</p><p>Java 性能基础：你将掌握相关工具、方法论与基础实践。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 体验 Java 的魅力 &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法入门05</title>
    <link href="yanchongsheng.github.io/2018/11/28/Algorithm-2018-11-28-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A805/"/>
    <id>yanchongsheng.github.io/2018/11/28/Algorithm-2018-11-28-算法入门05/</id>
    <published>2018-11-28T12:58:22.000Z</published>
    <updated>2018-11-29T01:51:02.261Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 栈 </blockquote><a id="more"></a><p>1、栈是一种「操作受限」的线性表，只允许在一端插入和删除数据。</p><p>2、栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p><p>3、均摊时间复杂度一般都等于最好情况时间复杂度。动态扩容的顺序栈，需要重点掌握它的均摊时间复杂度分析方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 栈 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法基础" scheme="yanchongsheng.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法基础" scheme="yanchongsheng.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket 入门</title>
    <link href="yanchongsheng.github.io/2018/11/28/Other-2018-11-28-WebSocket%E5%85%A5%E9%97%A8/"/>
    <id>yanchongsheng.github.io/2018/11/28/Other-2018-11-28-WebSocket入门/</id>
    <published>2018-11-28T11:33:21.000Z</published>
    <updated>2018-11-28T08:26:39.886Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> WebSocket 入门 </blockquote><a id="more"></a><p>1、WebSocket 是一种网络通信协议。</p><p>2、为什么需要 WebSocket？ 因为通过它服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息。而 HTTP 协议的通信只能由客户端发起。</p><p>3、协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。eg：<code>ws://example.com:80/some/path</code>。</p><p>4、WebSocket 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">简介：  </span><br><span class="line">    WebSocket 对象提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。</span><br><span class="line"></span><br><span class="line">构造函数：</span><br><span class="line">    `WebSocket(url[, protocols])`  返回一个 WebSocket 对象</span><br><span class="line"></span><br><span class="line">属性：</span><br><span class="line">    WebSocket.binaryType</span><br><span class="line">    使用二进制的数据类型连接</span><br><span class="line"></span><br><span class="line">    WebSocket.bufferedAmount 只读</span><br><span class="line">    未发送至服务器的字节数</span><br><span class="line"></span><br><span class="line">    WebSocket.extensions 只读</span><br><span class="line">    服务器选择的扩展</span><br><span class="line"></span><br><span class="line">    WebSocket.onclose</span><br><span class="line">    用于指定连接关闭后的回调函数</span><br><span class="line"></span><br><span class="line">    WebSocket.onerror</span><br><span class="line">    用于指定连接失败后的回调函数</span><br><span class="line"></span><br><span class="line">    WebSocket.onmessage</span><br><span class="line">    用于指定当从服务器接受到信息时的回调函数</span><br><span class="line"></span><br><span class="line">    WebSocket.onopen</span><br><span class="line">    用于指定连接成功后的回调函数</span><br><span class="line"></span><br><span class="line">    WebSocket.protocol 只读</span><br><span class="line">    服务器选择的下属协议</span><br><span class="line"></span><br><span class="line">    WebSocket.readyState 只读</span><br><span class="line">    当前的链接状态</span><br><span class="line"></span><br><span class="line">    WebSocket.url 只读</span><br><span class="line">    WebSocket 的绝对路径</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">    WebSocket.close([code[, reason]])</span><br><span class="line">    关闭当前链接</span><br><span class="line"></span><br><span class="line">    WebSocket.send(data)</span><br><span class="line">    向服务器发送数据</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">    // Create WebSocket connection.</span><br><span class="line">    const socket = new WebSocket(&apos;ws://localhost:8080&apos;);</span><br><span class="line"></span><br><span class="line">    // Connection opened</span><br><span class="line">    socket.addEventListener(&apos;open&apos;, function (event) &#123;</span><br><span class="line">    socket.send(&apos;Hello Server!&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Listen for messages</span><br><span class="line">    socket.addEventListener(&apos;message&apos;, function (event) &#123;</span><br><span class="line">    console.log(&apos;Message from server &apos;, event.data);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>5、客户端的简单示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&quot;wss://echo.WebSocket.org&quot;);</span><br><span class="line"></span><br><span class="line">ws.onopen = function(event) &#123;</span><br><span class="line">  console.log(&quot;Connection open ...&quot;);</span><br><span class="line">  ws.send(&quot;Hello WebSocket!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ws.onmessage = function(event) &#123;</span><br><span class="line">  console.log(&quot;Received Message: &quot; + event.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ws.onclose = function(event) &#123;</span><br><span class="line">  console.log(Connection closed.)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、WebSocket 客户端的 API</p><p>(1) WebSocket 构造函数<br>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。eg：<code>var ws = new WebSocket(&#39;ws://localhost:8080&#39;);</code> 执行语句之后，客户端就会与服务器进行连接。</p><p>(2) webSocket.readyState<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># readyState属性返回实例对象的当前状态，共有四种</span><br><span class="line"></span><br><span class="line">CONNECTING：值为0，表示正在连接。</span><br><span class="line">OPEN：值为1，表示连接成功，可以通信了。</span><br><span class="line">CLOSING：值为2，表示连接正在关闭。</span><br><span class="line">CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</span><br></pre></td></tr></table></figure></p><p>(3) webSocket.onopen<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 实例对象的 onopen 属性，用于指定连接成功后的回调函数</span><br><span class="line">ws.onopen = function () &#123;</span><br><span class="line">  ws.send(&apos;Hello Server!&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如果要指定多个回调函数，可以使用 addEventListener 方法</span><br><span class="line">ws.addEventListener(&apos;open&apos;,</span><br><span class="line">  function fun1 (event) &#123; ws.send(&apos;Hello Server1!&apos;);&#125;,</span><br><span class="line">  function fun2 (event) &#123; ws.send(&apos;Hello Server2!&apos;);&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; WebSocket 入门 &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法入门04</title>
    <link href="yanchongsheng.github.io/2018/11/20/Algorithm-2018-11-20-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A804/"/>
    <id>yanchongsheng.github.io/2018/11/20/Algorithm-2018-11-20-算法入门04/</id>
    <published>2018-11-20T12:03:26.000Z</published>
    <updated>2018-11-28T12:54:07.322Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">  链表 </blockquote><a id="more"></a><p>1、常见的缓存淘汰策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p><p>2、不管是「指针」还是「引用」，实际上，它们的意思都是一样的，都是<strong>存储</strong><code>所指对象的</code><strong>内存地址</strong>。</p><p>3、指针：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p><p>在编写链表代码的时候，我们经常会有这样的代码：p-&gt;next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。</p><p>4、哨兵：解决「边界问题」的，不直接参与业务逻辑。如果引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。也把这种有哨兵结点的链表叫带头链表。哨兵结点是不存储数据的。</p><p>如何表示一个空链表？head=null 表示链表中没有结点了。其中 head 表示头结点指针，指向链表中的第一个结点。</p><p>5、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char* 是声明一个字符类型的指针</span><br><span class="line"></span><br><span class="line"># 声明一个指针 c，这个指针指向的内存地址上只能存放字符类型的值</span><br><span class="line"># 在 char* c = &quot;Hello World&quot;; 中，&quot;Hello World&quot; 是长度为 12 的字符『数组』常量，其最后一个元素是&apos;\0&apos;，而这句代码执行的结果是将 c 指向了 &quot;Hello World&quot; 的第一个字符 &apos;H&apos;，c 后面的连续内存依次存放 &apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos; &apos;,&apos;W&apos;,&apos;o&apos;,&apos;r&apos;,&apos;l&apos;,&apos;d&apos;,&apos;\0&apos;</span><br><span class="line"></span><br><span class="line">char* c = &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure></p><p>6、重点留意边界条件处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果链表为空时，代码是否能正常工作？</span><br><span class="line"></span><br><span class="line">如果链表只包含一个结点时，代码是否能正常工作？</span><br><span class="line"></span><br><span class="line">如果链表只包含两个结点时，代码是否能正常工作？</span><br><span class="line"></span><br><span class="line">代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</span><br></pre></td></tr></table></figure></p><p>7、常见链表操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单链表反转</span><br><span class="line"></span><br><span class="line">链表中环的检测</span><br><span class="line"></span><br><span class="line">两个有序的链表合并</span><br><span class="line"></span><br><span class="line">删除链表倒数第 n 个结点</span><br><span class="line"></span><br><span class="line">求链表的中间结点</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;  链表 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法基础" scheme="yanchongsheng.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法基础" scheme="yanchongsheng.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法基础03</title>
    <link href="yanchongsheng.github.io/2018/11/15/Algorithm-2018-11-15-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%8003/"/>
    <id>yanchongsheng.github.io/2018/11/15/Algorithm-2018-11-15-算法基础03/</id>
    <published>2018-11-15T12:26:06.000Z</published>
    <updated>2018-11-28T10:47:04.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 数组 </blockquote><a id="more"></a><h2 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h2><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><blockquote><p>线性表（Linear List）: 线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p>连续的内存空间和相同类型的数据 : 正是因为这两个限制，它才有了一个堪称「杀手锏」的特性：「随机访问」。计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。</p></blockquote><h2 id="一般使用数组而不用容器的情况"><a href="#一般使用数组而不用容器的情况" class="headerlink" title="一般使用数组而不用容器的情况"></a>一般使用数组而不用容器的情况</h2><p>1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p><ol><li><p>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</p></li><li><p>还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：<code>ArrayList&lt;ArrayList &gt; array</code>。</p></li></ol><p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 数组 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法基础" scheme="yanchongsheng.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法基础" scheme="yanchongsheng.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
