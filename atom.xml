<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有才的博客</title>
  
  <subtitle>不孤独，无自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="yanchongsheng.github.io/"/>
  <updated>2018-09-28T07:36:51.763Z</updated>
  <id>yanchongsheng.github.io/</id>
  
  <author>
    <name>Yan ChongSheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 入门总结(七)</title>
    <link href="yanchongsheng.github.io/2018/09/28/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%83)/"/>
    <id>yanchongsheng.github.io/2018/09/28/Linux入门总结(七)/</id>
    <published>2018-09-28T13:22:24.000Z</published>
    <updated>2018-09-28T07:36:51.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(七) —— Shell 编程 </blockquote><a id="more"></a><h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><p>1、正则表达式与通配符<br><strong>正则表达式</strong>用来在<strong>文件中</strong>匹配符合条件的<strong>字符串</strong>，正则是<strong>包含匹配</strong>。grep、awk、sed 等命令可以支持正则表达式。</p><p><strong>通配符</strong>用来匹配符合条件的<strong>文件名</strong>，通配符是<strong>完全匹配</strong>。ls、find、cp 这些命令不支持正则表达式，所以只能使用 Shell 自己的通配符来进行匹配了。</p><p>注意：通配符和正则表达式这种区分，仅限于 Linux 的 Shell 当中。</p><p><img src="/upload_image/Basic_Regex.png" alt="基础正则表达式" title="基础正则表达式"></p><p>注意：这里是基础正则表达式，还存在扩展正则表达式。</p><p>注意：「^」位于中括号里面表示取反，位于外面表示行首。</p><ol><li><p>「*」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 匹配所有内容，包括空白行（即 a 出现了 0 次）</span><br><span class="line">grep &quot;a*&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配至少包含一个 a 的行</span><br><span class="line">grep &quot;aa*&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配至少包含两个 a 的行</span><br><span class="line">grep &quot;aaa*&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「.」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># s..d 匹配在 s 和 d 之间一定有两个字符的所在行</span><br><span class="line">grep &quot;s..d&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配在 s 和 d 之间有任意字符，把 .* 当做一个整体看，表示除换行符外任意一个字符出现任意次</span><br><span class="line">grep &quot;s.*d&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配所有内容</span><br><span class="line">grep &quot;.*&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「^」行首、「$」行尾示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 以 M 开头的行</span><br><span class="line">grep &quot;^M&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 以 n 结尾的行</span><br><span class="line">grep &quot;n$&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配空白行</span><br><span class="line">grep -n &quot;^$&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「[]」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 匹配 s 和 i 之间，要么是 a、要么是 o。注意：一个中括号只匹配一个字符</span><br><span class="line">grep &quot;s[ao]id&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配任意一个数字</span><br><span class="line">grep &quot;[0-9]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配以小写字母开头的行</span><br><span class="line">grep &quot;^[a-z]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配不用小写字母开头的行</span><br><span class="line">grep &quot;^[^a-z]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配不用字母开头的行</span><br><span class="line">grep &quot;^[^a-zA-Z]&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><p>注意：中括号里面是不能匹配换行符的。</p><ol><li>「\」示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 匹配使用「.」结尾的行</span><br><span class="line">grep &quot;\.$&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><p>注意：「.」在正则里面表示任意一个字符，所以这里要加转义符。</p><ol><li>其他示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># a 连续出现 3 次</span><br><span class="line">grep &quot;a\&#123;3\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 包含连续的 3 个数字的字符串所在行</span><br><span class="line">grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配最少用连续三个数字开头的行</span><br><span class="line">grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配在 s 和 i 之间，最少有一个 a，最多有三个 a</span><br><span class="line">grep &quot;sa\&#123;1,3\&#125;i&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(七) —— Shell 编程 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(六)</title>
    <link href="yanchongsheng.github.io/2018/09/25/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AD)/"/>
    <id>yanchongsheng.github.io/2018/09/25/Linux入门总结(六)/</id>
    <published>2018-09-25T13:45:15.000Z</published>
    <updated>2018-09-28T03:20:42.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(六) —— Shell 基础 </blockquote><a id="more"></a><h2 id="Shell-概述"><a href="#Shell-概述" class="headerlink" title="Shell 概述"></a>Shell 概述</h2><p>1、Shell 是什么？<br>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统程序，用户可以用 Shell 来启动、挂起、停止甚至编写一些程序。</p><p>Shell 还是一个功能相当强大的编程语言。Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。</p><p>2、Shell 的分类<br>Bourne Shell：从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh。</p><p>C Shell：C Shell 主要在 BSD (Berkeley Software Distribution，是一个操作系统的名称，衍生自 Unix，被称为伯克利 Unix) 版的 Unix 系统中使用，其语法和 C 语言相类似而得名。</p><p>Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh、ksh、Bash、psh、zhs；C 家族主要包括：csh、tcsh。</p><p>Bash (Bourne Again Shell): Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。</p><p>3、Linux 支持的 Shell<br>在 「/etc/shells」文件中保存着当前系统支持的 Shell。注意：只要是系统支持的 Shell，我们就可以通过输入对应的 Shell 名字来进行切换。</p><p>4、echo 输出命令<br>echo 是反射、回声的意思。是用来输出的命令。格式：<code>echo [选项][输出内容]</code>；选项：<code>-e</code>，支持反斜杠控制的字符转换。<br>eg：<code>echo &#39;Hello World!&#39;</code>  注意：感叹号在 Shell 中有特殊的作用，所以这里使用单引号。</p><p>5、Linux 中常见的转义符<br><img src="/upload_image/Escape_Character.png" alt="Linux 中常见的转义符" title="Linux 中常见的转义符"></p><p>eg：<code>echo -e &quot;ab\bc&quot;</code> 删除左侧字符；输出结果：<code>ac</code>；分析：<code>\b</code> 代表的是退格键。<br>eg：<code>echo -e &quot;a\tb\tc\nd\te\tf&quot;</code> 制表符与换行符。<br>eg: <code>echo -e &quot;\e[1;31m abcd \e[0m&quot;</code> 带颜色输出内容；输出结果：<code>红色的 abcd</code>；分析：31m=红色；「\e[1;」表示开启颜色输出，「\e[0m」    表示结束颜色输出。</p><p>6、第一个 Shell 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/Bash</span><br><span class="line"><span class="meta">#</span>The first program</span><br><span class="line"><span class="meta">#</span>Author: YanChongsheng E-mail: yanchongsheng@gmail.com</span><br><span class="line">echo -e "YanChongsheng is the most handsome man in China."</span><br></pre></td></tr></table></figure><p>注意：「#!/bin/Bash」这句话不是注释，而是标称，标称以下内容是 Shell 脚本。在 Linux 中以 # 号开头的是注释。</p><p>7、脚本执行</p><ul><li>方式一：赋予执行权限，直接运行 <code>赋予权限：chmod 755 hello.sh 运行脚本：./hello.sh</code></li><li>方式二：通过 Bash 调用执行脚本：<code>bash hello.sh</code></li></ul><p>注意：使用 base 执行脚本的时候，脚本甚至可以没有执行权限。它的意思是通过这个 Shell 来解释这个 shell 脚本文件，所以只要里面的内容是正确的，连执行权限都可以不用给就可以执行，但是最习惯的执行方法还是第一种。</p><p>cat 命令给其加上选项 -A ：表示查看所有的文件内容，包括隐藏字符，例如回车符就属于文件中的隐藏字符。在 Linux 中，回车符识别为「$」号。但是 Windows 中的回车符是「^M$」，表示这个 shell 是在 windows 中编辑完成的，要想在 Linux 中执行，就需要进行转换，利用命令: dos2unix [文件名]。注意：如果 dos2unix 命令没有则需要安装：<code>yum -y install dos2unix</code>。</p><h2 id="Bash-的基本功能"><a href="#Bash-的基本功能" class="headerlink" title="Bash 的基本功能"></a>Bash 的基本功能</h2><p>1、历史命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：histor [选项][历史命令保存文件]</span><br><span class="line">选项：</span><br><span class="line">    -c  清空历史命令</span><br><span class="line">    -w  把缓存中的历史命令写入历史命令保存文件「~./bash_histor」</span><br></pre></td></tr></table></figure></p><p>注意：每次登陆之后所敲的命令都会放在 history 即内存中，并不会放入 ~/.bash_history 文件，而是等正常退出以后，才会将内存中的历史命令写入到 ~/.bash_history 文件中的。注意：-c 会清除内存中和文件中的所有的历史命令。</p><p>历史命令默认会保存 1000 条，可以在环境变量配置文件「/etc/profile」中进行修改 <code>HISTSIZE=1000</code> 注意：重新登录以后才会生效。如果超过 1000，则删除第 1 条命令，保存第 1001 条命令。</p><p>历史命令的调用：</p><ol><li>使用上、下箭头调用以前的历史命令</li><li>使用「!n」调用第 n 条历史命令</li><li>使用「!!」执行上一条命令</li><li>使用「!字符」执行最后一条以该字符串开头的命令</li></ol><p>2、命令别名：<br>设定命令别名：alias 别名=’原命令’。注意：用命令行方式定义的别名它只会临时生效，一旦系统重启，这个别名就会消失。<br>查询命令别名：alias 别名</p><p>3、命令执行顺序</p><ol><li>第一顺位：执行用绝对路径或相对路径执行的命令。</li><li>第二顺位：执行别名。</li><li>第三顺位：执行 Bash 的内部命令。</li><li>第四顺位：执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令。</li></ol><p>输出环境变量：<code>echo $PATH</code></p><p>让别名永久生效：<code>vim /root/.bashrc</code> 注意：修改的是用户对应家目录下的「./bashrc」文件。rc 可以简单的理解为 user config 的简写，取 user 的最后一个字母 r 和 config 的第一个字母 c 组成 rc。</p><p>删除别名：<code>unalias 别名</code></p><p>4、Bash 常用快捷键<br><img src="/upload_image/Bash_Shortcut_Key.png" alt="Bash 常用快捷键" title="Bash 常用快捷键"></p><p>5、标准输入输出</p><table><thead><tr><th>设备</th><th>设备文件名</th><th>文件描述符</th><th>类型</th></tr></thead><tbody><tr><td>键盘</td><td>/dev/stdin</td><td>0</td><td>标准输入</td></tr><tr><td>显示器</td><td>/dev/stdout</td><td>1</td><td>标准输出</td></tr><tr><td>显示器</td><td>/dev/stderr</td><td>2</td><td>标准错误输出</td></tr></tbody></table><p>6、输出重定向<br><img src="/upload_image/Output_redirect.png" alt="输出重定向" title="输出重定向"></p><p>注意：不是所有的命令都可以使用输出重定向的，这个命令必须得有输出才可以。<br>注意：错误输出中，2 和 大于号之间不能有空格。</p><p><img src="/upload_image/Output_All.png" alt="正确输出和错误输出同时保存" title="正确输出和错误输出同时保存"></p><p>注意：「/dev/null」是 Linux 中的一个特殊文件，可以把它当成垃圾箱，相当于不保存任何输出。</p><p>7、输入重定向「注意：输入重定向了解即可」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：wc [选项][文件名]</span><br><span class="line">选项：</span><br><span class="line">    -c  统计字符数 (character)</span><br><span class="line">    -w  统计单词数 (word)</span><br><span class="line">    -l  统计行数 (line)</span><br></pre></td></tr></table></figure></p><p>注意：wc 可以统计键盘输入，输入的行数、单词数、字节数，输入完成之后按 ctrl + d，结束并进行统计。注意回车换行符也会被当成字节进行统计。</p><p>把文件作为命令的输入：<code>命令&lt;文件</code>。eg：<code>wc &lt; anaconda-ks.cfg</code></p><p>8、多命令顺序执行<br><img src="/upload_image/Execute_Many_Command.png" alt="多命令顺序执行" title="多命令顺序执行"></p><p>eg：<code>ls; date; cd /user; pwd</code><br>eg: <code>命令 &amp;&amp; echo yes || echo no</code></p><p><img src="/upload_image/Example_Many_Command.png" alt="例子" title="例子"><br>命令 dd 是磁盘或者说是数据复制的命令，但是它不是 cp，cp 命令只能复制文件，但是 dd 命令能复制特殊文件，也能复制分区甚至整个硬盘，不仅复制分区或硬盘的数据，还复制分区或硬盘的文件系统。dd 主要是用来进行磁盘复制。</p><p>9、管道符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：命令1 | 命令2</span><br></pre></td></tr></table></figure></p><p><code>命令1</code> 的<code>正确输出</code>作为<code>命令2</code> 的<code>操作对象</code>。</p><p>注意：命令1 必须正确输出，否则命令2 不会正常执行。</p><p>10、grep 命令，在文件中搜索符合条件的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：grep [选项] &quot;搜索内容&quot;</span><br><span class="line">选项：</span><br><span class="line">    -i  忽略大小写</span><br><span class="line">    -n  输出行号</span><br><span class="line">    -v  反向查找 (注意：-v 查找的是不匹配的行，即反向查找)</span><br><span class="line">    --color=auto  搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure></p><p>通配符<br><img src="/upload_image/Wildcard.png" alt="通配符" title="通配符"></p><p>Bash 中的特殊符号<br><img src="/upload_image/Special_Character.png" alt="Bash 中的特殊符号" title="Bash 中的特殊符号"></p><p>注意：通配符是用来匹配文件名的，起码在 Linux 系统当中是用来匹配文件名的。</p><p>$ 和 $() 的区别是：$ 是用于调用变量的值；而 $() 是用来引用系统命令。</p><h2 id="Bash-的变量"><a href="#Bash-的变量" class="headerlink" title="Bash 的变量"></a>Bash 的变量</h2><p>1、变量设置规则  </p><ol><li><p>变量名称可以由字母、数字、下划线组成，但是不能以数字开头。</p></li><li><p>在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。</p></li><li><p>变量用等号连接值，<strong>等号左右两侧不能有空格</strong>。</p></li><li><p>变量的值如果有空格，需要使用单引号或双引号包括。</p></li><li><p>在变量的值中，可以使用「\」转义符。</p></li><li><p>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名” 或用 ${变量名} 包含。</p></li><li><p>如果是把命令的结果作为变量值赋值给变量，则需要使用反引号或 $() 包含<strong>命令</strong>。</p></li><li><p>环境变量名建议大写，便于区分。</p></li></ol><p>环境变量名大写，目的是为了区分。因为环境变量会让 Linux 当中所有的 Shell 都能使用，Linux 的系统命令也是在所有的 Shell 中都能使用，但是系统命令都是小写，为了让系统命令和环境变量区分开，建议把环境变量都写成大写。</p><p>2、变量分类</p><ol><li>用户自定义变量</li><li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。</li><li>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</li><li>预定义变量：是 Bash 中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li></ol><p>其实位置参数变量是预定义变量的一种，由于位置参数变量相对来说较多，所以我们习惯上将位置参数变量单独作为一个分类。所以这两种变量的限制是一样的，只能更改值。</p><p>3、本地变量<br>用户自定义变量又称为本地变量。「$变量名」的作用是调用变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 定义变量</span><br><span class="line">aa=123</span><br><span class="line"></span><br><span class="line"># 变量叠加</span><br><span class="line">aa=&quot;$aa&quot;456 # 结果：123456</span><br><span class="line">aa=$&#123;aa&#125;789 # 结果：123456789</span><br><span class="line"></span><br><span class="line"># 变量调用</span><br><span class="line">echo $name</span><br><span class="line"></span><br><span class="line"># 变量查看</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># 变量删除</span><br><span class="line">unset name</span><br></pre></td></tr></table></figure></p><p>set 命令：表示查看系统的所有变量，包括系统的环境变量，以及系统变量，自定义的变量。<br>总结：变量的定义、叠加、调用、查看、删除；变量的概念、变量的规则、变量的分类。</p><p>4、环境变量是什么？<br>用户自定义变量只在当前 Shell 中生效。（使用命令行定义的）环境变量会在当前 Shell 和这个 Shell 的所有子 Shell 当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的 Shell 中生效。</p><p>5、设置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 声明变量</span><br><span class="line">export 变量名=变量值</span><br><span class="line"></span><br><span class="line"># 查询变量</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"># 删除变量</span><br><span class="line">unset 变量名</span><br><span class="line"></span><br><span class="line"># 将已经定义好的本地变量变为环境变量</span><br><span class="line">export 变量名</span><br></pre></td></tr></table></figure></p><p>注意：系统当前本身就是在一个 Shell 里面，我们可以直接输入 csh、或 bash 表示进入对应的 Shell，而系统本身的 shell 就是 csh 或者 bash 的父 Shell，这样就创建了一个子 Shell，当然子 Shell 里面还可以有子子 Shell。</p><p>如何查询和确定 Shell 呢？<br>使用命令 <code>pstree</code>，它的作用是确定进程数。</p><p>6、系统常见环境变量<br>PATH：系统查找命令的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出 PATH</span><br><span class="line">echo $PATH</span><br><span class="line"></span><br><span class="line"># PATH 变量叠加</span><br><span class="line">PATH=&quot;$PATH&quot;:/root/sh</span><br></pre></td></tr></table></figure></p><p>PS1：定义系统提示符的变量</p><p><img src="/upload_image/PS1_Character.png" alt="定义系统提示符" title="定义系统提示符"></p><p>eg：<code>PS1=[\u@\h \W]\$</code>。注意习惯在 $ 最后加一个空格，要不然你的命令会紧挨着提示符 # 或者 $。这种写法只是临时生效。</p><p>注意：env 是专门用来查看当前系统的环境变量的。严格来说 PS1 并不是环境变量，因为 env 命令查看不到，必须使用 set 命令查看。虽然它不是环境变量，但是它是系统预留专门用作定义系统操作环境的一个变量。它是环境变量的一个子分支。</p><p><strong>注意：Linux 以冒号为分割符号。</strong></p><p>7、位置参数</p><p><img src="/upload_image/Location_Param.png" alt="位置参数" title="位置参数"></p><p>位置参数变量最大的作用就是向程序中传递需要的值。它的好处是可以在命令执行的同时接受参数。</p><p>注意：位置参数变量的名称和作用都是固定的。我们能做的只是在里面传入不同的值。</p><p>注意：要想进行数值运算，必须加 $(()) 双小括号括起来，它才能进行数值计算，这是 Linux Shell 的标准格式。</p><p>注意：$# 不会计算命令本身，它计算的仅仅只是参数。</p><p><code>$*</code> 和 $@ 的区别：<code>$*</code> 中的所有参数看成是一个整体。$@ 中的每个参数看成是独立的。</p><p>8、预定义变量<br><img src="/upload_image/Predefined_Variable.png" alt="预定义变量" title="预定义变量"></p><p>其实位置参数变量就是预定义变量当中的一个分类，其特点是不能改变变量名，变量的作用也是固定的。</p><p>$? 用来接收和判断上一条命令是否正确执行。注意：&amp;&amp; || 利用的就是 $? 来判断上一条命令是否正确执行的。</p><p>9、接受键盘输入，read 会把键盘输入的数据赋值给后面的变量中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：read [选项] [变量名]</span><br><span class="line">选项：</span><br><span class="line">    -p &quot;提示信息&quot;：在等待 read 输入时，输出提示信息</span><br><span class="line">    -t 秒数：read 命令会一直等待用户输入，使用此选项可以指定等待时间</span><br><span class="line">    -n 字符数：read 命令只接受指定的字符数，就会执行</span><br><span class="line">    -s：隐藏输入的数据，适用于机密信息的输入</span><br></pre></td></tr></table></figure></p><p>注意：如果不加 -n 选项，read 命令在回车以后才会结束，如果加了 -n 选项，则字符数达到 -n 执行的数字，则自动结束 read 并执行。</p><h2 id="Bash-的运算符"><a href="#Bash-的运算符" class="headerlink" title="Bash 的运算符"></a>Bash 的运算符</h2><p>注意：Linux 的 Shell 中变量的类型默认都是字符串型。</p><p>1、declare 声明变量类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：declare [+/-][选项] 变量名</span><br><span class="line">选项：</span><br><span class="line">    -：给变量设定类型属性</span><br><span class="line">    +：取消变量的类型属性</span><br><span class="line"></span><br><span class="line">    -i：将变量声明为整型（integer）</span><br><span class="line">    -x：将变量声明为环境变量</span><br><span class="line">    -p：显示指定变量的被声明的类型</span><br></pre></td></tr></table></figure></p><p>2、数值运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line"></span><br><span class="line"># 方法1</span><br><span class="line">declare -i cc=$aa+$bb</span><br><span class="line"></span><br><span class="line"># 方法2</span><br><span class="line"># 利用 expr 或 let 数值运算工具。注意：「+」号左右两侧必须有空格。</span><br><span class="line">cc=$(expr $aa + $bb)</span><br><span class="line"></span><br><span class="line"># 方法3</span><br><span class="line"># $((运算式)) 或 $[运算式]</span><br><span class="line">cc=$(($aa+$bb))</span><br><span class="line">cc=$[$aa+$bb]</span><br></pre></td></tr></table></figure></p><p>3、运算符<br><img src="/upload_image/Linux_Operator.png" alt="运算符" title="运算符"></p><p>注意：此处数字越大，优先级越高。</p><p>4、变量测试与内容替换<br><img src="/upload_image/Variable_Alternative_Test.png" alt="变量测试与内容替换" title="变量测试与内容替换"></p><p>主要作用：通过 x 的值来确定 y 的情况。这块内容了解即可，完全可以 if 语句来替代，只是系统提供的更简洁、高效一点，用到的时候查一下能看懂就行，不要可以去记忆。</p><h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><p>1、source 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：source 配置文件</span><br><span class="line">或</span><br><span class="line">格式：. 配置文件</span><br></pre></td></tr></table></figure></p><p>注意：source 命令的作用是让你的配置文件生效，即让系统重新读取一遍配置文件。（正常情况下配置文件生效需要重新登录一次，但是利用 source 命令可以直让配置文件生效）。<br>注意：点「.」和配置文件之间有空格，点「.」其实就是 source 的缩写。</p><p>2、环境变量配置文件简介<br>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如 PATH、HISTSIZE、PS1、HOSTNAME 等默认环境变量。</p><p>系统中主要的 5 类环境变量配置文件：</p><ol><li>/etc/profile 的作用：USER 变量、LOGNAME 变量、MAIL 变量、PATH 变量、HOSTNAME 变量、HISTSIZE 变量、umask、调用 /etc/profile.d/*.sh 文件。</li><li>~/.bash_profile 的作用：调用了 ~/.bashrc 文件、在 PATH 变量后面加入了 「:$HOME/bin」这个目录。</li><li>~/.bashrc 的作用：定义默认别名、调用 /etc/bashrc。</li><li>/etc/bashrc 的作用：PS1 变量、umask、PATH 变量、调用 /etc/profile.d/*.sh 文件。</li><li>/etc/profile.d/*.sh</li></ol><p>注意：只要是保存在 /etc 目录中的，表示对所有登录到该 Linux 系统的用户都生效。~/ 表示当前用户的家目录，「.」表示该文件是隐藏文件，这些配置文件针对的是当前用户。「~」表示家目录的意思。</p><p>3、环境变量配置文件作用</p><p><img src="/upload_image/Profile_Invoke_Order.png" alt="环境变量配置文件调用顺序" title="环境变量配置文件调用顺序"></p><p>注意：环境变量默认赋值的时候分两种情况<br>1.一种是用户通过输入用户名和密码的正常登陆。<br>2.一种是用户通过命令切换到子 Shell 的登陆，这种情况是没有输入用户名密码过程的。<br>这两种不同的登陆方法，它读取的配置文件是不一样的。</p><p>注意：环境变量配置文件它们之间是有优先级的。越后面读取的配置文件，其优先级越高，因为后面定义的变量会覆盖前面的变量。</p><p>需要输入用户名密码的正常登录情况配置文件的读取顺序：<br>/etc/profile「 ——&gt; …… ——&gt; /etc/sysconfig/i18n (新版的 Linux 为 /etc/locale.conf) 这些都是 /etc/profile 文件中调用的子文件或子子文件」当完成 /etc/profile 的所有调用以后 /etc/profile 就会将它的调用传递给下一个环境变量配置文件即 ~./bash_profile，然后照着上图依次往下传递。</p><p>发现 /etc/profile 和 /etc/bashrc 中有很多内容是重复的，如 PATH、umask、PS1，注意这个不是单单只是重复。你会发现 /etc/bashrc 中重复定义变量的地方有这样的注释「We’re not a login shell」即该文件定义的是没有登录情况的 Shell 的环境变量。</p><p>4、注销时生效的环境变量配置文件<br>~/.bash_logout 默认为空，可以在里面写一些退出登录时候的操作，比如清空历史命令等操作。</p><p>5、其他配置文件<br>~/.bash_history 历史命令保存的地方。一般不要清空，但是有一种情况例外，比如你给某个服务设置密码，如 mysql，mysql 设置密码的时候使用的是明文（注意：是明文）系统命令，它会把密码记录在历史文件中，所以要清空明文密码记录。</p><p>6、Shell 登录信息<br>1.<strong>本地</strong>终端欢迎信息：/etc/issue<br><img src="/upload_image/Local_Terminal_Character.png" alt="本地终端转义符" title="本地终端转义符"></p><p>注意：欢迎信息不要写 welcome 之类的，应该写的是警告信息。注意：针对的是本地登录。</p><p>2.<strong>远程</strong> 终端欢迎信息：/etc/issue.net<br>注意：转义符在 /etc/issue.net 文件中不能使用，即本地终端的转义符在这里都不能使用，这里只能写纯文本信息。是否显示此欢迎信息由 ssh 的配置文件 /etc/ssh/sshd_config 决定，加入「Banner /etc/issue.net」行才能显示。（记得重启 ssh 服务）。重启 ssh 服务：<code>service sshd restart</code></p><p>3.<strong>本地和远程</strong>登录后欢迎信息：/etc/motd<br>不管是本地登录，还是远程登录，都可以显示此欢迎信息。但是，它是登录后的欢迎信息。刚才那两个文件是登录前的提示信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(六) —— Shell 基础 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="yanchongsheng.github.io/2018/09/21/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>yanchongsheng.github.io/2018/09/21/工厂模式/</id>
    <published>2018-09-21T07:45:07.000Z</published>
    <updated>2018-09-21T11:10:57.172Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"> 工厂模式 </blockquote></p><p>&lt;! – more –&gt;</p><p>1、工厂模式（Factory Pattern），属于创建型模式，它提供了一种创建对象的最佳方式。<strong>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象</strong>。即告诉对象工厂我需要一个什么样的对象，然后就可以坐等对象工厂返回你需要的对象了。</p><p>2、简单工厂模式<br>到底要实例化哪个类，将来会不会增加实例化对象的种类，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>[大话设计模式]<br>[菜鸟教程]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt; 工厂模式 &lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;! – more –&amp;gt;&lt;/p&gt;
&lt;p&gt;1、工厂模式（Factory Pattern），属于创建型模式，它提供了一种创建对象的最佳方
      
    
    </summary>
    
      <category term="设计模式" scheme="yanchongsheng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="yanchongsheng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>推荐阅读</title>
    <link href="yanchongsheng.github.io/2018/09/20/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/"/>
    <id>yanchongsheng.github.io/2018/09/20/推荐阅读/</id>
    <published>2018-09-20T08:41:53.000Z</published>
    <updated>2018-09-20T08:52:09.530Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 记录在工作学习个人认为优秀的博客 </blockquote><a id="more"></a><p>1、<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a></p><p>2、<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></p><p>3、<a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux 命令大全</a></p><p>4、<a href="https://coolshell.cn/" target="_blank" rel="noopener">左耳朵耗子</a></p><p>5、<a href="https://legacy.gitbook.com/explore?lang=zh" target="_blank" rel="noopener">GitBook</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 记录在工作学习个人认为优秀的博客 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人思考" scheme="yanchongsheng.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
    
      <category term="个人思考" scheme="yanchongsheng.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(七)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%83)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Java入门总结(七)/</id>
    <published>2018-09-19T11:45:19.000Z</published>
    <updated>2018-09-21T07:27:59.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(七) —— 随机 </blockquote><a id="more"></a><p>1、Random 类的构造方法可以接受一个 long 类型的种子参数。种子决定了随机产生的序列，种子相同，产生的随机数序列就是相同的。</p><p>2、为什么要指定种子？指定种子是为了实现可重复的随机。</p><p>3、Random 产生的随机数不是真正的随机数，相反，它产生的随机数一般称之为伪随机数，真正的随机数比较难以产生，计算机程序中的随机数一般都是伪随机数。</p><p>4、伪随机数都是基于一个种子数的，然后每需要一个随机数，都是对当前种子进行一些数学运算，得到一个数，基于这个数得到需要的随机数和新的种子。</p><p>5、Random 类是线程安全的，也就是说，多个线程可以同时使用一个 Random 实例对象，不过，如果并发性很高，会产生竞争，这时，可以考虑使用多线程库中的 ThreadLocalRandom 类。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5808954.html" target="_blank" rel="noopener">Java编程的逻辑 —— 随机</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(七) —— 随机 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(六)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AD)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Java入门总结(六)/</id>
    <published>2018-09-19T11:45:19.000Z</published>
    <updated>2018-09-20T03:18:47.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(六) —— 剖析日期和时间 </blockquote><a id="more"></a><p>1、关于时区<br>英国格林尼治是 0 时区，北京是东八区，也就是说格林尼治凌晨 1 点，北京是早上 9 点。0 时区的时间也称为 GMT+0 时间，GMT 是格林尼治标准时间，北京的时间就是 GMT+8:00。</p><p>2、时刻和 Epoch Time(纪元时)<br>所有计算机系统内部都用一个整数表示时刻，这个整数是距离格林尼治标准时间 1970年1月1日0时0分0秒 的毫秒数。格林尼治标准时间 1970年1月1日0时0分0秒 也被称为 Epoch Time (纪元时)。这个整数表示的是一个时刻，与时区无关，世界上各个地方都是同一个时刻。而对于 1970 年以前的时间则使用负数表示。</p><p>3、年历<br>公历和农历都是年历。年历就是对一年有多少月，每月有多少天，甚至一天有多少小时的规则定义。</p><p>时刻是一个绝对时间，对时刻的解读，如年月日周时分秒等，则是相对的，与年历和时区相关。</p><p>Date：表示时刻，即绝对时间，与年月日无关。</p><p>Calendar：表示年历，Calendar 是一个抽象类，其中表示公历的子类是 GregorianCalendar。</p><p>DateFormat：表示格式化，能够将日期和时间与字符串进行相互转换，DateFormat 也是一个抽象类，其中最常用的子类是 SimpleDateFormat。</p><p>TimeZone: 表示时区。Locale: 表示国家和语言。</p><p>4、Date 表示时刻，内部主要是一个 long 类型的值 <code>private transient long fastTime;</code> 几乎所有的未过时的方法都是对该值进行操作的。</p><p>5、Calendar 类是日期和时间操作中的主要类，它表示与 TimeZone 和 Locale 相关的日历信息，可以进行各种相关的运算。</p><p>Calendar.MONTH：表示月，一月份是 0。Calendar.DAY_OF_MONTH：表示日，每月的第一天是 1。Calendar.DAY_OF_WEEK：表示星期几，周日是 1，周一是 2，周六是 7。</p><p>内部，Calendar 会将表示时刻的毫秒数，按照 TimeZone 和 Locale 对应的年历，计算各个日历字段的值，存放在 fields 数组中，Calendar.get 方法获取的就是 fields 数组中对应字段的值。</p><p>内部，根据字段设置或修改时间时，Calendar 会更新 fields 数组对应字段的值，但一般不会立即更新其他相关字段或内部的毫秒数的值，不过在获取时间或字段值的时候，Calendar 会重新计算并更新相关字段。</p><p>6、DateFormat 类主要在 Date 和字符串表示之间进行相互转换。</p><p>7、DateFormat/SimpleDateFormat 不是线程安全的，因为 DateFormat 内部使用了一个 Calendar 实例对象，多线程同时调用的时候，这个 Calendar 实例的状态可能就会紊乱。</p><p>8、总结：Date 表示时刻，与年月日无关，Calendar 表示日历，与时区和 Locale 相关，可进行各种运算，是日期时间操作的主要类，DateFormat/SimpleDateFormat 在 Date 和字符串之间进行相互转换。</p><p>9、Joda 的主要工作都是在毫秒和年月日等年历信息之间进行相互转换。</p><p>10、Joda-Time 中的主要类都被设计为了不可变类，不可变类有一个很大的优点，那就是简单、线程安全，所有看似的修改操作都是通过创建新对象来实现的。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5774483.html" target="_blank" rel="noopener">Java编程的逻辑 —— 剖析日期和时间</a><br><a href="http://www.cnblogs.com/swiftma/p/5794390.html" target="_blank" rel="noopener">Java编程的逻辑 —— Joda-Time</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(六) —— 剖析日期和时间 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(五)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%94)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Linux入门总结(五)/</id>
    <published>2018-09-19T06:36:12.000Z</published>
    <updated>2018-09-28T09:28:56.996Z</updated>
    
    <content type="html"><![CDATA[<p>1、在 Linux 中，umask 的默认值为 022，用来定义默认新建文件的缺省权限。直接执行 umask 命令会得到一个 4 位的数字：0022 第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认的权限 rwxr-xr-x。</p><p>注意：在 Linux 权限管理有一个最基本的定义：缺省创建的文件是不能具有可执行权限的。在 Linux 系统中任何新建的文件都会把可执行权限去掉。所以新建文件实际的权限为 777-022-111 = 644，即rw-r–r–。</p><p>2、RHEL 的全称是 Red Hat Enterprise Linux 红帽企业版 Linux。</p><p>3、「n1,n2d」删除 n1 到 n2 行。例如：删除 1 到 10 行「:1,10d」。「n，$d」删除从某行开始至文本末尾。例如：删除第 8 行至末尾「:8,$d」。在 vim 中，0 表示行首，$ 表示行尾。</p><p>4、在内存小于 2G 的情况下，交换分区应为内存的 2 倍，超过 2G 的话，交换分区为物理内存加上 2G。</p><p>Red Hat 官方文库中有一段话：目前 Red Hat（红帽官方）推荐交换分区的大小应当与系统物理内存的大小保持线性比例关系。不过在小于 2GB 物理内存的系统中，交换分区大小应该设置为内存大小的两倍，如果内存大小多于 2GB，交换分区大小应该是物理内存大小加上 2GB。其原因在于，系统中的物理内存越大，对于内存的负荷可能也越大。</p><p>5、内核分为：进程管理子系统、内存管理子系统、I/O 管理子系统、文件管理系统 4 部分。</p><p>6、UNIX 系统由内核、shell、文件系统和应用程序 4 部分组成。</p><p>7、系统调用有 5 个分别为：open、write、read、close、ioctl。</p><p>所谓系统调用，就是内核提供的、功能十分强大的一系列的函数。这些系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。  </p><p>整个系统调用的过程总结如下：    </p><ol><li>执行用户程序(如: fork)  </li><li>根据 glibc 中的函数实现，取系统调用号并执行 int $0x80 产生中断。  </li><li>进行址空间的转换和堆栈的切换，执行 SAVE_ALL（进行内核模式）。  </li><li>进行中断处理根据系统调用表调用内核函数。  </li><li>执行内核函数。  </li><li>执行RESTORE_ALL并返回用户模式。  </li></ol><p>8、cat 有三个功能：  </p><ol><li>一次显示整个文件。「cat filename」  </li><li>从键盘创建新文件，但是不能编辑已有文件。「cat &gt; filename」  </li><li>将几个文件合并为一个文件。「cat file1 file2 &gt; file」  </li></ol><p>9、Linux下进程通信的八种方法：管道(pipe)，命名管道(FIFO)，内存映射(mapped memeory)，消息队列(message queue)，共享内存(shared memory)，信号量(semaphore)，信号(signal)，套接字(Socket)。</p><p>10、ssh 用于远程登录；scp 是 secure copy 的缩写，用于远程数据传输。</p><p>11、MMU(Memory Management Unit) 内存管理单元，是中央处理器用来管理虚拟内存和物理内存寄存器的控制线路，同时也负责虚拟内存映射为物理内存等。即在 CPU 和物理内存之间进行地址转换，将地址从逻辑空间映映射到物理地址空间。</p><p>12、压缩解压命令 tar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：tar [选项] [压缩后文件名] [目录]</span><br><span class="line">选项：</span><br><span class="line">  -c(create)  打包</span><br><span class="line">  -x(extract)  解包</span><br><span class="line">  -v(verbose)  显示详细信息</span><br><span class="line">  -f(file)  指定文件名</span><br><span class="line">  -z(gzip)  打包同时压缩/解压缩</span><br></pre></td></tr></table></figure></p><p>13、内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file 对象，file 对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的 file 对象。需要注意的是，file 对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的 file 对象，从而共享这个打开的文件。file 对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为 0 时，内核才销毁 file 对象，因此某个进程关闭文件，不影响与之共享同一个 file 对象的进程。</p><p>14、查找当前目录不包括子目录命令：<code>find . -name &quot;*.c&quot; -maxdepth 1</code>。最大深度为 1，表示当前目录。如果为 0，则表示只对命令行参数有效。</p><p>注意：符号「&gt;」是定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空；</p><p>7、<br>wc -l        # 统计行数<br>wc -w      # 统计单词数量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在 Linux 中，umask 的默认值为 022，用来定义默认新建文件的缺省权限。直接执行 umask 命令会得到一个 4 位的数字：0022 第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认
      
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(五)</title>
    <link href="yanchongsheng.github.io/2018/09/18/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%94)/"/>
    <id>yanchongsheng.github.io/2018/09/18/Java入门总结(五)/</id>
    <published>2018-09-18T10:54:55.000Z</published>
    <updated>2018-09-18T11:03:01.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(五) —— Arrays 类 </blockquote><a id="more"></a><p>1、Java 中的 Arrays 类中包含一些对数组操作的静态方法。</p><p>2、Arrays 的 toString 方法可以方便的输出一个数组的字符串形式。</p><p>3、数组排序之基本类型，对指定类型的数组按升序进行排序。sort 方法还可以指定排序范围 [fromIndex, toIndex)。</p><p>4、数组排序之对象类型，sort 还可以直接接受对象类型，但对象需要实现 Comparable 接口。</p><p>5、数组排序之自定义比较器，sort 还可以接受一个比较器作为参数。Comparator 就是比较器，它是一个接口，最主要的是 compare 这个方法，它比较两个对象，返回一个表示比较结果的值，-1 表示 o1 小于 o2，0 表示相等，1表示 o1 大于 o2。排序是通过比较来实现的，sort 方法在排序的过程中，需要对对象进行比较的时候，就调用比较器的 compare 方法。</p><p>6、需要注意的是 binarySearch 针对的必须是已排序数组，如果指定了 Comparator，需要和排序时指定的 Comparator 保持一致，另外，如果数组中有多个匹配的元素，则返回哪一个是不确定的。</p><p>7、在创建多维数组时，除了第一维的长度需要指定外，其他维的长度不需要指定，甚至，第一维中，每个元素的第二维的长度可以不一样。</p><p>8、多维数组到底是什么呢？其实，可以认为，多维数组只是一个假象，只有一维数组，只是数组中的每个元素还可以是一个数组，这样就形成二维数组，如果其中每个元素还都是一个数组，那就是三维数组。</p><p>9、Arrays 类的 sort 实现原理：  </p><blockquote><ul><li>基本数据类型数据：双枢轴快速排序(Dual-Pivot Quicksort)；是一种对快速排序（不稳定）进行优化后的算法；  </li><li>引用数据类型数据：TimSort；是一种对归并排序（稳定）进行优化后的算法；</li></ul></blockquote><p>它们之所以没有采用相同的排序算法，跟排序算法的稳定性有关。快速排序更快，但不稳定，而归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没有关系。但对于对象类型，相同只是比较结果一样，它们还是不同的对象，其他实例变量也不见得一样，稳定不稳定可能就很有关系了，所以采用归并排序。</p><p>10、Comparator 接口和 Comparable 接口？<br><a href="https://blog.csdn.net/zolalad/article/details/30060499" target="_blank" rel="noopener">Comparable 接口和 Comparator 接口的比较</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5747942.html" target="_blank" rel="noopener">Java编程的逻辑 —— 剖析 Arrays</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(五) —— Arrays 类 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/17/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/17/Linux入门总结(四)/</id>
    <published>2018-09-17T11:53:18.000Z</published>
    <updated>2018-09-20T12:30:39.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(四) —— Vim 编辑器 </blockquote><a id="more"></a><h2 id="Vim-简介"><a href="#Vim-简介" class="headerlink" title="Vim 简介"></a>Vim 简介</h2><hr><p>Vim 有三种命令模式。可以使用 vim 加上任何一个已经存在或者你想创建的文件名就可以进入 Vim 默认的命令模式。vi 和 vim 都是命令，两个的效果一模一样，一个是早期的一个是 Vi 的增强版（全名 Vi imporove 简称 Vim） 。Vim 命令默认进入的是命令模式，在该模式下，你敲的任何一个字符系统都会当成命令来处理。要想进入文本的插入模式，你需要输入插入命令，比较常用的有 i、a、o 就会进入到插入模式，要想退出插入模式，则可以使用 Esc 键，表示退出插入模式，但是此时进入到的是命令模式，此时你输入的任何内容都会被当成命令。在命令模式里面按「：」冒号就会进入到编辑模式，此时输入的就是编辑模式的命令了，即你输入的内容都会被当成是编辑模式的命令。比如设置行号命令：set number（简写：set nu）。编辑模式的命令执行完成以后它会自动的回到命令模式，所以冒号后面输入的内容才是编辑模式的命令。保存退出命令模式：「:wq」。</p><p><img src="/upload_image/Vim_Model.png" alt="Vim 工作模式" title="Vim 工作模式"></p><h2 id="命令模式和编辑模式常用命令"><a href="#命令模式和编辑模式常用命令" class="headerlink" title="命令模式和编辑模式常用命令"></a>命令模式和编辑模式常用命令</h2><hr><p><img src="/upload_image/Insert_Command.png" alt="插入命令" title="插入命令"><br>注意：在使用小 a 的时候光标会自动往后跳一格，例如：we 光标现在在 w 上，按  a以后光标自动跳到 e 上，然后在 e 的前面插入，实际上就是在 w 的后面插入。</p><p><img src="/upload_image/Position_Command.png" alt="定位命令" title="定位命令"><br>注意：上图中前面有冒号的表示编辑模式命令，没有冒号的表示命令模式命令。</p><p><img src="/upload_image/Delete_Command.png" alt="删除命令" title="删除命令"></p><p><img src="/upload_image/Copy_Move_Command.png" alt="复制和剪切命令" title="复制和剪切命令"></p><p><img src="/upload_image/Replace_Cancel_Command.png" alt="替换和取消命令" title="替换和取消命令"></p><p><img src="/upload_image/Explore_Replace_Command.png" alt="搜索和搜索替换命令" title="搜索和搜索替换命令"><br>Linux 中的查找是严格区分大小写的，但是我们可以设置忽略大小写。<br>「:%s 表示全局替换」「g 表示替换的时候不询问」「c表示替换的时候要询问」</p><p><img src="/upload_image/Save_Exit_Command.png" alt="保存和退出命令" title="保存和退出命令"></p><h2 id="Vim-使用技巧"><a href="#Vim-使用技巧" class="headerlink" title="Vim 使用技巧"></a>Vim 使用技巧</h2><hr><p>「:r 文件名」可以导入一个文件的内容到当前 vim 编辑的文件之中。eg：「:r /etc/issue」导入的位置为刚才你光标所在的位置。</p><p>「:!命令」可以在不退出 vim 的情况下，执行系统响应的操作命令。eg：「:!which ls」</p><p>「:r!命令」将一个命令的执行结果导入到当前的 vim 文件里面。eg：「:r!date」</p><p>自定义快捷键「:map 快捷键 触发命令」。eg：「:map ^p I#<esc>」^p 表示 ctrl + p 的快捷键，该快捷键代表的命令是：跳到行首并进入插入模式，插入 # 号，然后退出。eg：「:map ^b 0x」表示用快捷键 ctrl + b 表示删除行首字母。</esc></p><p>注意：设置快捷键的方式是，使用 ctrl + v + 所需字母；或者先按 ctrl + v，再按 ctrl + 所需字母，效果是一样的。这种是构造 ctrl + 字母的快捷键的方法。</p><p>连续行注释：「n1,n2s/^/#/g」表示从 n1 行开始到 n2 行，每行的行首都增加 # 号，并且替换的时候不询问。<br>去掉连续行注释：「n1,n2s/^#//g」表示从 n1 行开始到 n2 行，每行的行首的 # 号都替换为空，并且替换的时候不询问。<br>如果注释符是「//」则需要转义：「:n1,n2s/^/\/\//g」表示从 n1 行开始到 n2 行，每行的行首都增加 // 号，并且替换的时候不询问。<br>注意：「^」表示行首的意思。注意：在 Linux 中「\/」中「\」表示转义符的意思「/」它才是真正的符号。</p><p>替换命令：「:ab 旧内容 新内容」即「:ab a b」这个命令可以简单的理解为：当你输入 a，它会自动的帮你转换成 b。eg: 「:ab sb hello」 当前输入 sb 的时候，会自动的替换成 hello。</p><p>注意：以上定义的快捷键重启以后都不存在，要想永久生效，你需要将其定义在每个用户的宿主（家）目录中的配置文件里面。以 root 为例：vi /root/.vimrc (注意这个配置文件叫 .vimrc)这里面只能放一些<strong>编辑模式</strong>的命令：比如设置行号、设置快捷键、ab 命令（前面可以没有冒号「:」）。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href=""></a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(四) —— Vim 编辑器 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/12/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/12/Linux入门总结(三)/</id>
    <published>2018-09-12T12:28:43.000Z</published>
    <updated>2018-09-13T06:25:19.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(三) —— Linux 网络 </blockquote><a id="more"></a><p>mkdir(make directories) cd(change direcotry) pwd(print working directory) rmdir(remove empty directories) cp(copy) -r(directory) -p(property) mv(move) rm(remove) -r(directory) -f(force)<br>mkdir 创建一个新的目录 -p 创建一个新的目录的同时用 -p 再递归创建一个子目录；cd 切换目录；pwd查看当前的工作目录；rmdir 删除一个空目录；cp 复制文件 -r 复制目录 -p复制的时候保持文件的属性；mv 剪切或者给一个文件改名；rm 删除文件 -r 删除目录 -f删除目录或者文件的同时不希望询问确认；</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(三) —— Linux 网络 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(三)</title>
    <link href="yanchongsheng.github.io/2018/09/12/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/12/求实英语(三)/</id>
    <published>2018-09-12T11:27:16.000Z</published>
    <updated>2018-09-21T03:15:34.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(三) —— 过去时 </blockquote><a id="more"></a><p>1、你去年经常拜访他们吗？<br>Did you ofter visit them last year?</p><p>2、三年前你对这种工作有多少经验？<br>我的：How much experience did you have for this job three years ago?<br>答案：How much experience in this kind of work did you have three years age?  </p><p>3、我没及时告诉她，因为我病了。<br>我的：I don’t tell her in time, because i was ill.<br>答案：I din’t tell her in time, because i was ill.</p><p>4、我上周就认知他了，可他却一点儿也不了解我。<br>我的：I knew him last week, but he don’t know me little.<br>答案：I knwe him last wekk, but he didn’t know me at all.</p><p>5、昨天你和王先生在哪儿？<br>where were you with Mr. Wang yesterday?</p><p>6、你见过那个新来的老板了吗？<br>我的：Do you have seen the new boss?<br>答案：Have you seen that new boss?</p><p>7、去年她像妈妈，可今年谁也不像。(此处 like 当介词)<br>我的：She was like her mother last year, but she isn’t like anyone this year.<br>答案：She was like her mother last year, but she is like no noe this year.</p><p>8、 谁问有关我学习的事儿来着？<br>我的：Who was asked me about my study？<br>答案：Who has asked something about my study?</p><p>9、爸爸昨晚没有责怪我。<br>Our father did’t scold me last night.</p><p>10、昨天你在哪儿听到的那个消息？我是从报纸上看到的。<br>where did you hear that news yesterday？I read it from the paper.</p><p>11、我的电脑又出毛病了。<br>我的：My computer has broken again.<br>答案：Something was wrong again with my computer.</p><p>12、昨天我很紧张，你呢？<br>I was very nervous yesterday, and how were you?</p><p>13、你们的值日生昨天擦黑板了吗？<br>Did your students on duty clean the blackboard yesterday?</p><p>14、今天上午李先生出什么事了？<br>我的：What did happend with Mr.Li this forenoon？<br>答案：What happended to Mr. Li this morning?</p><p>15、由于贫穷他去年就辍学了，我们去看看他吧。<br>我的：Because of poverty he droped out school last year, we are looking  at him tomorrow.<br>答案：He quit school last year because of being poor, Let’s go to see him tomorrow.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(三) —— 过去时 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(二)</title>
    <link href="yanchongsheng.github.io/2018/09/12/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/12/求实英语(二)/</id>
    <published>2018-09-12T11:27:16.000Z</published>
    <updated>2018-09-12T12:17:05.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(二) —— 主谓宾 </blockquote><a id="more"></a><p>1、他整天没地方去也没事儿干。<br>He goes nowhere and has nothing to do every day.</p><p>2、她天天在哪儿吃午饭？<br>Where does she have lunch every day?</p><p>3、你怎么不常和他们一块儿来？<br>Why don’t you often come with them?</p><p>4、王芳有姐姐吗？<br>Does WangFang have any sisters?</p><p>5、为什么他总听你的而不听我的？我不知道。<br>Why does he always listen to you but doesn’t listen to me? I don’t know.</p><p>6、他了解你多少？你非常了解他吗？<br>How much does he know you? Do you know him very well?</p><p>7、你们每周怎么去那儿?<br>How do you get there every week?</p><p>8、李梅不知道那事儿，但我知道。<br>LiMei doesn’t know that but me.</p><p>9、每天下班后，Tod 都载我回家。<br>Tod picks me up home after work every day.</p><p>10、这些小狗都叫什么？它的名字是 TianTian,那只叫 LeLe。<br>What are these dogs’ names? Its name is TianTian, that is called LeLe.</p><p>11、他准时上学并及时做作业。<br>He goes to school on time and does his homework in time.</p><p>12、没人相信他，因为他经常撒谎。他太丢人了。<br>Nobody believes him because he often tell lies. He is very shameful.</p><p>13、你妈把我的手表放什么里边了？<br>what does your mother put my watch in?</p><p>14、我像他，但却不喜欢他。<br>I am like hime, but I don’t like him.</p><p>15、你这么辛苦工作是为了什么？<br>what do you work hard for?</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>on time 准时<br>in time 及时</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(二) —— 主谓宾 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker 入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/11/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/11/Docker入门总结(四)/</id>
    <published>2018-09-11T13:33:57.000Z</published>
    <updated>2018-09-12T08:41:27.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Docker 入门总结(四) </blockquote><a id="more"></a><p>1、Docker 包括三个基本概念：<br>镜像（Image）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>容器（Container）：容器的实质是进程。镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p><p>仓库（Repository）：一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>2、<code>$ docker run -it --rm ubuntu:16.04 bash</code><br>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</p><p>3、<code>$ docker system df</code><br>通过以上命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><p>4、docker image ls 选项：<br>默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。<br>docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。<br>-q 只列出镜像的 ID。</p><p>5、Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>1、FROM 指定基础镜像，一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p><p>2、RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><blockquote><p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。<br>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</p></blockquote><p>3、COPY 复制文件</p><blockquote><p>COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</p></blockquote><p>4、ADD 更高级的复制文件<br>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。这个功能其实并不实用，而且不推荐使用。</p><p>5、CMD 容器启动命令</p><blockquote><p>shell 格式：CMD &lt;命令&gt;<br>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]<br>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</p></blockquote><p>6、ENTRYPOINT 入口点<br>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。</p><p>7、ENV 设置环境变量</p><blockquote><p>ENV <key> <value><br>ENV <key1>=<value1> <key2>=<value2>…</value2></key2></value1></key1></value></key></p></blockquote><p>8、VOLUME 定义匿名卷</p><blockquote><p>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]<br>VOLUME &lt;路径&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Docker 入门总结(四) &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求实英语(一)</title>
    <link href="yanchongsheng.github.io/2018/09/11/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%80)/"/>
    <id>yanchongsheng.github.io/2018/09/11/求实英语(一)/</id>
    <published>2018-09-11T11:31:00.000Z</published>
    <updated>2018-09-12T12:17:05.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(一) —— 主系表 </blockquote><a id="more"></a><p>1、我姐姐在那儿吗？她和谁在一起呢？</p><blockquote><p>我的：Is my sister at there? whom is my sister with?<br>答案：Is my sister there? whom is she with?</p></blockquote><p>解析：there 在这里是名词，表示哪个地方的意思，所以不用 at。问句中用她来指代我姐姐。</p><p>2、我妈妈没在家，她和街坊出去了。</p><blockquote><p>我的：My mother is not at home, she is with neighborhood out.<br>答案：My mother is not at home, she is out with some neighbors.</p></blockquote><p>解析：out 在 这里是形容词，表示外面的。</p><p>3、那本书怎么样？它在你的手里吗？</p><blockquote><p>我的：How is that book? Is it in your hand?<br>答案：</p></blockquote><p>4、这是给我的，那些是给谁的？</p><blockquote><p>我的：This is for me, whom are those for?<br>答案：</p></blockquote><p>5、Sam Sterm 根本就没在这儿，他每天在二楼办公。</p><blockquote><p>我的：Sam Sterm is not here at all, he is at second floor everday.<br>答案：Sam Sterm is not here at all, he is at work on the 2nd floor ever day.</p></blockquote><p>解析：在工作用 at work 表示，在二楼用 at 2nd floor 表示，everday 是形容词每天的，而不是每天，这个是副词。</p><p>6、他是干什么的？他不是经理吗？</p><blockquote><p>我的：What is he? Is not he a manager?<br>答案：</p></blockquote><p>7、你的小狗在哪儿？它在什么里边？</p><blockquote><p>我的：Where is your dog? What is it in?<br>答案：</p></blockquote><p>8、这是谁的办公室？里边有人吗？哪间办公室是你的？</p><blockquote><p>我的：Whom is this office? Who is in the office? Which is your  office?<br>答案：Whose office is this? Is anyone in? Which office is yours?</p></blockquote><p>9、我的电话出了毛病，手机在哪儿？</p><blockquote><p>我的：My phone is wrong, where is cell phone?<br>答案：Something is wrong with my telephone,where is the cellphone?</p></blockquote><p>10、电视开着呢，把它关上吧！</p><blockquote><p>我的：The TV is on, turn it off!<br>答案：</p></blockquote><p>11、我的备份没在你的电脑里吗？</p><blockquote><p>我的：Is not my copy in your computer?<br>答案：</p></blockquote><p>12、这是干什么用的？</p><blockquote><p>我的：What is this for?<br>答案：</p></blockquote><p>13、我的手机昨天就在这儿放着呢!</p><blockquote><p>我的：My cellphone was right here yesterday!<br>答案：</p></blockquote><p>14、这个书包是谁的？那是谁的书包？我的在这儿！她的呢？  </p><blockquote><p>我的：Whose bag is this? Whose bag is that? My bag is here! Where is her bag?<br>答案：Whose is this bag? Whose bag is that? Mine is here! where is hers?</p></blockquote><p>15、这本字典不像我的，但那本像。  </p><blockquote><p>我的：This dictionary is not like mine,bug that is like.<br>答案：This dictionary is not like mine,bug that one is.</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、注意区分以下两种形式：<br>Whose is this bag？这个包是谁的？ This bag is whose.<br>Whose bag is this？这是谁的包？   This is whose bag.</p><p>2、区分 我、你、他 这些代词的各种形式：  </p><table><thead><tr><th>主格</th><th>宾格</th><th>属格</th><th>属格(名词性)</th></tr></thead><tbody><tr><td>I</td><td>me</td><td>my</td><td>mine</td></tr><tr><td>you</td><td>your</td><td>your</td><td>yours</td></tr><tr><td>he</td><td>him</td><td>his</td><td>his</td></tr><tr><td>she</td><td>her</td><td>her</td><td>hers</td></tr><tr><td>it</td><td>its</td><td>its</td><td>its</td></tr><tr><td>they</td><td>them</td><td>their</td><td>theirs</td></tr></tbody></table><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://zhidao.baidu.com/question/140269" target="_blank" rel="noopener">英语代词有哪些？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(一) —— 主系表 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/10/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/10/Java入门总结(四)/</id>
    <published>2018-09-10T13:14:54.000Z</published>
    <updated>2018-09-10T11:15:18.823Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/10/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/10/Java入门总结(三)/</id>
    <published>2018-09-10T12:35:49.000Z</published>
    <updated>2018-09-10T11:02:30.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(三) —— NIO </blockquote><a id="more"></a><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>1、在 Java 中，已有的 IO 操作大部分都属于阻塞的操作。为了提升服务器操作的性能，在 JDK1.4 之后增加了 NIO，在整个 NIO 的操作中，基本上都是使用缓冲区完成的。</p><p>2、<code>public abstract class Bufferextends Object</code> 抽象类 Buffer 是一个用于<strong>特定基本类型数据的容器</strong>。</p><p>3、<strong>缓冲区是特定基本类型元素的线性有限序列</strong>。除内容外，缓冲区的基本属性还包括容量、限制和位置：</p><blockquote><p>缓冲区的 容量(capacity) 是它所包含的元素的数量。缓冲区的容量不能为负并且不能更改。<br>缓冲区的 限制(limit) 是第一个不应该读取或写入的元素的索引。缓冲区的限制不能为负，并且不能大于其容量。<br>缓冲区的 位置(position) 是下一个要读取或写入的元素的索引。缓冲区的位置不能为负，并且不能大于其限制。  </p></blockquote><p>对于每个非 boolean 基本类型，此类都有一个子类与之对应。</p><p>4、标记、位置、限制和容量值遵守以下不变式： <code>0 &lt;= 标记 &lt;= 位置 &lt;= 限制 &lt;= 容量</code> 。</p><p>5、清除、反转和重绕   </p><blockquote><p>clear() 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为<strong>容量大小</strong>，将位置设置为 0。<br>flip() 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为<strong>当前位置</strong>，然后将位置设置为 0。<br>rewind() 使缓冲区为重新读取已包含的数据做好准备：它使<strong>限制保持不变</strong>，将位置设置为 0。  </p></blockquote><p>6、直接 与 非直接缓冲区<br>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</p><p>直接字节缓冲区可以通过调用此类的 allocateDirect 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</p><p>直接字节缓冲区还可以通过 mapping 将文件区域直接映射到内存中来创建。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</p><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>1、在 NIO 中，通道是一个可以用来读取和写入数据的一种形式。Channel 接口，用于 I/O 操作的连接。通道表示到实体的开放连接。 通道表示到实体，如硬件设备、文件、网络套接字或可以执行一个或多个不同 I/O 操作（如读取或写入）的程序组件的开放的连接。<strong>通道都是通过操作缓冲区来完成全部功能的。所有的内容都是先读或写到缓冲区之中，再通过缓冲区读或写入到通道中的，即程序不会直接操作通道。</strong><br><img src="/upload_image/Java_Channel.png" alt="Channel 简介" title="Channel 简介"></p><p>2、Java NIO Channel 通道和流非常相似，主要有以下几点区别：  </p><blockquote><p>通道可以读也可以写，流一般来说是单向的（只能读或者写）。<br>通道可以异步读写。<br>通道总是基于缓冲区Buffer来读写。  </p></blockquote><p>3、什么是内存映射？<br>将文件中的某个区域直接映射到内存中；对于较大的文件，这通常比调用普通的 read 或 write 方法更为高效。 在通道中还有一种方式成为内存映射。内存映射是速度最快的，MapperedByteBuffer，使用此种方式读取的内容是最快的，需要将一个输入的操作流绑定在内存映射上。</p><p>内存映射在读取的时候是最快的，但是如果执行的是写入操作则有可能是非常危险的，因为仅仅只是改变数组中的单个元素这样简单的操作就可能直接修改磁盘上的文件，因为修改数据与将数据保存在磁盘上是一样的。</p><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>在 Java NIO 中提供了文件锁的功能，这样当一个线程将文件锁定之后，其他线程是无法操作此文件的，要想进行文件的锁定操作，则要使用 FileLock 类完成，此类的对象需要依靠 FileChannel 进行实例化操作。</p><p>锁定方式：</p><blockquote><p>共享锁：允许多个线程进行文件的读取操作。<br>独占锁：只允许一个线程进行文件的读/写操作。</p></blockquote><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO 浅析</a><br><a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-channel.html" target="_blank" rel="noopener">Java NIO Channel 通道</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(三) —— NIO &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(二)</title>
    <link href="yanchongsheng.github.io/2018/09/06/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/06/Linux入门总结(二)/</id>
    <published>2018-09-06T12:00:23.000Z</published>
    <updated>2018-09-12T12:23:48.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(二) —— Linux 系统安装 </blockquote><a id="more"></a><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>磁盘分区又叫系统分区，是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。从字面意思来讲，磁盘分区指的就是把大的硬盘按照我的需求划分成几个分区，不同类目录与文件可以存储进不同的分区。</p><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><ol><li>主分区：最多只能有 4 个。  </li><li><p>扩展分区「是从主分区的 4 个分区之中拿出 1 个分区作为扩展分区」：</p><blockquote><ul><li>扩展分区最多只能有 1 个（注意：针对一块硬盘来讲，一个硬盘最多只能有一个扩展分区）。</li><li>主分区加扩展分区最多只能有 4 个。</li><li>扩展分区本身不能写入数据也不能格式化，唯一的作用就是用来包含逻辑分区。</li></ul></blockquote></li><li><p>逻辑分区「即扩展分区中的逻辑分区」：可以正确的写入数据和格式化。按照硬盘的限制，一块硬盘最多只能分 4 个分区，即 4 个主分区。这种限制不是 Linux 系统的限制而是硬盘本身的限制，只要硬盘结构不发生变化，这种限制会一直存在。</p></li></ol><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>硬盘正确分区以后还不能写入数据，硬盘还必须经过格式化以后才可以写入数据。</p><p>格式化 (高级格式化) 又称逻辑格式化，它是指根据用户选定的文件系统（如 fat16、fat32、NTFS、ext2、ext3、ext4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。</p><p>在 windows 中可以识别的文件系统有 fat16、fat32、NTFS，在 linux 中可以识别的文件系统有 ext2、ext3、ext4，centOS 默认使用的是 ext4。</p><p>硬盘的格式化最主要的目的就是为了在硬盘当中写入文件系统，写入文件系统最主要的工作就是按照文件系统的规则把硬盘分成等大小的数据块，然后建立 iNode 表，我们把表里的编号称为 i 节点号又名 iNode 号。</p><p>当在查找文件的时候，是通过 iNode 表找到 i 节点号来找到这个文件的条款，从而知道这个文件保存在哪几个数据块之中，从而找到这几个数据块拿出文件，拼凑成我们的文件。这个格子就叫做数据块，又名 block。</p><p>在 centos 当中，默认的文件系统是 ext4，它在进入格式化的时候，它需要把硬盘划分为一个又一个等大小的数据块，这个数据块默认的标准大小为 4kb。假如有一个数据是 10kb，需要占用 3 个格子，最后一个格子只放了 2kb 数据，剩余的 2kb 空闲空间是不能再被其它文件所占用的，这 3 个格子不一定在一块。windows 中有一个磁盘碎皮整理，它的原理就是将保存的同一个文件的格子尽量放到一起，这样更有利于数据的读取。</p><h2 id="硬件设备文件名"><a href="#硬件设备文件名" class="headerlink" title="硬件设备文件名"></a>硬件设备文件名</h2><p>如果是 windows，在进行了分区、格式化之后，给分区分配盘符然后就可以直接使用了。但是 Linux 不行，Linux 在进行了分区、格式化，格式化完成之后，要想给分区分配盘符之前，<strong>还必须给每一个分区起一个设备文件名，或者说给每一个分区起一个硬件设备文件名。</strong></p><p>在 Linux 中所有的硬件设备都是文件。</p><p><img src="/upload_image/Hardware_Name.png" alt="硬件设备文件名" title="硬件设备文件名"></p><p>「/」表示 Linux 中的最高一级目录，也就是根目录。在根目录下有一个 dev 的一级子目录，在 dev 目录中放入的所有的文件都是<strong>硬件文件</strong>。我们将<strong>硬件文件名</strong>，称为<strong>硬件的设备文件名</strong>。</p><p>为什么 Linux 需要「硬件设备文件名」而 windows 不需要？<br>在 windows 中，硬盘分区、格式化之后，然后可以直接分配盘符是因为我们可以在 windows 的图形界面中直接看到这个硬盘在哪（注意：一台机器可能有多个硬盘），所以可以直接分配盘符（windows 有完善的图形界面）。但是 Linux 最早出现的时候，是没有图形界面的，为了让系统知道我要给哪一个硬盘分配盘符，所以被迫需要给每一个硬盘或者硬件设备指定设备文件名。</p><p><strong>硬件设备文件名是固定的，系统自动检测的，我们能看懂就行。</strong> 关于硬盘，我们现在主要使用的是 SATA 硬盘接口，IDE、SCSI 硬盘接口基本被淘汰了。</p><h2 id="分区设备文件名"><a href="#分区设备文件名" class="headerlink" title="分区设备文件名"></a>分区设备文件名</h2><p>硬盘有了「硬件设备文件名」，还要给分区也要分配文件名，这就是「分区设备文件名」。「分区设备文件名」是在硬盘「硬件设备文件名」之后，直接加分区号就可以了。即硬盘有设备文件名，分区也应该有设备文件名，区别是一个是硬件设备文件名，一个是分区设备文件名。</p><p>分区设备文件名：分区文件名是在硬盘文件名之后直接加分区号，1 表示这个硬盘当中的第一个分区，依次类推。<strong>注意分区号有主分区号和逻辑分区号。</strong></p><p>逻辑分区是从 5 开始的，1234 只能给主分区或者扩展分区使用，即使一个硬盘中没有分够 4 个主分区，逻辑分区也不能占用 1234 这 4 个分区号，即不管如何分区 5 都表示逻辑分区的第一个分区。</p><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>windows 中分配盘符的操作在 Linux 中叫做挂载，我们把给分区分配盘符的过程称为挂载，我们把盘符叫做挂载点。在 Linux 中是使用空的目录名称作为盘符，而不是使用 CDEF 作为盘符，理论上任何一个目录都可以作为盘符，实际上有些目录是不可以的。</p><p>对于 Linux 来讲有两个必须分区：根分区、swap 分区（交换分区，大小一般为内存的 2 倍，一般不超过 2GB）。这两个是必须分区，如果不分区，则 Linux 不能安装，只要有这两个分区，Linux 就可以正常使用。还有一个推荐分区，/boot（启动分区，大小一般为 200M)。</p><p>根分区用于存放剩余数据，swap 分区可以理解为虚拟内存，即当我真正的内存不够用的时候可以拿交换分区的硬盘空间来当内存来用，理论上讲 swap分 区应该是内存的两倍，但是最大不超过 2GB，因为虚拟内存到底不是真正的内存，如果给它给的再大，它也不能取代内存，当它达到 2GB 的时候，如果再给大，只会占用我们更多的硬盘空间，但是对我们的系统不会产生更多的影响，所以最大不超过 2GB。</p><p>Boot 分区是专门用来保存启动时候的数据，任何操作系统启动的时候都需要一些硬盘空间，如果不给 boot 分区，万一根分区写满了，系统可能就启动不了了，为了解决这个问题，一般都会给 boot 单独分区。Boot 分区 200MB 足够，不用太大，写完之后不再往 boot 分区写入任何数据，它永远都会有一定的空余空间，就算把根分区写满了，也不会影响 Linux 启动。</p><h2 id="Linux-文件系统结构"><a href="#Linux-文件系统结构" class="headerlink" title="Linux 文件系统结构"></a>Linux 文件系统结构</h2><p><img src="/upload_image/File_System_Structure.png" alt="Linux 文件系统结构" title="Linux 文件系统结构"></p><p>从 Linux 系统上看，boot、home 都是根分区的子目录。但是从硬盘上来看，它们每一个目录都可以有自己独立的硬盘空间，即每一个目录都可以有自己独立的分区，而每个分区又对应某块硬盘空间，所以每个目录都可以有自己独立的硬盘空间。</p><p>挂载点就是分区的盘符，swap 分区即交换分区没有盘符，swap 分区不是给用户用的，是由 Linux 操作系统或者内核直接调用的，所以它根本不需要盘符，有了盘符反而不正确了。swap 对系统性能的影响极小，所以分的空间不用太大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>分区：把大硬盘分为小的逻辑分区；<br>格式化：格式化的目的是为了写入文件系统，当然在写入文件系统的时候会附带的把硬盘当中的数据清空；<br>分区设备文件名：给每个分区定义设备文件名；<br>挂载：给每个分区分配挂载点，这个挂载点必须是目录，而且必须是空的目录才可以进行挂载点分配。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(二) —— Linux 系统安装 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(一)</title>
    <link href="yanchongsheng.github.io/2018/09/06/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>yanchongsheng.github.io/2018/09/06/Linux入门总结(一)/</id>
    <published>2018-09-06T11:18:24.000Z</published>
    <updated>2018-09-12T12:21:26.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(一) —— Linux 系统简介 </blockquote><a id="more"></a><h2 id="Unix-发展史"><a href="#Unix-发展史" class="headerlink" title="Unix 发展史"></a>Unix 发展史</h2><p>Unix 与 Linux 的关系就像是父子关系，Unix 是父亲，Linux 是儿子。肯.汤普森在 1969 年开发出了 Unix 系统。1971 年，肯.汤普森的同事丹尼斯.里奇发明了 C 语言，随后 Unix 系统绝大部分源代码用 C 语言重写，为提高 Unix 系统的可移植性打下基础。</p><h2 id="Unix-主要发行版本"><a href="#Unix-主要发行版本" class="headerlink" title="Unix 主要发行版本"></a>Unix 主要发行版本</h2><p><img src="/upload_image/Unix_Major_Version.png" alt="Unix 主要发行版本" title="Unix 主要发行版本"></p><h2 id="Linux-发展史"><a href="#Linux-发展史" class="headerlink" title="Linux 发展史"></a>Linux 发展史</h2><p>Linux 系统诞生于 1991 年，由芬兰大学生李纳斯(Linux Torvalds) 和后来陆续加入的爱好者共同完成。Unix 和 Linux 的内核都是用 c 语言写的。Linux 是开源软件。</p><h2 id="Linux-发行版和-Linux-内核的区别？"><a href="#Linux-发行版和-Linux-内核的区别？" class="headerlink" title="Linux 发行版和 Linux 内核的区别？"></a>Linux 发行版和 Linux 内核的区别？</h2><p>内核版是 Linux 官方发布的，仅仅是单纯的内核。在拿到内核以后，每个产商可以加入自己的桌面、应用程序等再进行开发，称为发行版。Linux 内核官网：www.kernel.org。</p><h2 id="Linux-主要发行版本"><a href="#Linux-主要发行版本" class="headerlink" title="Linux 主要发行版本"></a>Linux 主要发行版本</h2><p>Linux 主要分为两个系列：redhat 系列和 debian 系列。其本质是一样的，因为两者采用系统的内核。最主要的区别就是软件安装的方式不一样。Redhat 系列主要分为 HEL 和 federo 两个系列，其中 federo 是个人版，HEL 是企业版。对于 Linux 的企业版和个人版跟 windows 是不一样的，对于 windows 而言 windows7 是个人版，windows2008 是企业版，它们的区别是 windows7 可以看成是 windows2008 的一个阉割版，windows2008 才是完整的。但是 Linux 不同，个人版和企业版的区别在于，个人版是开发版，可能有的功能没有进行过测试，更像是一个实验体，而企业版是稳定版。</p><p><img src="/upload_image/Linux_Major_Version.png" alt="Linux 主要发行版本" title="Linux 主要发行版本"></p><h2 id="开源软件的特点"><a href="#开源软件的特点" class="headerlink" title="开源软件的特点"></a>开源软件的特点</h2><ol><li>使用的自由：绝大多数开源软件免费（注意的是开源和免费并不是等同的，开源软件也可以出售，但是卖给你的是源代码，并不是编译之后的代码给你）。</li><li>研究自由：可以获得软件源代码（开放源代码带来的好处——安全，足够多的眼睛可以发现更多的问题，可以容易的看到大神级人物的代码风格和注释）。</li><li>散步及改良自由：可以自由传播、改良甚至销售。</li></ol><h2 id="Linux-的应用领域"><a href="#Linux-的应用领域" class="headerlink" title="Linux 的应用领域"></a>Linux 的应用领域</h2><ol><li>基于 Linux 的企业服务器：企业服务器。</li><li>嵌入式应用：Android 平台就是一个典型的 Linux 嵌入式应用、智能家电如机顶盒、游戏机、数码相机等。</li><li>电影娱乐业：用于电影、图片的后期处理。</li></ol><h2 id="Linux-为什么选择命令行？"><a href="#Linux-为什么选择命令行？" class="headerlink" title="Linux 为什么选择命令行？"></a>Linux 为什么选择命令行？</h2><p>Linux 选用命令行界面主要是考虑到系统的稳定性和安全性，如果装了图形界面，对系统资源的占用是比较庞大的，所以比较不好用。而 windows 考虑的是易用性，windows 系统主要考虑的是系统的易用性。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>1、www.netcraft.com 是一个典型的扫描和踩点网站。只要输入你要查询的网站，就可以获取网站后台服务器所采用的操作系统。该网站是一个全球著名的信息统计网站。从攻击的角度叫踩点，从防御的角度叫扫描。</p><p>2、www.top500.org 会统计全球范围内运算能力排在前 500 的服务器或者叫群组。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(一) —— Linux 系统简介 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker 入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/04/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/04/Docker入门总结(三)/</id>
    <published>2018-09-04T11:41:20.000Z</published>
    <updated>2018-09-05T08:19:56.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Docker 入门总结(三) —— Nginx 容器教程 </blockquote><a id="more"></a><p>1、CentOS7 修改 Nginx 默认 web 目录后 403 ？<br>我这边的原因是：SElinux 没关导致的，直接使用命令 <code>setenforce 0</code> 关闭 SELinux 以后就正常了。具体原因查看：<a href="https://stackoverflow.com/questions/43302142/docker-nginx-selinux-centos-rhel-with-403-forbidden-access" target="_blank" rel="noopener">Docker nginx SELinux</a>。</p><p>2、CentOS7 修改 Nginx 默认 web 目录后 403 ？<br><code>docker container run -d -p 8000:80 --rm --name mynginx -v &quot;$PWD/html&quot;:/usr/share/nginx/html nginx</code><br><code>docker container run -d -p 8000:80 --rm --name mynginx -v &quot;$pwd/html&quot;:/usr/share/nginx/html nginx</code><br>注意：对 PWD 大小写敏感，深坑啊！！！否则会报 403 的错误。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html" target="_blank" rel="noopener">Nginx 容器教程</a><br><a href="http://www.56dr.com/info/iso/18848.html" target="_blank" rel="noopener">Nginx 报 403 forbidden 错误</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Docker 入门总结(三) —— Nginx 容器教程 &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker 入门总结(二)</title>
    <link href="yanchongsheng.github.io/2018/09/04/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/04/Docker入门总结(二)/</id>
    <published>2018-09-04T11:19:19.000Z</published>
    <updated>2018-09-05T11:12:00.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Docker 入门总结(二) —— Docker 微服务教程 </blockquote><a id="more"></a><p>1、站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器……Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。</p><p>2、如何在一台计算机上实现多个服务，让它们互相配合，组合出一个应用程序？</p><p>3、Docker 容器中是否可以再包含 Docker 容器，这样层层嵌套？</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">Docker 教程</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="noopener">Docker 微服务教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Docker 入门总结(二) —— Docker 微服务教程 &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
