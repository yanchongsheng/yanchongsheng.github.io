<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有才的博客</title>
  
  <subtitle>不孤独，无自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="yanchongsheng.github.io/"/>
  <updated>2018-10-22T11:30:21.265Z</updated>
  <id>yanchongsheng.github.io/</id>
  
  <author>
    <name>Yan ChongSheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 入门总结(十二)</title>
    <link href="yanchongsheng.github.io/2018/10/26/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%8D%81%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/10/26/Linux入门总结(十二)/</id>
    <published>2018-10-26T13:22:24.000Z</published>
    <updated>2018-10-22T11:30:21.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十二) —— Shell 编程 </blockquote><a id="more"></a><h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><p>1、正则表达式与通配符<br><strong>正则表达式</strong>用来在<strong>文件中</strong>匹配符合条件的<strong>字符串</strong>，正则是<strong>包含匹配</strong>。grep、awk、sed 等命令可以支持正则表达式。</p><p><strong>通配符</strong>用来匹配符合条件的<strong>文件名</strong>，通配符是<strong>完全匹配</strong>。ls、find、cp 这些命令不支持正则表达式，所以只能使用 Shell 自己的通配符来进行匹配了。</p><p>注意：通配符和正则表达式这种区分，仅限于 Linux 的 Shell 当中。</p><p><img src="/upload_image/Basic_Regex.png" alt="基础正则表达式" title="基础正则表达式"></p><p>注意：这里是基础正则表达式，还存在扩展正则表达式。</p><p>注意：「^」位于中括号里面表示取反，位于外面表示行首。</p><p>test.txt 内容如下，将适用于以下所有用到 test.txt 的地方：</p><table><thead><tr><th>ID</th><th>Name</th><th>Gender</th><th>Score</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>male</td><td>86</td></tr><tr><td>2</td><td>lisi</td><td>female</td><td>90</td></tr><tr><td>3</td><td>wangwu</td><td>male</td><td>83</td></tr></tbody></table><ol><li><p>「*」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 匹配所有内容，包括空白行（即 a 出现了 0 次）</span><br><span class="line">grep &quot;a*&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配至少包含一个 a 的行</span><br><span class="line">grep &quot;aa*&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配至少包含两个 a 的行</span><br><span class="line">grep &quot;aaa*&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「.」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># s..d 匹配在 s 和 d 之间一定有两个字符的所在行</span><br><span class="line">grep &quot;s..d&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配在 s 和 d 之间有任意字符，把 .* 当做一个整体看，表示除换行符外任意一个字符出现任意次</span><br><span class="line">grep &quot;s.*d&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配所有内容</span><br><span class="line">grep &quot;.*&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「^」行首、「$」行尾示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 以 M 开头的行</span><br><span class="line">grep &quot;^M&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 以 n 结尾的行</span><br><span class="line">grep &quot;n$&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配空白行</span><br><span class="line">grep -n &quot;^$&quot; test.txt</span><br></pre></td></tr></table></figure></li><li><p>「[]」示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 匹配 s 和 i 之间，要么是 a、要么是 o。注意：一个中括号只匹配一个字符</span><br><span class="line">grep &quot;s[ao]id&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配任意一个数字</span><br><span class="line">grep &quot;[0-9]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配以小写字母开头的行</span><br><span class="line">grep &quot;^[a-z]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配不用小写字母开头的行</span><br><span class="line">grep &quot;^[^a-z]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配不用字母开头的行</span><br><span class="line">grep &quot;^[^a-zA-Z]&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><p>注意：中括号里面是不能匹配换行符的。</p><ol><li>「\」示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 匹配使用「.」结尾的行</span><br><span class="line">grep &quot;\.$&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><p>注意：「.」在正则里面表示任意一个字符，所以这里要加转义符。</p><ol><li>其他示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># a 连续出现 3 次</span><br><span class="line">grep &quot;a\&#123;3\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 包含连续的 3 个数字的字符串所在行</span><br><span class="line">grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配最少用连续三个数字开头的行</span><br><span class="line">grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配在 s 和 i 之间，最少有一个 a，最多有三个 a</span><br><span class="line">grep &quot;sa\&#123;1,3\&#125;i&quot; test.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h2><p>1、cut 字段提取命令「默认列之间的分隔符为 tab 键」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">格式：cut [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">    -f列号  提取第几列</span><br><span class="line">    -d分隔符  按照指定分隔符分割列</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 提取第二列</span><br><span class="line">    cut -f 2 test.txt</span><br><span class="line"></span><br><span class="line">    # 提取第二、第三列，注意不是范围，是指定的列，中间以逗号分隔</span><br><span class="line">    cut -f 2,3 test.txt</span><br><span class="line"></span><br><span class="line">    # 指定列之间的分隔符为「:」，默认为 tab 键</span><br><span class="line">    cut -d &quot;:&quot; -f 1,3</span><br></pre></td></tr></table></figure></p><p>注意：grep 命令表示在指定的文件中提取匹配的行，cut、awk 命令用来提取匹配的列。cut 命令中列之间的默认分割符为制表符即 tab 键。命令 grep -v [内容]，表示列出不包含指定的内容的行。grep 确认行，cut 确认列，利用这两个命令可以做一些操作，比如，获取所有普通用户的用户名：<code>cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1</code>。</p><p>cut 命令有一个局限就是「无法」识别空格（指识别起来超级麻烦扩展性还差）。对于空格的判断我们使用 awk 命令，但是因为 awk 比较复杂，所以能用 cut 的尽量不要用 awk，因为 cut 简单，但是存在局限性。</p><p>2、printf 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">格式：printf &apos;输出类型输出格式&apos; 输出内容</span><br><span class="line">输出类型：</span><br><span class="line">      %ns     输出字符串。n 是数字，指代输出几个字符</span><br><span class="line">      %ni     输出整数。n 是数字，指代输出几个数字</span><br><span class="line">      %m.nf   输出浮点数。m 和 n 是数字，指代输出的整数位数和小数位数。</span><br><span class="line">              eg：%8.2f 代表共输出 8 位数，其中 2 位是小数，6 位是整数</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">      \a   输出警告音</span><br><span class="line">      \b   输出退格键，即 Backspace 键</span><br><span class="line">      \f   清除屏幕</span><br><span class="line">      \n   换行</span><br><span class="line">      \r   回车，即 Enter 键</span><br><span class="line">      \t   水平输出 Tab 键</span><br><span class="line">      \v   垂直输出 Tab 键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 注意以下命令中是否加了单引号或双引号</span><br><span class="line">    printf %s 1 2 3 4 5 6</span><br><span class="line">    printf %s %s %s 1 2 3 4 5 6</span><br><span class="line">    printf &apos;%s %s %s&apos; 1 2 3 4 5 6</span><br><span class="line">    printf &apos;%s %s %s\n&apos; 1 2 3 4 5 6</span><br></pre></td></tr></table></figure></p><p>printf 是格式化输出命令，类似于 echo 命令。注意：printf 后面不能直接加文件名，也不能接受管道符的内容。但是可以使用 <code>printf &#39;%s&#39; $(cat 文件名)</code> 的形式输出命令执行结果，需要注意的是 printf 没有对格式进行任何调整。</p><p>printf 命令没有 cat 和 echo 的自动格式化功能，为什么还要学习 printf 命令，是因为在 awk 命令中不能调用系统命令 cat 或者 echo，只能使用 printf。</p><p>在 awk 命令的输出中支持 print 和 printf 命令：</p><blockquote><p>print：print 会在每个输出之后自动加入一个换行符（Linux 默认没有 print 命令）。<br>printf：printf 是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符。</p></blockquote><p>注意：print 只能在 awk 中使用。printf 命令在 Linux 系统中直接使用的几率不大，主要是在 awk 命令中使用。</p><p>3、awk 命令，注意单引号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line">    awk &apos;条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ...&apos; 文件名</span><br><span class="line"></span><br><span class="line">条件：</span><br><span class="line">    一般使用关系表达式作为条件</span><br><span class="line">    x &gt; 10</span><br><span class="line">    x &lt;= 10</span><br><span class="line"></span><br><span class="line">动作：</span><br><span class="line">    格式化语句</span><br><span class="line">    流程控制语句</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # $2 表示第 2 列，$4 表示第 4 列</span><br><span class="line">    awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br><span class="line"></span><br><span class="line">    df -h | awk &apos;&#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&apos;</span><br><span class="line"></span><br><span class="line">典例：获取系统中根分区硬盘的使用率，可以用来报警，如果超过80则给管理员提示。</span><br><span class="line">    df -h | grep 只有根分区才存在的字符串 | awk &apos;&#123;printf $5&#125;&apos; | cut -d &quot;%&quot; -f 1</span><br></pre></td></tr></table></figure></p><p>注意：awk 命令虽然是列提取命令，但是它处理数据的时候，是先读入一行数据，然后把这行数据所有的内容都复制给对应的变量，$1 代表第一列，依次类推，然后再判断条件是否符合，对满足条件的执行相应的动作。</p><p>注意：awk 默认是以空格或者制表符作为分割符的。</p><p>注意：BEGIN 必须大写。它位于大括号前，表示它是一个条件，只有满足了这个条件，其后的动作才会被执行。BEGIN 的作用是：在所有的数据读取之前，执行其后面相对应的动作。注意所有的动作都要用单引号括起来。</p><ol><li><p>BEGIN 表示最先执行 BEGIN 条件后面的动作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在进行整正的数据读取之前，即 awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt，打印「This is a transcript.」这句话</span><br><span class="line">awk &apos;BEGIN&#123;printf &quot;This is a transcript. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br></pre></td></tr></table></figure></li><li><p>FS 内置变量<br>FS 的作用是指定分隔符的。注意：awk 命令在处理的时候是先读入第一行数据，然后再执行相应的动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出结果中，第一行数据没有按照预期输出</span><br><span class="line">awk &apos;&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd</span><br><span class="line"></span><br><span class="line"># 改进：读取第一条数据之前，先把分隔符变成「:」</span><br><span class="line">awk &apos;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>END 表示最后执行 END 条件后面的动作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 表示在输出 &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125; 动作中的内容之后，输出 &#123;printf &quot;The end. \n&quot;&#125; 动作中的内容</span><br><span class="line">awk &apos;END&#123;printf &quot;The end. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br></pre></td></tr></table></figure></li><li><p>关系运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取成绩大于 87 的用户名，grep -v Name 的作用是去掉标题行</span><br><span class="line">cat test.txt | grep -v Name | awk &apos;$4 &gt;= 87 &#123;printf $2 &quot;\n&quot;&#125;&apos;</span><br></pre></td></tr></table></figure></li></ol><p>4、sed 命令<br>sed 是一种几乎包括在所有 Unix 平台（包括 Linux）的轻量级<strong>流编辑器</strong>。sed 主要是用来将数据进行选取、替换、删除、新增的命令。</p><p>sed 其实不是截取命令，其实是一个流的编辑器。相当于一个编辑器。既然已经学了 vim，为什么还有学习 sed 呢？因为 vim 命令只能修改文件，不能直接修改命令结果里的内容。要想使用 vim 修改命令的输出，则需要先把输出保存到文件当中，然后再用 vim 修改文件。sed 不光可以修改文件，因为其是一个流编辑器，所以可以从管道符接受数据来进行修改，即 sed 支持管道符操作。实际操作中主要用在对命令的结果进行操作，但是在 shell 编程中，sed 是一个重要的流数据处理编辑器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    sed [选项] &apos;[动作]&apos; 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n  一般 sed 命令会把所有数据都输出到屏幕，如果加入此选项，则只会把经过 sed 命令处理的行输出到屏幕</span><br><span class="line">    -e  允许对输入数据应用多条 sed 命令编辑</span><br><span class="line">    -i  用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出，不光输出的数据会更改，源数据文件也会被更改。</span><br><span class="line"></span><br><span class="line">动作：</span><br><span class="line">    a \:    追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    c \:    行替换，用 c 后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    i \:    插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    d:      删除，删除指定的行</span><br><span class="line">    p:      打印，输出指定的行</span><br><span class="line">    s:      字符串替换，用一个字符串替换另外一个字符串。格式为「行范围/s/就字符串/新字符串/g」</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看文件的第二行，会输出全部内容</span><br><span class="line">    sed &apos;2p&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 只显示经过 sed 命令处理的行</span><br><span class="line">    sed -n &apos;2p&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 针对管道符结果操作</span><br><span class="line">    df -h | sed -n &apos;2p&apos;</span><br><span class="line"></span><br><span class="line">    # 删除第二到第四行的数据，但不修改文件本身</span><br><span class="line">    sed &apos;2,4d&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第二行后追加 hello</span><br><span class="line">    sed &apos;2a hello&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第二行前插入两行数据</span><br><span class="line">    sed &apos;2i hello \</span><br><span class="line">    world&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 数据替换</span><br><span class="line">    sed &apos;2c No such person&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第三行中，把 90 替换成 99</span><br><span class="line">    sed &apos;3s/90/99/g&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # sed 操作的数据直接写入文件</span><br><span class="line">    sed -i &apos;3s/90/99/g&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 同时把 zhangsan 和 lisi 替换为空</span><br><span class="line">    sed -e &apos;s/zhangsan//g;s/lisi//g&apos; test.txt</span><br></pre></td></tr></table></figure><h2 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h2><p>1、排序命令 sort<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    sort [选项] 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -f    忽略大小写</span><br><span class="line">    -n    以数值型进行排序，默认使用字符串型排序</span><br><span class="line">    -r    反向排序</span><br><span class="line">    -t    指定分割符，默认分隔符是制表符</span><br><span class="line">    -k n[,m]    按照指定的字段范围排序。从第 n 字段开始，m 字段结束（默认到行尾）</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 排序用户信息文件</span><br><span class="line">    sort /etc/passwd</span><br><span class="line"></span><br><span class="line">    # 反向排序</span><br><span class="line">    sort -t /etc/passwd</span><br><span class="line"></span><br><span class="line">    # 指定分隔符「:」。用第三字段开头，第三字段结尾排序，就是只用第三字段排序（类比数据库 order by 后面可以跟多个字段）</span><br><span class="line">    sort -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line"></span><br><span class="line">    # -n 表示将提取的字段当成数字来对待</span><br><span class="line">    sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br></pre></td></tr></table></figure></p><h2 id="条件判断（即测试一个条件是否成立）"><a href="#条件判断（即测试一个条件是否成立）" class="headerlink" title="条件判断（即测试一个条件是否成立）"></a>条件判断（即测试一个条件是否成立）</h2><p>1、按照文件类型进行判断（记住蓝色的就行，其它的了解）<br><img src="/upload_image/Judge_File_Type.png" alt="按照文件类型进行条件判断" title="按照文件类型进行条件判断"></p><p>2、两种判断格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式一:</span><br><span class="line">  # 注意该命令执行后没有任何输出，要想知道该命令的输出结果，可以使用 $? 来获取结果，「echo $?」打印结果</span><br><span class="line">  # $? 的作用是判断上一条命令是否正确执行，正确执行返回 0，否则返回其他数字</span><br><span class="line">  test -e /root/install.log</span><br><span class="line"></span><br><span class="line">格式二:</span><br><span class="line">  # 注意两端必须有空格</span><br><span class="line">  [ -e /root/install.log ]</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line">  # 第一个判断命令如果正确执行，则打印 yes，否则打印 no</span><br><span class="line">  [ -d /root ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br></pre></td></tr></table></figure></p><p>这种判断主要用在 Shell 脚本当中，而在脚本当中最常用的判断格式是用中括号。</p><p>3、按照文件权限进行判断<br><img src="/upload_image/Judge_File_Permission.png" alt="按照文件权限进行条件判断" title="按照文件权限进行条件判断"></p><p>注意：以上权限部分不区分所有者、所属组、其他人，只要该文件有这个权限，就为真。</p><p>4、两个文件之间进行比较<br><img src="/upload_image/Two_File_Compare.png" alt="两个文件之间进行比较" title="两个文件之间进行比较"></p><p>5、两个整数之间比较<br><img src="/upload_image/Two_Integer_Compare.png" alt="两个整数之间比较" title="两个整数之间比较"><br>-ne ：  (not equal) 不相等<br>-gt ：  (greater than) 大于<br>-lt ：  (less than) 小于<br>-ge ：  (greater than or equal) 大于或等于<br>-le ：  (less than or equal)小于或等于</p><p>6、字符串的判断<br><img src="/upload_image/Judge_String.png" alt="字符串的判断" title="字符串的判断"><br>注意：== 会把参数当成字符串</p><p>7、多重条件判断<br><img src="/upload_image/Judge_Many_Condition.png" alt="多重条件判断" title="多重条件判断"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(十二) —— Shell 编程 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(十一)</title>
    <link href="yanchongsheng.github.io/2018/10/25/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%8D%81%E4%B8%80)/"/>
    <id>yanchongsheng.github.io/2018/10/25/Linux入门总结(十一)/</id>
    <published>2018-10-25T11:59:38.000Z</published>
    <updated>2018-10-22T11:29:29.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十一) —— Shell 基础 </blockquote><a id="more"></a><h2 id="Shell-概述"><a href="#Shell-概述" class="headerlink" title="Shell 概述"></a>Shell 概述</h2><p>1、Shell 是什么？<br>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统程序，用户可以用 Shell 来启动、挂起、停止甚至编写一些程序。</p><p>Shell 还是一个功能相当强大的编程语言。Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。</p><p>2、Shell 的分类<br>Bourne Shell：从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh。</p><p>C Shell：C Shell 主要在 BSD (Berkeley Software Distribution，是一个操作系统的名称，衍生自 Unix，被称为伯克利 Unix) 版的 Unix 系统中使用，其语法和 C 语言相类似而得名。</p><p>Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh、ksh、Bash、psh、zhs；C 家族主要包括：csh、tcsh。</p><p>Bash (Bourne Again Shell): Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。</p><p>3、Linux 支持的 Shell<br>在 「/etc/shells」文件中保存着当前系统支持的 Shell。注意：只要是系统支持的 Shell，我们就可以通过输入对应的 Shell 名字来进行切换。</p><p>4、echo 输出命令<br>echo 是反射、回声的意思。是用来输出的命令。格式：<code>echo [选项][输出内容]</code>；选项：<code>-e</code>，支持反斜杠控制的字符转换。<br>eg：<code>echo &#39;Hello World!&#39;</code>  注意：感叹号在 Shell 中有特殊的作用，所以这里使用单引号。</p><p>5、Linux 中常见的转义符<br><img src="/upload_image/Escape_Character.png" alt="Linux 中常见的转义符" title="Linux 中常见的转义符"></p><p>eg：<code>echo -e &quot;ab\bc&quot;</code> 删除左侧字符；输出结果：<code>ac</code>；分析：<code>\b</code> 代表的是退格键。<br>eg：<code>echo -e &quot;a\tb\tc\nd\te\tf&quot;</code> 制表符与换行符。<br>eg: <code>echo -e &quot;\e[1;31m abcd \e[0m&quot;</code> 带颜色输出内容；输出结果：<code>红色的 abcd</code>；分析：31m=红色；「\e[1;」表示开启颜色输出，「\e[0m」    表示结束颜色输出。</p><p>6、第一个 Shell 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/Bash</span><br><span class="line"><span class="meta">#</span>The first program</span><br><span class="line"><span class="meta">#</span>Author: YanChongsheng E-mail: yanchongsheng@gmail.com</span><br><span class="line">echo -e "YanChongsheng is the most handsome man in China."</span><br></pre></td></tr></table></figure><p>注意：「#!/bin/Bash」这句话不是注释，而是标称，标称以下内容是 Shell 脚本。在 Linux 中以 # 号开头的是注释。</p><p>7、脚本执行</p><ul><li>方式一：赋予执行权限，直接运行 <code>赋予权限：chmod 755 hello.sh 运行脚本：./hello.sh</code></li><li>方式二：通过 Bash 调用执行脚本：<code>bash hello.sh</code></li></ul><p>注意：使用 base 执行脚本的时候，脚本甚至可以没有执行权限。它的意思是通过这个 Shell 来解释这个 shell 脚本文件，所以只要里面的内容是正确的，连执行权限都可以不用给就可以执行，但是最习惯的执行方法还是第一种。</p><p>cat 命令给其加上选项 -A ：表示查看所有的文件内容，包括隐藏字符，例如回车符就属于文件中的隐藏字符。在 Linux 中，回车符识别为「$」号。但是 Windows 中的回车符是「^M$」，表示这个 shell 是在 windows 中编辑完成的，要想在 Linux 中执行，就需要进行转换，利用命令: dos2unix [文件名]。注意：如果 dos2unix 命令没有则需要安装：<code>yum -y install dos2unix</code>。</p><h2 id="Bash-的基本功能"><a href="#Bash-的基本功能" class="headerlink" title="Bash 的基本功能"></a>Bash 的基本功能</h2><p>1、历史命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：histor [选项][历史命令保存文件]</span><br><span class="line">选项：</span><br><span class="line">    -c  清空历史命令</span><br><span class="line">    -w  把缓存中的历史命令写入历史命令保存文件「~./bash_histor」</span><br></pre></td></tr></table></figure></p><p>注意：每次登陆之后所敲的命令都会放在 history 即内存中，并不会放入 ~/.bash_history 文件，而是等正常退出以后，才会将内存中的历史命令写入到 ~/.bash_history 文件中的。注意：-c 会清除内存中和文件中的所有的历史命令。</p><p>历史命令默认会保存 1000 条，可以在环境变量配置文件「/etc/profile」中进行修改 <code>HISTSIZE=1000</code> 注意：重新登录以后才会生效。如果超过 1000，则删除第 1 条命令，保存第 1001 条命令。</p><p>历史命令的调用：</p><ol><li>使用上、下箭头调用以前的历史命令</li><li>使用「!n」调用第 n 条历史命令</li><li>使用「!!」执行上一条命令</li><li>使用「!字符」执行最后一条以该字符串开头的命令</li></ol><p>2、命令别名：<br>设定命令别名：alias 别名=’原命令’。注意：用命令行方式定义的别名它只会临时生效，一旦系统重启，这个别名就会消失。<br>查询命令别名：alias 别名</p><p>3、命令执行顺序</p><ol><li>第一顺位：执行用绝对路径或相对路径执行的命令。</li><li>第二顺位：执行别名。</li><li>第三顺位：执行 Bash 的内部命令。</li><li>第四顺位：执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令。</li></ol><p>输出环境变量：<code>echo $PATH</code></p><p>让别名永久生效：<code>vim /root/.bashrc</code> 注意：修改的是用户对应家目录下的「./bashrc」文件。rc 可以简单的理解为 user config 的简写，取 user 的最后一个字母 r 和 config 的第一个字母 c 组成 rc。</p><p>删除别名：<code>unalias 别名</code></p><p>4、Bash 常用快捷键<br><img src="/upload_image/Bash_Shortcut_Key.png" alt="Bash 常用快捷键" title="Bash 常用快捷键"></p><p>5、标准输入输出</p><table><thead><tr><th>设备</th><th>设备文件名</th><th>文件描述符</th><th>类型</th></tr></thead><tbody><tr><td>键盘</td><td>/dev/stdin</td><td>0</td><td>标准输入</td></tr><tr><td>显示器</td><td>/dev/stdout</td><td>1</td><td>标准输出</td></tr><tr><td>显示器</td><td>/dev/stderr</td><td>2</td><td>标准错误输出</td></tr></tbody></table><p>6、输出重定向<br><img src="/upload_image/Output_redirect.png" alt="输出重定向" title="输出重定向"></p><p>注意：不是所有的命令都可以使用输出重定向的，这个命令必须得有输出才可以。<br>注意：错误输出中，2 和 大于号之间不能有空格。</p><p><img src="/upload_image/Output_All.png" alt="正确输出和错误输出同时保存" title="正确输出和错误输出同时保存"></p><p>注意：「/dev/null」是 Linux 中的一个特殊文件，可以把它当成垃圾箱，相当于不保存任何输出。</p><p>7、输入重定向「注意：输入重定向了解即可」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：wc [选项][文件名]</span><br><span class="line">选项：</span><br><span class="line">    -c  统计字节数 (byte) print the byte counts</span><br><span class="line">    -m  统计字符数 (character) print the character counts</span><br><span class="line">    -w  统计单词数 (word)</span><br><span class="line">    -l  统计行数 (line)</span><br></pre></td></tr></table></figure></p><p>注意：wc 可以统计键盘输入，输入的行数、单词数、字节数，输入完成之后按 ctrl + d，结束并进行统计。注意回车换行符也会被当成字节进行统计。</p><p>把文件作为命令的输入：<code>命令&lt;文件</code>。eg：<code>wc &lt; anaconda-ks.cfg</code></p><p>8、多命令顺序执行<br><img src="/upload_image/Execute_Many_Command.png" alt="多命令顺序执行" title="多命令顺序执行"></p><p>eg：<code>ls; date; cd /user; pwd</code><br>eg: <code>命令 &amp;&amp; echo yes || echo no</code></p><p><img src="/upload_image/Example_Many_Command.png" alt="例子" title="例子"><br>命令 dd 是磁盘或者说是数据复制的命令，但是它不是 cp，cp 命令只能复制文件，但是 dd 命令能复制特殊文件，也能复制分区甚至整个硬盘，不仅复制分区或硬盘的数据，还复制分区或硬盘的文件系统。dd 主要是用来进行磁盘复制。</p><p>9、管道符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：命令1 | 命令2</span><br></pre></td></tr></table></figure></p><p><code>命令1</code> 的<code>正确输出</code>作为<code>命令2</code> 的<code>操作对象</code>。</p><p>注意：命令1 必须正确输出，否则命令2 不会正常执行。</p><p>10、grep 命令，在文件中搜索符合条件的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：grep [选项] &quot;搜索内容&quot;</span><br><span class="line">选项：</span><br><span class="line">    -i  忽略大小写</span><br><span class="line">    -n  输出行号</span><br><span class="line">    -v  反向查找 (注意：-v 查找的是不匹配的行，即反向查找)</span><br><span class="line">    --color=auto  搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure></p><p>通配符<br><img src="/upload_image/Wildcard.png" alt="通配符" title="通配符"></p><p>Bash 中的特殊符号<br><img src="/upload_image/Special_Character.png" alt="Bash 中的特殊符号" title="Bash 中的特殊符号"></p><p>注意：通配符是用来匹配文件名的，起码在 Linux 系统当中是用来匹配文件名的。</p><p>$ 和 $() 的区别是：$ 是用于调用变量的值；而 $() 是用来引用系统命令。</p><h2 id="Bash-的变量"><a href="#Bash-的变量" class="headerlink" title="Bash 的变量"></a>Bash 的变量</h2><p>1、变量设置规则  </p><ol><li><p>变量名称可以由字母、数字、下划线组成，但是不能以数字开头。</p></li><li><p>在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。</p></li><li><p>变量用等号连接值，<strong>等号左右两侧不能有空格</strong>。</p></li><li><p>变量的值如果有空格，需要使用单引号或双引号包括。</p></li><li><p>在变量的值中，可以使用「\」转义符。</p></li><li><p>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名” 或用 ${变量名} 包含。</p></li><li><p>如果是把命令的结果作为变量值赋值给变量，则需要使用反引号或 $() 包含<strong>命令</strong>。</p></li><li><p>环境变量名建议大写，便于区分。</p></li></ol><p>环境变量名大写，目的是为了区分。因为环境变量会让 Linux 当中所有的 Shell 都能使用，Linux 的系统命令也是在所有的 Shell 中都能使用，但是系统命令都是小写，为了让系统命令和环境变量区分开，建议把环境变量都写成大写。</p><p>2、变量分类</p><ol><li>用户自定义变量</li><li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。</li><li>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</li><li>预定义变量：是 Bash 中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li></ol><p>其实位置参数变量是预定义变量的一种，由于位置参数变量相对来说较多，所以我们习惯上将位置参数变量单独作为一个分类。所以这两种变量的限制是一样的，只能更改值。</p><p>3、本地变量<br>用户自定义变量又称为本地变量。「$变量名」的作用是调用变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 定义变量</span><br><span class="line">aa=123</span><br><span class="line"></span><br><span class="line"># 变量叠加</span><br><span class="line">aa=&quot;$aa&quot;456 # 结果：123456</span><br><span class="line">aa=$&#123;aa&#125;789 # 结果：123456789</span><br><span class="line"></span><br><span class="line"># 变量调用</span><br><span class="line">echo $name</span><br><span class="line"></span><br><span class="line"># 变量查看</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># 变量删除</span><br><span class="line">unset name</span><br></pre></td></tr></table></figure></p><p>set 命令：表示查看系统的所有变量，包括系统的环境变量，以及系统变量，自定义的变量。<br>总结：变量的定义、叠加、调用、查看、删除；变量的概念、变量的规则、变量的分类。</p><p>4、环境变量是什么？<br>用户自定义变量只在当前 Shell 中生效。（使用命令行定义的）环境变量会在当前 Shell 和这个 Shell 的所有子 Shell 当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的 Shell 中生效。</p><p>5、设置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 声明变量</span><br><span class="line">export 变量名=变量值</span><br><span class="line"></span><br><span class="line"># 查询变量</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"># 删除变量</span><br><span class="line">unset 变量名</span><br><span class="line"></span><br><span class="line"># 将已经定义好的本地变量变为环境变量</span><br><span class="line">export 变量名</span><br></pre></td></tr></table></figure></p><p>注意：系统当前本身就是在一个 Shell 里面，我们可以直接输入 csh、或 bash 表示进入对应的 Shell，而系统本身的 shell 就是 csh 或者 bash 的父 Shell，这样就创建了一个子 Shell，当然子 Shell 里面还可以有子子 Shell。</p><p>如何查询和确定 Shell 呢？<br>使用命令 <code>pstree</code>，它的作用是确定进程数。</p><p>6、系统常见环境变量<br>PATH：系统查找命令的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出 PATH</span><br><span class="line">echo $PATH</span><br><span class="line"></span><br><span class="line"># PATH 变量叠加</span><br><span class="line">PATH=&quot;$PATH&quot;:/root/sh</span><br></pre></td></tr></table></figure></p><p>PS1：定义系统提示符的变量</p><p><img src="/upload_image/PS1_Character.png" alt="定义系统提示符" title="定义系统提示符"></p><p>eg：<code>PS1=[\u@\h \W]\$</code>。注意习惯在 $ 最后加一个空格，要不然你的命令会紧挨着提示符 # 或者 $。这种写法只是临时生效。</p><p>注意：env 是专门用来查看当前系统的环境变量的。严格来说 PS1 并不是环境变量，因为 env 命令查看不到，必须使用 set 命令查看。虽然它不是环境变量，但是它是系统预留专门用作定义系统操作环境的一个变量。它是环境变量的一个子分支。</p><p><strong>注意：Linux 以冒号为分割符号。</strong></p><p>7、位置参数</p><p><img src="/upload_image/Location_Param.png" alt="位置参数" title="位置参数"></p><p>位置参数变量最大的作用就是向程序中传递需要的值。它的好处是可以在命令执行的同时接受参数。</p><p>注意：位置参数变量的名称和作用都是固定的。我们能做的只是在里面传入不同的值。</p><p>注意：要想进行数值运算，必须加 $(()) 双小括号括起来，它才能进行数值计算，这是 Linux Shell 的标准格式。</p><p>注意：$# 不会计算命令本身，它计算的仅仅只是参数。</p><p><code>$*</code> 和 $@ 的区别：<code>$*</code> 中的所有参数看成是一个整体。$@ 中的每个参数看成是独立的。</p><p>8、预定义变量<br><img src="/upload_image/Predefined_Variable.png" alt="预定义变量" title="预定义变量"></p><p>其实位置参数变量就是预定义变量当中的一个分类，其特点是不能改变变量名，变量的作用也是固定的。</p><p>$? 用来接收和判断上一条命令是否正确执行。注意：&amp;&amp; || 利用的就是 $? 来判断上一条命令是否正确执行的。</p><p>9、接受键盘输入，read 会把键盘输入的数据赋值给后面的变量中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：read [选项] [变量名]</span><br><span class="line">选项：</span><br><span class="line">    -p &quot;提示信息&quot;：在等待 read 输入时，输出提示信息</span><br><span class="line">    -t 秒数：read 命令会一直等待用户输入，使用此选项可以指定等待时间</span><br><span class="line">    -n 字符数：read 命令只接受指定的字符数，就会执行</span><br><span class="line">    -s：隐藏输入的数据，适用于机密信息的输入</span><br></pre></td></tr></table></figure></p><p>注意：如果不加 -n 选项，read 命令在回车以后才会结束，如果加了 -n 选项，则字符数达到 -n 执行的数字，则自动结束 read 并执行。</p><h2 id="Bash-的运算符"><a href="#Bash-的运算符" class="headerlink" title="Bash 的运算符"></a>Bash 的运算符</h2><p>注意：Linux 的 Shell 中变量的类型默认都是字符串型。</p><p>1、declare 声明变量类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：declare [+/-][选项] 变量名</span><br><span class="line">选项：</span><br><span class="line">    -：给变量设定类型属性</span><br><span class="line">    +：取消变量的类型属性</span><br><span class="line"></span><br><span class="line">    -i：将变量声明为整型（integer）</span><br><span class="line">    -x：将变量声明为环境变量</span><br><span class="line">    -p：显示指定变量的被声明的类型</span><br></pre></td></tr></table></figure></p><p>2、数值运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line"></span><br><span class="line"># 方法1</span><br><span class="line">declare -i cc=$aa+$bb</span><br><span class="line"></span><br><span class="line"># 方法2</span><br><span class="line"># 利用 expr 或 let 数值运算工具。注意：「+」号左右两侧必须有空格。</span><br><span class="line">cc=$(expr $aa + $bb)</span><br><span class="line"></span><br><span class="line"># 方法3</span><br><span class="line"># $((运算式)) 或 $[运算式]</span><br><span class="line">cc=$(($aa+$bb))</span><br><span class="line">cc=$[$aa+$bb]</span><br></pre></td></tr></table></figure></p><p>3、运算符<br><img src="/upload_image/Linux_Operator.png" alt="运算符" title="运算符"></p><p>注意：此处数字越大，优先级越高。</p><p>4、变量测试与内容替换<br><img src="/upload_image/Variable_Alternative_Test.png" alt="变量测试与内容替换" title="变量测试与内容替换"></p><p>主要作用：通过 x 的值来确定 y 的情况。这块内容了解即可，完全可以 if 语句来替代，只是系统提供的更简洁、高效一点，用到的时候查一下能看懂就行，不要可以去记忆。</p><h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><p>1、source 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：source 配置文件</span><br><span class="line">或</span><br><span class="line">格式：. 配置文件</span><br></pre></td></tr></table></figure></p><p>注意：source 命令的作用是让你的配置文件生效，即让系统重新读取一遍配置文件。（正常情况下配置文件生效需要重新登录一次，但是利用 source 命令可以直让配置文件生效）。<br>注意：点「.」和配置文件之间有空格，点「.」其实就是 source 的缩写。</p><p>2、环境变量配置文件简介<br>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如 PATH、HISTSIZE、PS1、HOSTNAME 等默认环境变量。</p><p>系统中主要的 5 类环境变量配置文件：</p><ol><li>/etc/profile 的作用：USER 变量、LOGNAME 变量、MAIL 变量、PATH 变量、HOSTNAME 变量、HISTSIZE 变量、umask、调用 /etc/profile.d/*.sh 文件。</li><li>~/.bash_profile 的作用：调用了 ~/.bashrc 文件、在 PATH 变量后面加入了 「:$HOME/bin」这个目录。</li><li>~/.bashrc 的作用：定义默认别名、调用 /etc/bashrc。</li><li>/etc/bashrc 的作用：PS1 变量、umask、PATH 变量、调用 /etc/profile.d/*.sh 文件。</li><li>/etc/profile.d/*.sh</li></ol><p>注意：只要是保存在 /etc 目录中的，表示对所有登录到该 Linux 系统的用户都生效。~/ 表示当前用户的家目录，「.」表示该文件是隐藏文件，这些配置文件针对的是当前用户。「~」表示家目录的意思。</p><p>3、环境变量配置文件作用</p><p><img src="/upload_image/Profile_Invoke_Order.png" alt="环境变量配置文件调用顺序" title="环境变量配置文件调用顺序"></p><p>注意：环境变量默认赋值的时候分两种情况<br>1.一种是用户通过输入用户名和密码的正常登陆。<br>2.一种是用户通过命令切换到子 Shell 的登陆，这种情况是没有输入用户名密码过程的。<br>这两种不同的登陆方法，它读取的配置文件是不一样的。</p><p>注意：环境变量配置文件它们之间是有优先级的。越后面读取的配置文件，其优先级越高，因为后面定义的变量会覆盖前面的变量。</p><p>需要输入用户名密码的正常登录情况配置文件的读取顺序：<br>/etc/profile「 ——&gt; …… ——&gt; /etc/sysconfig/i18n (新版的 Linux 为 /etc/locale.conf) 这些都是 /etc/profile 文件中调用的子文件或子子文件」当完成 /etc/profile 的所有调用以后 /etc/profile 就会将它的调用传递给下一个环境变量配置文件即 ~./bash_profile，然后照着上图依次往下传递。</p><p>发现 /etc/profile 和 /etc/bashrc 中有很多内容是重复的，如 PATH、umask、PS1，注意这个不是单单只是重复。你会发现 /etc/bashrc 中重复定义变量的地方有这样的注释「We’re not a login shell」即该文件定义的是没有登录情况的 Shell 的环境变量。</p><p>4、注销时生效的环境变量配置文件<br>~/.bash_logout 默认为空，可以在里面写一些退出登录时候的操作，比如清空历史命令等操作。</p><p>5、其他配置文件<br>~/.bash_history 历史命令保存的地方。一般不要清空，但是有一种情况例外，比如你给某个服务设置密码，如 mysql，mysql 设置密码的时候使用的是明文（注意：是明文）系统命令，它会把密码记录在历史文件中，所以要清空明文密码记录。</p><p>6、Shell 登录信息<br>1.<strong>本地</strong>终端欢迎信息：/etc/issue<br><img src="/upload_image/Local_Terminal_Character.png" alt="本地终端转义符" title="本地终端转义符"></p><p>注意：欢迎信息不要写 welcome 之类的，应该写的是警告信息。注意：针对的是本地登录。</p><p>2.<strong>远程</strong> 终端欢迎信息：/etc/issue.net<br>注意：转义符在 /etc/issue.net 文件中不能使用，即本地终端的转义符在这里都不能使用，这里只能写纯文本信息。是否显示此欢迎信息由 ssh 的配置文件 /etc/ssh/sshd_config 决定，加入「Banner /etc/issue.net」行才能显示。（记得重启 ssh 服务）。重启 ssh 服务：<code>service sshd restart</code></p><p>3.<strong>本地和远程</strong>登录后欢迎信息：/etc/motd<br>不管是本地登录，还是远程登录，都可以显示此欢迎信息。但是，它是登录后的欢迎信息。刚才那两个文件是登录前的提示信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(十一) —— Shell 基础 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(十)</title>
    <link href="yanchongsheng.github.io/2018/10/24/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%8D%81)/"/>
    <id>yanchongsheng.github.io/2018/10/24/Linux入门总结(十)/</id>
    <published>2018-10-24T12:23:42.000Z</published>
    <updated>2018-10-24T03:35:51.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十) —— 文件系统管理 </blockquote><a id="more"></a><h2 id="分区和文件系统"><a href="#分区和文件系统" class="headerlink" title="分区和文件系统"></a>分区和文件系统</h2><p>1、分区类型<br><img src="/upload_image/disk_prartition.png" alt="分区类型" title="分区类型"></p><p>2、分区表示方法<br><img src="/upload_image/prartition_show.png" alt="分区表示方法" title="分区表示方法"></p><p>3、分区的设备文件名<br><img src="/upload_image/prartition_device_name.png" alt="分区的设备文件名" title="分区的设备文件名"><br>其中，sd 表示硬盘的接口类型，a 代表第一块硬盘，1、2、3、4 代表 4 个主分区。注意：分区的设备文件名是固定的，我们只需要记下来，能看懂就行。注意：逻辑分区最少从 5 开始，1、2、3、4 这 4 个数字是留给主分区或扩展分区用的。</p><p>4、文件系统<br>了解文件系统 ext、ext1、ext2、ext3、ext4。</p><p><strong>小结：分区的表示方式，采用 /dev 下的 sd 代表 SATA 硬盘接口，hd 代表 IDE 硬盘的接口，a、b、c、d 代表第几块硬盘，1、2、3、4 代表主分区或扩展分区，5、6、7、8、… 代表逻辑分区。</strong></p><h2 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h2><p>1、文件系统查看命令 df<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">    df - report file system disk space usage</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    df [选项] [挂载点]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a  显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs</span><br><span class="line">    -h  使用习惯单位显示容量，如 KB、MB、GB 等</span><br><span class="line">    -T  显示文件系统类型</span><br><span class="line">    -m  以 MB 为单位显示容量</span><br><span class="line">    -k  以 KB 为单位显示容量。默认就是以 KB 为单位</span><br></pre></td></tr></table></figure></p><p>2、统计目录或文件大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">    du - estimate(估计) file space usage</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    du [选项] [目录或文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</span><br><span class="line">    -h 使用习惯单位显示磁盘占用量，如 KB、MB、GB 等</span><br><span class="line">    -s 统计总占用量，而不列出子目录和子文件的占用量</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 统计 /etc/ 目录大小</span><br><span class="line">    du /etc/</span><br><span class="line">    输出结果：它会列出该目录下所有子目录各占用了多大空间，最后统计这个目录的总大小</span><br></pre></td></tr></table></figure></p><p>注意：du 命令是用来统计目录或文件大小的，但是一般不用它来统计文件大小，因为通过「ls -l」命令就可以很清楚的看到文件的大小。<strong>但是 ls 命令在统计目录大小的时候，它只会统计该目录下一级子目录和子文件的文件名占用了多大空间，并不会统计该目录下子目录当中的数据或者文件当中的数据占用了多大空间。</strong> 所以你会看到 ls 命令在显示目录的大小的时候一般就只有几 KB，这也是 ls 命令的局限性所在。要想统计目录的大小就必须使用 du 命令。</p><p>3、du 命令和 df 命令的区别</p><blockquote><p>df 命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）。</p><p>du 命令是面向文件的，只会计算文件后目录占用的空降。</p></blockquote><p>Linux 系统要定期重启，来释放被进程或者已经删除的文件所占用的硬盘空间。要以 df 命令看到的剩余空间才是真正可以使用的空间。</p><p>4、文件系统修复命令 fsck<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    fsck [选项] 分区设备文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a 不用显示用户提示，自动修复文件系统</span><br><span class="line">    -y 自动修复。和 -a 作用一致，不过有些文件系统只支持 -y</span><br></pre></td></tr></table></figure></p><p>系统会自动执行该命令进行修复检测，一般不用该命令，除非真的需要。没事别用，否则有可能会造成系统崩溃。该命令了解即可。</p><p>5、显示磁盘状态命令 dumpe2fs<br><strong>注意：该命令只针对 ext 文件系统有效。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    dumpe2fs 分区设备文件名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    dumpe2fs /dev/sda3 | more</span><br></pre></td></tr></table></figure></p><p>「| more」 分屏显示，即将很多内容，分成多段来显示。主要是用来查看超级块的信息的，可以看到分区中一个数据块的大小。注意：每个数据块中(常见的为 4kb)，只能保存一个文件中的数据。</p><p>在 Centos7 系统下使用 dumpe2fs 查看文件系统查不到对应的超级块，原因是 Centos7 默认安装的文件系统是 XFS 类型而不是 ext2/ext3/ext4。对于 XFS，使用 dumpe2fs 命令是找不到对应的超级块，可以使用 xfs_info 来查看分区信息。<a href="https://wenku.baidu.com/view/3d882d2c0812a21614791711cc7931b765ce7baf.html?re=view" target="_blank" rel="noopener">CentOS 7 查看磁盘状态</a></p><p>小结：du 只统计文件大小，df 不光统计文件大小，还要统计被系统占用的空间。所以用 du 看文件大小更准确，用 df 看剩余空间更准确。</p><p>6、查询与自动挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询系统中已经挂载的设备，-l 会显示卷标名称</span><br><span class="line">mount [-l]</span><br><span class="line"></span><br><span class="line"># 依据配置文件 /etc/fstab 的内容，自动挂载</span><br><span class="line"># 按照配置文件的需求，把所有的分区重新挂载一遍，a 即 all</span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure></p><p>mount 是用来进行设备挂载的命令，Linux 中所有的可存储设备：包括硬盘、光盘、u盘、软盘、移动硬盘等，都必须挂载之后才能使用，只是硬盘的挂载是系统自动进行的，其他的就需要手工挂载了。</p><p>挂载：Linux 中每一个硬件都有一个设备文件名，也会有一个挂载点（空目录），挂载就是把设备文件名和挂载点联系起来。<strong>只有通过访问挂载点，来访问这个设备，即设备是不能直接访问的，得需要通过挂载点才能访问。</strong></p><p>7、挂载命令格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    mount [选项] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -t 文件系统        加入文件系统类型来指定挂载的类型，如 ext3、ext4、iso9660 等文件系统</span><br><span class="line">    -L 卷标名          挂载指定卷标的分区，而不是安装设备文件名挂载。卷标：就相当于给你的分区起一个别名，意义不大，不写也无所谓</span><br><span class="line">    -o 特殊选项        可以指定挂载的额外选项</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 重新挂载 /home 分区，并使用 noexec 权限</span><br><span class="line">    mount -o remount,noexec /home</span><br><span class="line">    # 测试，发现不能执行了</span><br><span class="line">    cd /home &amp;&amp; vim hello.sh &amp;&amp; chmod 755 hello.sh &amp;&amp; ./hello.sh</span><br><span class="line">    # 最后记得改回去，要不会影响系统启动的</span><br><span class="line">    mount -o remount,exec /home</span><br></pre></td></tr></table></figure></p><p>以下为 -o 的特殊选项：<br><img src="/upload_image/mount_o_option.png" alt="-o 的特殊选项" title="-o 的特殊选项"></p><p>注意：mount -o 的这些选项参数，针对的都是分区。-o 后面可以同时跟多个选项，选项之间以逗号分隔。</p><p>7、挂载示例<br>（1）挂载光盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 建立挂载点</span><br><span class="line">mkdir /mnt/cdrom/</span><br><span class="line"></span><br><span class="line"># 挂载光盘</span><br><span class="line">mount -t iso9660 /dev/cdrom/ /mnt/cdrom/</span><br><span class="line">或</span><br><span class="line">mount /dev/sr0 /mnt/cdrom/</span><br></pre></td></tr></table></figure></p><p>只要是<strong>空目录</strong>都可以作为挂载点。注意光盘是只读的。</p><p>（2）卸载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    umount 设备文件名或挂载点</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    umount /mnt/cdrom</span><br></pre></td></tr></table></figure></p><p>用完光盘之后，必须手动卸载，否则光驱不会弹出来。注意：不要在光盘目录下卸载，否则会报设备正忙的错。</p><p>（3）挂载 U 盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看 U 盘设备文件名</span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"># 挂载 U 盘</span><br><span class="line">mount -t vfat /dev/sdb1 /mnt/usb/</span><br></pre></td></tr></table></figure></p><p>注意：Linux 默认是不支持 NTFS 文件系统的。注意：U 盘的设备文件名不是固定的，因为 U 盘跟硬盘采用同样的命名规则，如果系统中只有一块硬盘，U 盘就会识别为 sdb，依次类推，如果系统中已经有两块硬盘，则 U 盘就会识别为 sdc。即它是需要自动识别的，不需要去分配，只要插入，它就会自动去识别。在插入 U 盘的时候，鼠标一定要点到虚拟机里面（VMware 中），否则它就不是 Linux 虚拟机识别 U 盘了，而是 Windows 去识别 U 盘了。Linux 中把 fat16 文件系统识别为 fat，fat32 文件系统识别为 vfat。注意：先卸载再拔出 U 盘。</p><p>8、Linux 挂载 NTFS 文件系统的硬件设备<br>由于 Linux 本身不支持 NTFS 文件系统，所以需要利用第三方软件让 Linux 支持 NTFS 文件系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、下载 NTFS-3G 插件</span><br><span class="line">http://www.tuxera.com/community/ntfs-3g-download/</span><br><span class="line">2、安装 NTFS-3G 插件</span><br><span class="line">解压 &amp;&amp; 进入压缩目录 &amp;&amp; 「./configure」编译器准备。没有指定安装目录，安装到默认位置。 &amp;&amp; 编译 &amp;&amp; 安装</span><br><span class="line">3、插入 NTFS 文件系统的外设</span><br><span class="line">移动硬盘，插入硬盘的时候，鼠标要点进 VMware 虚拟机里面</span><br><span class="line">4、挂载</span><br><span class="line">mount -t ntfs-3g 分区设备文件名 挂载点</span><br></pre></td></tr></table></figure></p><h2 id="fdisk-分区"><a href="#fdisk-分区" class="headerlink" title="fdisk 分区"></a>fdisk 分区</h2><p>Linux 中真正的手工分区命令 fdisk。要掌握如何利用 fdisk 命令给 Linux 新建一个新的分区。</p><p>1、添加新硬盘<br>注意：添加硬盘的时候，必须先断电，否则虚拟机中硬件是无法添加和删除的，真实机也是这样的。</p><p>2、查看新硬盘<br>使用「fdisk -l」命令查询一下新硬盘是否被识别了。该命令最主要的作用就是查询系统当中有多少可以被识别的硬件设备。</p><p>3、使用 fdisk 命令分区<br>fdisk /dev/sdb</p><p><img src="/upload_image/fdisk_manual.png" alt="fdisk 交互指令" title="fdisk 交互指令"><br>主要知道 d、l、m、n、p、q、w 的作用即可。</p><p>4、重新读取分区表信息，使得新添加的分区生效<br>partprobe</p><p>5、格式化分区，注意扩展分区是不能格式化和写入数据的，但是逻辑分区可以<br>mkfs -t ext4 /dev/sdb1</p><p>6、建立挂载点并挂载分区<br>mkdir /disk1 &amp;&amp; mount /dev/sdb1 /disk1/</p><p>注意：使用 fdisk -l 命令只能看到分区是否被正常分配，但是不能知道分区是否被 Linux 挂载，要想知道分区是否被挂载可以使用 mount 或 df 命令。</p><p>7、分区的自动挂载<br>在 Linux 当中，如果使用命令来挂载，一旦重启命令操作的结果就会消失。要想永久生效，就要写入文件。自动挂载归根结底是要写入 /etc/fstab 文件。</p><p><img src="/upload_image/etc_fstab.png" alt="fstab 文件" title="fstab 文件"><br>第一个字段：最好使用 UUID。因为设备文件名有个问题，如果不小心把分区的顺序颠倒了，或者升级了系统内核，或者添加了新的硬盘，这种情况非常容易造成系统崩溃，但是系统是按照原先的顺序进行系统的启动和调用的。UUID 的作用相当于给每个分区起了一个唯一识别号，不管分区顺序如何变，分区的 UUID 号都是不会变的。可以使用「dumpe2fs -h 分区设备文件名」可以查看到分区的 UUID。</p><p>第四个字段：defaults 指分区自动挂载的时候使用默认权限，跟 mount 挂载的时候通过 -o 指定挂载权限是一回事。</p><p>第五个字段：注意这里的自动备份针对的是分区，即目录必须是分区才可以。自动备份到 lost+found 目录下。</p><p>第六个字段：一般我们新添加的分区，不应该等于 1，因为 1 是系统分配的，其优先级本应该最高，所以说我们分配的分区优先级应该比 2 大（数字越大，优先级越低）。注意：/etc/fstab 文件是重要的系统启动文件，修改的时候要特别小心，否则会把系统搞崩溃。</p><p><strong>注意：当修改完 /etc/fstab 文件后不要着急重启，先执行「mount -a」命令，如果 /etc/fstab 文件中有错误，会有提示，不至于重启的时候系统崩溃。</strong> 该命令的作用是根据配置文件 /etc/fstab 的内容，自动挂载。</p><p>如果还是不小心把 /etc/fstab 文件中的内容写错了，是还有修复的机会的。重启系统，输入 root 用户的密码，这时候会进入到系统，但是却发现不能编辑 /etc/fstab 文件，因为分区在报错了之后，挂载的时候挂成了只读权限，所以任何文件都无法修改，这个时候只需要重新把根分区挂载成读写权限就可以了「mount -o remount,rw /」。注意：/etc/fstab 文件修复，只能修复这个文件的报错，但是如果你在这个文件中把根分区 / 写错了，则无法修复，系统会直接崩溃。</p><h2 id="分配-swap-分区"><a href="#分配-swap-分区" class="headerlink" title="分配 swap 分区"></a>分配 swap 分区</h2><p>1、free 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看内存与 swap 分区使用情况，选项 -h 人性化显示大小</span><br><span class="line">free</span><br></pre></td></tr></table></figure></p><blockquote><p>cached(缓存)：是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程。<br>buffer(缓冲)：是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程。</p></blockquote><p>2、添加 swap 分区操作步骤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 1、新建 swap 分区</span><br><span class="line"># 注意：把分区 ID 改为 82</span><br><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line"># 2、格式化，注意分区设备名</span><br><span class="line">mkswap /dev/sdb6</span><br><span class="line"></span><br><span class="line"># 3、加入 swap 分区，注意分区设备名</span><br><span class="line">swapon /dev/sdb6</span><br><span class="line"># 取消 swap 分区</span><br><span class="line">swapoff /dev/sdb6</span><br><span class="line"></span><br><span class="line"># 4、swap 分区开机自动挂载</span><br><span class="line">vim /etc/fstab</span><br><span class="line">写入内容：/dev/sdb6 swap swap defaults 0 0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(十) —— 文件系统管理 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(九)</title>
    <link href="yanchongsheng.github.io/2018/10/23/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B9%9D)/"/>
    <id>yanchongsheng.github.io/2018/10/23/Linux入门总结(九)/</id>
    <published>2018-10-23T13:21:51.000Z</published>
    <updated>2018-11-01T12:54:34.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(九) —— 权限管理 </blockquote><a id="more"></a><h2 id="ACL-权限"><a href="#ACL-权限" class="headerlink" title="ACL 权限"></a>ACL 权限</h2><h3 id="ACL-权限简介与开启"><a href="#ACL-权限简介与开启" class="headerlink" title="ACL 权限简介与开启"></a>ACL 权限简介与开启</h3><p>1、ACL 权限简介<br><img src="/upload_image/acl_introductio.png" alt="ACL 权限简介" title="ACL 权限简介"></p><p>ACL 权限就是专门用作解决身份（u、g、o）不足的问题。它跟 Windows 中的权限很类似，<strong>即 ACL 权限不再管以前存在的身份（u、g、o），而是针对某个用户或者组，添加相应的权限。</strong></p><p>2、查看<strong>分区</strong> ACL 权限是否开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># dumpe2fs 命令是查询指定分区详细文件系统信息的命令</span><br><span class="line"># -h 选项：仅显示超级块中信息，而不显示磁盘块组的详细信息</span><br><span class="line">dumpe2fs -h /dev/sda3</span><br></pre></td></tr></table></figure></p><p>命令：<code>df -h</code> 查看当前系统有哪些分区。df 命令是用来查看分区使用状况的，或者说占用空间容量的，但是它可以看到其对应的分区。/dev/shm 分区是一个假的分区。</p><p>注意：是否支持 ACL 权限，不是文件支持，也不是用户支持，而是文件所在的分区是否支持 ACL 权限。即 ACL 权限本身是用户对这个文件有没有相应的 rwx 权限，但是必须文件所在的分区支持才可以来分配。</p><p><img src="/upload_image/acl_look.png" alt="ACL 权限查看" title="ACL 权限查看"><br>注意查看默认挂载选项 <code>default mount options</code>，可以看到支持 acl。当前的 Linux 当中，所有的分区，默认挂载的时候都已经支持 ACL。</p><p>3、临时开启分区 ACL 权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 重新挂载根分区，并挂载加入 ACL 权限</span><br><span class="line">mount -o remount,acl /</span><br></pre></td></tr></table></figure></p><p>4、永久开启分区 ACL 权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在权限位，一般是 defaults 后面加上 acl，分隔符为逗号，即「defaults,acl」</span><br><span class="line">vim /etc/fstab</span><br><span class="line"></span><br><span class="line"># 重新挂载文件系统或重启系统，使修改生效</span><br><span class="line">mount -o remount</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/etc_fstab_content.png" alt="/etc/fstab" title="/etc/fstab"><br>注意：defaults 表示的是分区自动挂载时候的默认选项，Linux 中默认已经支持 ACL 选项了。如果某个分区不支持，可以直接在 defaults 后面加「,acl」然后保存重启。</p><p><strong>ACL 权限是为了解决 u、g、o 三个身份不足的情况。ACL 权限的开启方法，了解即可，一般默认都开启了。</strong></p><h3 id="查看与设定-ACL-权限"><a href="#查看与设定-ACL-权限" class="headerlink" title="查看与设定 ACL 权限"></a>查看与设定 ACL 权限</h3><p>1、查看 ACL 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getfacl 文件名</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/look_acl_permission.png" alt="查看 ACL 权限" title="查看 ACL 权限"></p><p>注意：用户 shiting 和用户组 tgroup2 并不是 /project 目录的所有者和所属组，但它依然对该目录有相应的权限，这就是 ACL 权限。</p><p>2、设定 ACL 权限的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    setfacl 选项 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -m    设定 ACL 权限</span><br><span class="line">    -x    删除指定的 ACL 权限</span><br><span class="line">    -b    删除所有的 ACL 权限</span><br><span class="line">    -d    设定默认 ACL 权限</span><br><span class="line">    -k    删除默认 ACL 权限</span><br><span class="line">    -R    递归设定 ACL 权限</span><br></pre></td></tr></table></figure></p><p>3、给用户设定 ACL 权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 示例命令</span><br><span class="line">mkdir /project</span><br><span class="line">useradd student1</span><br><span class="line">useradd student2</span><br><span class="line">useradd shiting</span><br><span class="line">groupadd tgroup</span><br><span class="line">gpasswd -a student1 tgroup</span><br><span class="line">gpasswd -a student2 tgroup</span><br><span class="line">chown root:tgroup /project</span><br><span class="line">chmod 770 /project</span><br><span class="line">setfacl -m u:shiting:rx /project</span><br></pre></td></tr></table></figure></p><p>注意：给用户 shiting 赋予 r-x 权限，使用「u:用户名:权限」的格式。注意：权限的后面多了一个「+」号，就表示设置 ACL 权限成功了。要想看具体的 ACL 权限，就要使用前面讲的 getfacl 命令。<br><img src="/upload_image/set_acl_show.png" alt="注意 + 号" title="注意 + 号"></p><p>4、给用户组设定 ACL 权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd tgroup2</span><br><span class="line"># 为组 tgroup2 分配 ACL 权限。使用「g:组名:权限」的格式</span><br><span class="line">setfacl -m g:tgroup2:rwx /project</span><br></pre></td></tr></table></figure></p><h3 id="最大有效权限与删除-ACL-权限"><a href="#最大有效权限与删除-ACL-权限" class="headerlink" title="最大有效权限与删除 ACL 权限"></a>最大有效权限与删除 ACL 权限</h3><p>1、最大有效权限 mask<br>mask 是用来指定最大有效权限的。如果我给用户赋予了 ACL 权限，是需要和 mask 的权限「相与」才能得到用户的真正权限。</p><p><img src="/upload_image/mask_permission.png" alt="mask 权限相与" title="mask 权限相与"></p><p><strong>注意：mask 不会影响所有者的权限，但是会影响 ACL 和所属组的权限。</strong></p><p>2、修改最大有效权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设定 mask 权限为 r-x，使用「m:权限」的格式</span><br><span class="line">setfacl -m m:rx 文件名</span><br></pre></td></tr></table></figure></p><p>3、删除 ACL 权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 删除指定用户的 ACL 权限</span><br><span class="line">setfacl -x u:用户名 文件名</span><br><span class="line"></span><br><span class="line"># 删除指定用户组的 ACL 权限</span><br><span class="line">setfacl -x g:组名 文件名</span><br><span class="line"></span><br><span class="line"># 会删除文件的所有的 ACL 权限，包括 mask</span><br><span class="line">setfacl -b 文件名</span><br></pre></td></tr></table></figure></p><h3 id="默认-ACL-权限和递归-ACL-权限"><a href="#默认-ACL-权限和递归-ACL-权限" class="headerlink" title="默认 ACL 权限和递归 ACL 权限"></a>默认 ACL 权限和递归 ACL 权限</h3><p>1、递归 ACL 权限<br>递归是父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意：-R 的位置不能放到 -m 那里，只能放到如下所示的位置</span><br><span class="line">setfacl -m u:用户名:权限 -R 文件名</span><br></pre></td></tr></table></figure><p>2、默认 ACL 权限<br>默认 ACL 权限的作用是如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 格式：setfacl -m d:u:用户名:权限 文件名</span><br><span class="line"># 加 -R 选项，表示其子目录递归拥有默认权限</span><br><span class="line">setfacl -m d:u:shiting:rx -R /project</span><br></pre></td></tr></table></figure><p>注意：递归权限针对的是目录下的子文件，如果赋予文件 ACL 权限，文件是不可能有子文件的，它会报错。默认权限指的是这个目录当中新出现的文件或者目录遵守 ACL 权限，如果给文件赋予 ACL 权限，它虽然不报错，但是没有作用，因为不能在文件中创建子文件。所以这两个权限都只能赋予目录。</p><h2 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h2><h3 id="SetUID"><a href="#SetUID" class="headerlink" title="SetUID"></a>SetUID</h3><p>1、SetUID 的功能<br>(1) 只有可以执行的二进制程序才能设定 SetUID 权限<br>(2) 命令执行者要对该程序拥有执行权限即 x<br>(3) 命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主）<br>(4) SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效    </p><p>举例：</p><blockquote><p>passwd 命令拥有 SetUID 权限，所以普通用户可以修改自己的密码。<br>cat 命令没有 SetUID 权限，所以普通用户不能查看 /etc/shadow 文件内容。</p></blockquote><p><img src="/upload_image/passwd_file.png" alt="passwd 文件属性" title="passwd 文件属性"><br>注意：上图中出现了「s」，SetUID 指的就是在该文件的所有者权限范围内拥有「s」权限；而 SetGID 指的就是在该文件的所属组权限范围内拥有「s」权限；而 Sticky BIT 指的就是在该文件的其他人权限范围内拥有「s」权限。<strong>它们都是将对应执行权限位的 x 替换为 s。</strong></p><p><img src="/upload_image/setuid_show.png" alt="注意 s 权限" title="注意 s 权限"></p><p>2、设定 SetUID 的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 4 代表 SetUID</span><br><span class="line">方法一：chmod 4755 文件名</span><br><span class="line">方法二：chmod u+s 文件名</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/setuid_example_one.png" alt="设定 SetUID" title="设定 SetUID"></p><p><img src="/upload_image/setuid_example_two.png" alt="大写 S 表示报错" title="大写 S 表示报错"></p><p>注意：出现了大写的 S，跟 chmod 4755 设定出来的小写的 s 效果不一样。大写的 S 其实是报错了，证明这个权限不能运行，因为用户必须对这个文件拥有执行权限，SetUID 才有作用，这个文件的权限原来是 644，在 644 的基础之上加了一个 s，任何人对这个文件都没有执行权限，所以系统用大写的 S 报警，提示用户这种 SetUID 值不能正确执行。</p><p>3、取消 SetUID 的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法一：chmod 755 文件名</span><br><span class="line">方法二：chmod u-s 文件名</span><br></pre></td></tr></table></figure></p><p>4、危险的 SetUID<br>（1）关键目录应严格控制写权限。比如「/」「/usr」等。<br>（2）用户的密码设置要严格遵守密码三原则。<br>（3）对系统中默认应该具有 SetUID 权限的文件做个列表，定时检查有没有列表之外的文件被设置了 SetUID 权限。</p><h3 id="SetGID"><a href="#SetGID" class="headerlink" title="SetGID"></a>SetGID</h3><p>1、SetGID 针对文件的作用<br>(1) 只有可执行的二进制程序才能设置 SetGID 权限<br>(2) 命令执行者要对该程序拥有执行权限即 x<br>(3) 命令执行在执行程序的时候，组身份升级为该程序文件的属组<br>(4) SetGID 权限只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效</p><p><img src="/upload_image/locate_show.png" alt="SetGID 作用效果" title="SetGID 作用效果"><br>举例：<br>locate 文件搜索命令，它跟 find 命令相比，之所以执行速度更快，是因为 locate 命令搜索的是 /var/lib/mlocate/mlocate.db 这个数据库，该数据库中会记录当前系统中所有文件的文件名。会发现该数据的权限是 -rw-r—–，如果普通用户去搜索这个数据库文件按理应该是没有权限的，但是 locate 命令有 SetGID 权限。即普通用户虽然对数据库文件没有权限，但是普通用户是通过 locate 命令去搜索数据库文件的，而 locate 命令是拥有 SetGID 权限的，当任意一个普通用户执行 locate 命令的时候，其身份组就会切换为 locate 命令的组即 slocate，而数据库文件的所属组就是 slocate，并且所属组拥有读权限，所以普通用户利用 locate 命令的 SetGID 权限就可以读取数据库文件了。</p><p>2、SetGID 针对目录的作用<br>(1) 普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录<br>(2) 普通用户在此目录中的有效组会变成此目录的属组<br>(3) 若普通用户对此目录拥有 w 权限时，新建的文件的默认属组是这个目录的属组</p><p><strong>注意：只有 SetGID 可以既针对二进制文件，也可以针对目录。</strong></p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># root 用户执行命令</span><br><span class="line">mkdir /tmp/dtest</span><br><span class="line">chmod 2777 /tmp/dtest</span><br><span class="line"># 切换为普通用户</span><br><span class="line">su - youcai</span><br><span class="line">cd /tmp/dtest/</span><br><span class="line"># 注意：在 /tmp/dtest 目录下新建文件的所属组是 root，即 dtest 目录的所属组，不再是当前用户的缺省组了</span><br><span class="line">touch /tmp/dtest/ftest</span><br></pre></td></tr></table></figure></p><p>注意：对目录设置 SetGID 实际操作意义不大，了解即可。</p><p>3、设定 SetGID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 代表 SetGID</span><br><span class="line">方法一：chmod 2755 文件名</span><br><span class="line">方法二：chmod g+s 文件名</span><br></pre></td></tr></table></figure></p><p>4、取消 SetGID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法一：chmod 755 文件名</span><br><span class="line">方法二：chmod g-s 文件名</span><br></pre></td></tr></table></figure></p><p>系统利用了 SetUID 和 SetGID 这些权限来完成一些必须给普通用户分配权限的工作。</p><h3 id="Sticky-BIT"><a href="#Sticky-BIT" class="headerlink" title="Sticky BIT"></a>Sticky BIT</h3><p>1、Sticky BIT 粘着位作用<br>(1) 粘着位目前只对目录有效。<br>(2) 普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录拥有写入权限。<br>(3) 如果没有粘着位，因为普通用户拥有 w 权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。</p><p>举例：<br><img src="/upload_image/stichy_bit_example.png" alt="/tmp/ 目录属性" title="/tmp/ 目录属性"><br>注意：/tmp/ 目录的其他人权限位中的「t」表示粘着位权限。</p><p>2、设置粘着位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法一：chmod 1755 目录名</span><br><span class="line">方法二：chmod o+t 目录名</span><br></pre></td></tr></table></figure></p><p>3、取消粘着位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法一：chmod 755 目录名</span><br><span class="line">方法二：chmod o-t 目录名</span><br></pre></td></tr></table></figure></p><p><strong>注意：Stichy BIT 针对的是删除的限制，对读和修改没有限制。注意：特殊权限位虽然可以给 7，但是一般不这样做，因为操作的对象不同，有的是目录，有的是文件，所以不可能同时生效，所以这样做是没有意义的。注意：要定时检查系统中赋予 SetUID 和 SetGID 的权限的文件，如果有，要确认是否是多出来的，否则会造成非常大的隐患。</strong></p><p>小结：SetUID 只能针对二进制文件，用 4 表示，权限为字母为 s。SetGID 既可以针对二进制文件，也可以针对目录，用 2 表示，权限为字母为 s。Stichy BIT 只能针对目录，用 1 表示，权限为字母为 t。</p><h2 id="文件系统属性-chattr-权限"><a href="#文件系统属性-chattr-权限" class="headerlink" title="文件系统属性 chattr 权限"></a>文件系统属性 chattr 权限</h2><p>1、chattr 命令格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    change file attributes on a Linux file system（ch「change」 attr「attributes」)</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    # + 增加权限；- 删除权限；= 等于某权限</span><br><span class="line">    chattr [+-=] [选项] 文件或目录名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    i    如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置 i 属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。</span><br><span class="line">    a    如果对文件设置 a 属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除。</span><br></pre></td></tr></table></figure></p><p>注意：i 属性赋予文件，表示该文件是只读的。<strong>chattr 针对 root 用户也生效。要想恢复，则先去掉 i 属性。这也是 chattr 的好处，保护数据内容，而且对 root 用户也有效</strong>。 其实 a 是 append 追加的意思。如果对文件设置了 a 属性，则不能使用 vim 的方式对文件修改，只能使用 echo [内容]  &gt;&gt; [文件]的追加方式进行数据的写入。</p><p>2、查看文件系统属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    lsattr 选项 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a 显示所有文件和目录</span><br><span class="line">    -d 若目标是目录，仅列出目录本身的属性，而不是子文件的</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/lsattr_show.png" alt=""><br>e 属性：代表这个文件是在 ext 文件系统中创建的，e 属性是 ext 文件系统默认的，而且也不能取消。</p><h2 id="系统命令-sudo-权限"><a href="#系统命令-sudo-权限" class="headerlink" title="系统命令 sudo 权限"></a>系统命令 sudo 权限</h2><p>1、sudo 权限</p><blockquote><p>root 把本来只能超级用户执行的命令赋予普通用户执行。<br>sudo 的操作对象是系统命令。</p></blockquote><p>2、sudo 使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过编辑 /etc/sudoers 文件来给普通用户授权</span><br><span class="line"># visudo 命令实际修改的是 /etc/sudoers 文件</span><br><span class="line">visudo 等价于 vim /etc/sudoers</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/authorization_format.png" alt="授权格式" title="授权格式"></p><p>注意：上图中的授权格式中有三个 ALL，这三个 ALL 分别代表的是：</p><blockquote><p>第一个 ALL：它定义的并不是允许哪一个 IP 地址或网络访问我这台本机，而是定义的是允许哪一个用户执行某一条命令在<strong>哪一台计算机上</strong>。即它定义的是执行命令的计算机的 IP 地址或网段。<br>第二个 ALL：表示我可以使用什么身份。可以不写，默认为 ALL，表示把用户当成什么身份来对待。<br>第三个 ALL：代表任意命令。</p></blockquote><p>3、示例：授权 test 用户可以重启服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br><span class="line"># 添加如下内容，注意命令要写绝对路径，可以通过 whereis 查找命令绝对路径</span><br><span class="line">test ALL = /sbin/shutdown -r now</span><br></pre></td></tr></table></figure></p><p>4、示例：普通用户执行 sudo 赋予的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看可用的 sudo 命令</span><br><span class="line">sudo -l</span><br><span class="line"></span><br><span class="line"># 普通用户执行 sudo 赋予的命令</span><br><span class="line">sudo /sbin/shutdown -r now</span><br></pre></td></tr></table></figure></p><p><strong>注意：普通用户是可以使用 vim 的，但是普通用户自己用 vim 的时候是局限在自己的权限范围之内的。如果用 sudo 的方式把 root 用户的 vim 赋给普通用户，那么普通用户在执行 vim 命令的时候他的身份会自动切换成为 root，这是极其危险的。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(九) —— 权限管理 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(八)</title>
    <link href="yanchongsheng.github.io/2018/10/22/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AB)/"/>
    <id>yanchongsheng.github.io/2018/10/22/Linux入门总结(八)/</id>
    <published>2018-10-22T11:45:22.000Z</published>
    <updated>2018-10-30T06:48:28.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(八) —— 用户和用户组管理 </blockquote><a id="more"></a><h2 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h2><h3 id="1、用户信息文件-etc-passwd-详解"><a href="#1、用户信息文件-etc-passwd-详解" class="headerlink" title="1、用户信息文件 /etc/passwd 详解"></a>1、用户信息文件 /etc/passwd 详解</h3><p>在 Linux 中主要是通过用户配置文件来查看和修改用户信息。注意：在操作 passwd 文件的时候备份。可以使用 <code>man 5 passwd</code> 查看配置文件的帮助文档。</p><p><img src="/upload_image/etc_passwd_config.png" alt="/etc/passwd" title="/etc/passwd"></p><blockquote><p>第 1 个字段：用户名称。</p><p>第 2 个字段：密码标志。x 表示这个用户是有密码的。注意 x 是不能省略的，如果省略了，则用户登录的时候，系统是不会去 shadow 文件中去搜索用户的真正密码的，它会认为这个用户压根就没有密码，可以直接登录。没有密码的登录只允许本地登录，不允许远程登录，因为 ssh 协议本身就禁止的。</p><p>第 3 个字段：UID（用户 ID）。注意：系统中默认有很多伪用户，但是这些伪用户不能删，一旦删除系统就会崩溃，因为系统有很多服务会调用这些伪用户。这些伪用户是专门用来给系统当中，启动服务、启动命令的时候来调用的。总之这些用户都是系统用户，这些用户不能登录，其次不能删除。</p><blockquote><p>0:           超级用户，注意系统是通过 UID 为 0 来识别是否为超级管理员的，不是通过用户名是否为 root 识别<br>1-499:       系统用户（伪用户）<br>500-65535:   普通用户    </p></blockquote><p>第 4 个字段：GID（用户初始组 ID）。</p><blockquote><p>初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组。初始组的特点：每一个用户都必须有且仅有一个初始组。初始组不能选，但是可以改，一旦改变，以前的初始组就会被放弃，因为只能有一个初始组存在。<br>附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。</p></blockquote><p>第 5 个字段：用户说明。</p><p>第 6 个字段：家目录。</p><blockquote><p>普通用户：/home/用户名/<br>超级用户：/root/</p></blockquote><p>第 7 个字段：登录之后的 Shell。</p><blockquote><p>Shell 就是 Linux 的命令解释器。在 /etc/passwd 当中，除了标准 Shell 是 /bin/bash 之外，还可以写如 /sbin/nologin。简单来说：就是你在 Linux 中输入一个命令，eg：ll，实际上中间要通过命令解释器将 ll 命令解释成内核可以识别的符号然后传输给内核，内核再作出应答显示在命令操作窗口，这样的一个过程。对命令的解释就是 Shell 来执行的。默认即标准 Shell 是 /bin/bash，Linux 中 Shell 可以有多个，默认为 /bin/bash，理论上可以更改。  </p></blockquote></blockquote><h3 id="2、影子文件-etc-shadow-详解"><a href="#2、影子文件-etc-shadow-详解" class="headerlink" title="2、影子文件 /etc/shadow 详解"></a>2、影子文件 /etc/shadow 详解</h3><p>注意：/etc/shadow 文件的默认权限为 000，该文件很重要，保存了加密以后的用户密码。</p><p><img src="/upload_image/etc_shadow_config.png" alt="/etc/shadow" title="/etc/shadow"></p><blockquote><p>第 1 个字段：用户名。<br>第 2 个字段：加密密码。注意：如果密码位是「!!」或「*」代表没有密码，不能登录。<br>第 3 个字段：密码最后一次修改日期。使用 1970.01.01 作为标准时间，每过一天时间戳加 1。<br>第 4 个字段：两次密码的修改间隔时间（和第 3 字段相比）。<br>第 5 个字段：密码有效期（和第 3 字段相比）。<br>第 6 个字段：密码修改到期前的警告天数（和第 5 字段相比）。<br>第 7 个字段：密码过期后的宽限天数（和第 5 字段相比）。0 代表密码过期后立即失效。-1 则表示密码永远不会失效。<br>第 8 个字段：账号失效时间。要用时间戳表示。不管前面怎么设置，到时间了直接密码失效。<br>第 9 个字段：保留。</p></blockquote><p>时间戳换算方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 把时间戳换算为日期</span><br><span class="line">date -d &quot;1970-01-01 16666 days&quot;</span><br><span class="line"></span><br><span class="line"># 把日期换算为时间戳</span><br><span class="line"># $() 用来引用系统命令，date --date=&quot;2018/10/01&quot; +%s 将指定日期换算成秒（以 1970.01.01 作为标准时间）</span><br><span class="line">echo $(($(date --date=&quot;2018/10/01&quot; +%s)/86400+1))</span><br></pre></td></tr></table></figure></p><h3 id="3、组信息文件-etc-group"><a href="#3、组信息文件-etc-group" class="headerlink" title="3、组信息文件 /etc/group"></a>3、组信息文件 /etc/group</h3><p><img src="/upload_image/etc_group_config.png" alt="/etc/group" title="/etc/group"></p><blockquote><p>第 1 个字段：组名。<br>第 2 个字段：组密码标志。<br>第 3 个字段：GID。<br>第 4 个字段：组中附加用户。</p></blockquote><h3 id="4、组密码文件-etc-gshadow"><a href="#4、组密码文件-etc-gshadow" class="headerlink" title="4、组密码文件 /etc/gshadow"></a>4、组密码文件 /etc/gshadow</h3><p><img src="/upload_image/etc_gshadow_config.png" alt="/etc/gshadow" title="/etc/gshadow"></p><blockquote><p>第 1 个字段：组名。<br>第 2 个字段：组密码。<br>第 3 个字段：组管理员用户名。<br>第 4 个字段：组中附加用户。</p></blockquote><p>组密码的作用：只有管理员可以将用户加入到其他的用户组，但是 root 太忙了，这时候可以给组选一个管理员，给这个组设置一个密码，只要这个管理员知道密码，就可以把其他人拉到这个组里面来。或者把用户从这个组里面删掉。不推荐使用组密码，安全性差。</p><h2 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h2><p>1、用户的家目录</p><blockquote><p>普通用户：/home/用户名/，所有者和所属组都是此用户，权限 700。<br>超级用户：/root，所有者和所属组都是 root 用户，权限是 550。</p></blockquote><p>注意：用户的家目录是添加用户的时候自动生成的，可以在添加的时候不让它自动生成，手动创建，但是所有者、所属组以及权限都需要手动去调整。将普通用户变为超级管理员，修改 /etc/passwd 文件，将用户的 UID 改为 0，但是用户的家目录不会改变成 root，还是原来的家目录，只是它的权限是超级用户的权限了。</p><p>2、用户的邮箱<br>用户邮箱目录：/var/spool/mail/用户名/。注意：/var 目录是 Linux 中可变数据的保存位置。</p><p>3、用户模板目录 /etc/skel/<br>注意：添加一个用户会默认修改 7 个位置的文件，分别是：/etc/passwd/、/etc/shadow/、/etc/group/、/etc/gshadow/、家目录、邮箱目录、用户模板目录。模板文件 /etc/skel 里面有隐藏文件，新添加的用户，系统会默认将里面的文件拷贝到其所在的家目录下的。所以，添加一个用户实际会默认修改 6 个位置的文件，因为模板只是从其里面拷贝用的，不会修改。</p><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="1、用户添加命令-useradd"><a href="#1、用户添加命令-useradd" class="headerlink" title="1、用户添加命令 useradd"></a>1、用户添加命令 useradd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">useradd 命令格式：</span><br><span class="line">    useradd [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -u UID        手工指定用户的 UID 号</span><br><span class="line">    -d 家目录      手工指定用户的家目录</span><br><span class="line">    -c 用户说明    手工指定用户的说明。如果输入的内容之间有空格，要加双引号</span><br><span class="line">    -g 组名        手工指定用户的初始组</span><br><span class="line">    -G 组名        指定用户的附加组。可以同时指定多个附加组，中间以逗号分隔</span><br><span class="line">    -s shell       手工指定用户的登录 Shell。默认是 /bin/shell</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 添加默认用户，注意有 6 个位置的文件会被修改外加 1 个位置的文件被复制</span><br><span class="line">    useradd test</span><br><span class="line"></span><br><span class="line">    # 指定选项添加用户</span><br><span class="line">    useradd -u 666 -d /home/test -c &quot;test add user&quot; -g test -G root,bin -s /bin/bash test</span><br></pre></td></tr></table></figure><p>用户默认值文件：/etc/default/useradd<br><img src="/upload_image/etc_default_useradd.png" alt="/etc/default/useradd" title="/etc/default/useradd"></p><p>用户默认值文件：/etc/login.defs<br><img src="/upload_image/etc_logindefs.png" alt="/etc/login.defs" title="/etc/login.defs"></p><p>注意：密码最小长度为 5 位的那条记录已经不生效了，因为其定义的密码强度过于简单，现在采用的是 PAM 验证生效即默认最少 8 位。</p><h3 id="2、修改用户密码-passwd"><a href="#2、修改用户密码-passwd" class="headerlink" title="2、修改用户密码 passwd"></a>2、修改用户密码 passwd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">passwd 命令格式：</span><br><span class="line">    passwd [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -S       查询用户密码的密码状态。仅 root 用户可用。</span><br><span class="line">    -l       暂时锁定用户。仅 root 用户可用。</span><br><span class="line">    -u       解锁用户。仅 root 用户可用。</span><br><span class="line">    --stdin  可以通过管道符输出的数据作为用户的密码 (stdin 标准输入)。</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看密码状态</span><br><span class="line">    passwd -S test</span><br><span class="line">    输出结果为：  test PS 2018-04-11 0 99999 7 -1 (密码已设置，使用 SHA512 算法。)</span><br><span class="line">    解析输出结果：用户名(test) 密码状态(PS 密码已设置、LK 密码已锁定) 密码设定时间(2018-04-11)</span><br><span class="line">    密码修改间隔时间(0) 密码有效期(99999) 警告时间(7) 密码不失效(-1)</span><br><span class="line"></span><br><span class="line">    # 锁定用户</span><br><span class="line">    passwd -l test</span><br><span class="line">    # 解锁用户</span><br><span class="line">    passwd -u test</span><br><span class="line"></span><br><span class="line">    # 使用字符串作为用户的密码</span><br><span class="line">    # 注意：使用 --stdin 每个用户的密码都是使用明文的方式保存下来的，所以要提醒每个用户登录以后要修改密码</span><br><span class="line">    echo &quot;123&quot; | passwd --stdin test</span><br></pre></td></tr></table></figure><p>passwd 直接回车，表示给当前用户设置密码。 新建的用户如果没有设置密码是不能远程登录的，但是可以在本地无密码登录。普通用户修改密码只能使用 passwd，后面是不能加用户名的，只有超级用户可以。</p><h3 id="3、修改用户信息-usermod"><a href="#3、修改用户信息-usermod" class="headerlink" title="3、修改用户信息 usermod"></a>3、修改用户信息 usermod</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">usermod 即 user modify 修改用户的意思</span><br><span class="line"></span><br><span class="line">命令格式：</span><br><span class="line">    usermod [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -u UID        修改用户的 UID 号</span><br><span class="line">    -c 用户说明    修改用户的说明信息</span><br><span class="line">    -G 组名        修改用户的附加组</span><br><span class="line">    -L            临时锁定用户（Lock）</span><br><span class="line">    -U            解锁用户锁定（Unlock）</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 修改用户说明</span><br><span class="line">    usermod -c &quot;test user&quot; test</span><br><span class="line"></span><br><span class="line">    # 把 test 用户加入 root 组</span><br><span class="line">    usermod -G root test</span><br><span class="line"></span><br><span class="line">    # 锁定解锁用户</span><br><span class="line">    usermod -L test</span><br><span class="line">    usermod -U test</span><br></pre></td></tr></table></figure><h3 id="4、修改用户密码状态-chage"><a href="#4、修改用户密码状态-chage" class="headerlink" title="4、修改用户密码状态 chage"></a>4、修改用户密码状态 chage</h3><p>注意：是 <strong>chage</strong> 不是 cha<strong>n</strong>ge，没有 n 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    chage [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -l         列出用户的详细密码状态</span><br><span class="line">    -d 日期    修改密码最后一次更改日期（shadow 3 字段）</span><br><span class="line">    -m 天数    修改两次密码修改间隔（shadow 4 字段）</span><br><span class="line">    -M 天数    修改密码有效期（shadow 5 字段）</span><br><span class="line">    -W 天数    修改密码过期前警告天数（shadow 6 字段）</span><br><span class="line">    -I 天数    修改密码过期后宽限天数（shadow 7 字段）</span><br><span class="line">    -E 日期    修改账号失效时间（shadow 8 字段）</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 该命令把密码修改日期归 0 了（shadow 3 字段），这样用户一登录就要修改密码。</span><br><span class="line">    # 即用户从来没有修改过密码，即第一次密码时间为 1971-01-01，所以你一登录系统就会要求你更改密码。即把用户的密码修改时间归零。</span><br><span class="line">    chage -d 0 test</span><br></pre></td></tr></table></figure><h3 id="5、删除用户-userdel"><a href="#5、删除用户-userdel" class="headerlink" title="5、删除用户 userdel"></a>5、删除用户 userdel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    userdel [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r 删除用户的同时删除用户家目录</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 手动删除用户</span><br><span class="line">    vim /etc/passwd</span><br><span class="line">    vim /etc/shadow</span><br><span class="line">    vim /etc/group</span><br><span class="line">    vim /etc/gshadow</span><br><span class="line">    rm -rf /var/spool/mail/lamp</span><br><span class="line">    rm -rf /home/用户名</span><br></pre></td></tr></table></figure><p>查看用户 ID：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure></p><p>切换用户身份 su:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    su [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -             选项只使用「-」代表连带用户的环境变量一起切换</span><br><span class="line">    -c 命令       仅执行一次命令，而不切换用户身份</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 切换成 root</span><br><span class="line">    # 命令 env 用来查看用户环境变量（环境变量就是这个用户当前所操作的环境）</span><br><span class="line">    # 注意：su 命令切换的时候中间的减号一定不能省略，而且减号前后都有空格</span><br><span class="line">    # 从普通用户切换超级用户或其他普通用户需要输入密码，从超级用户切换普通用户不需要输入密码</span><br><span class="line">    su - root</span><br><span class="line"></span><br><span class="line">    # 不切换成 root，但是执行 useradd 命令添加 user1 用户</span><br><span class="line">    # 没有切换用户，用 -c 选项表示暂时性的调用 root 身份去执行一条 root 用户才能执行的命令</span><br><span class="line">    su - root -c &quot;useradd user1&quot;</span><br></pre></td></tr></table></figure></p><h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><p>1、添加用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    groupadd [选项] 组名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -g GID   指定组 ID</span><br></pre></td></tr></table></figure></p><p>2、修改用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    groupmod [选项] 组名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -g GID       修改组 ID</span><br><span class="line">    -n 新组名    修改组名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 把组名 group1 修改为 group2</span><br><span class="line">    groupmod -n group2 group1</span><br></pre></td></tr></table></figure></p><p>3、删除用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    groupdel 组名</span><br></pre></td></tr></table></figure></p><p>对于组的删除：如果这个组里面是某个用户的初始组，则这个组不能删。要想删除这个组首先要删除用户。如果某个组里面没有初始用户，附加用户有没有都可以删除，里面的用户会自动被清空。</p><p>4、把用户添加入组或从组中删除用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    gpasswd [选项] 组名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a 用户名   把用户加入组</span><br><span class="line">    -d 用户名   把用户从组中删除</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">    gpasswd -a 用户名 用户组</span><br><span class="line">    gpasswd -d 用户名 用户组</span><br></pre></td></tr></table></figure></p><p>Linux 本地无密码登录方法：将 /etc/passwd/ 文件中对应用户的密码标志位置为空，即去掉 x。然后在本地直接输入用户名就可以登录了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(八) —— 用户和用户组管理 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(七)</title>
    <link href="yanchongsheng.github.io/2018/10/18/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%83)/"/>
    <id>yanchongsheng.github.io/2018/10/18/Linux入门总结(七)/</id>
    <published>2018-10-18T11:44:11.000Z</published>
    <updated>2018-10-21T13:58:58.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(七) —— 软件包管理 </blockquote><a id="more"></a><h2 id="RPM-包管理之-rpm-命令管理"><a href="#RPM-包管理之-rpm-命令管理" class="headerlink" title="RPM 包管理之 rpm 命令管理"></a>RPM 包管理之 rpm 命令管理</h2><p>1、Linux 软件包分类</p><ol><li>源码包 （脚本安装包）</li><li>二进制包（RPM 包、系统默认包）</li></ol><p>Linux 是 C 语言写的，这里指的源码包绝大多数都是 C 语言写的。源码包和二进制包最大的区别就是：源码包是直接开发完的源代码给你，而二进制包它是将经过编译以后的包给你，看不到源代码了。编译的时间会比较慢。在 Centos 中我们把二进制包称为 RPM（red hat package manage）包。</p><p>2、RPM 包命名规则<br><img src="/upload_image/rpm_name_rule.png" alt="RPM 包命名规则" title="RPM 包命名规则"></p><p>15 指的是在这个版本上发布了 15 次。el6.centos 指 rpm 包的这个版本可以在 RHEL6 和 Centos 这两个 Linux 版本上安装。noarch 表示任何硬件平台都可以安装。有的包没有写适合哪个 Linux 平台，则适合所有的 Linux 平台。</p><p>注意区分包名和包全名：</p><blockquote><p>包全名：操作的包是没有安装的软件包时，使用包全名。而且要注意路径。上图的包全名为「httpd-2.2.15-15.el6.centos.1.i686.rpm」。一般是安装和升级的时候使用包全名，因为安装和升级的时候这些包都没有安装，操作的是未安装的包所以使用包全名。<br>包名：操作已经安装的软件包时，使用包名。是搜索 /var/lib/rpm 中的数据库。上图中的包名为「httpd」。一般查询、卸载这些命令操作的对象都是包名。</p></blockquote><p>3、RPM 包依赖性<br><img src="/upload_image/rpm_dependence.png" alt="RPM 包依赖性" title="RPM 包依赖性"></p><p>解决环形依赖：用一条命令把软件包 a、b、c 同时安装，就会解决环形依赖。</p><p>软件包库依赖(即模块依赖)：库依赖有个特征，只要是用「.so.数字」结尾，这种包都是库依赖，这个库依赖的不是单独独立的包，它是某一个软件安装包里面的某一个软件。即只要你找到了这个软件所在的包，然后将其所在的包安装，那么这个软件就会随着包的安装而自动安装，就会解决依赖性问题。通过 www.rpmfind.net 查找某个软件属于哪个依赖包。</p><p>4、RPM 包的安装、升级、卸载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rpm 命令简介：</span><br><span class="line">    命令所在路径：/bin/rpm；作用：RPM 包管理器</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    rpm [选项] [包名/包全名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -i        安装，install</span><br><span class="line">    -v        显示详细信息，verbose</span><br><span class="line">    -h        显示安装进度，hash</span><br><span class="line">    -U        升级，upgrade</span><br><span class="line">    -e        卸载，erase</span><br><span class="line">    --nodeps  不检测依赖性，「no/deps」</span><br><span class="line"></span><br><span class="line"># 安装 RPM 包，注意包全名</span><br><span class="line">rpm -ivh 包全名</span><br><span class="line"></span><br><span class="line"># 升级 RPM 包，注意包全名</span><br><span class="line">rpm -Uvh 包全名</span><br><span class="line"></span><br><span class="line"># 卸载 RPM 包，注意包名</span><br><span class="line">rpm -e 包名</span><br></pre></td></tr></table></figure></p><p>注意：安装和卸载用 yum 更为简单，因为它会自动就解决依赖性。但是查询只能通过 rpm，因为 yum 没有 rpm 查询强大，使用 yum 查不了 rpm 那么多的信息，即 rpm 的查询是一个非常常用的功能，不管是通过 rpm 安装还是 yum 安装都可以通过 rpm 命令的查询方式来进行查询。</p><p>5、RPM 包的查询</p><p>(1)查询包是否安装，-q 查询（query）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -q 包名</span><br><span class="line"></span><br><span class="line"># 查询所有已经安装的 RPM 包</span><br><span class="line">rpm -qa</span><br></pre></td></tr></table></figure></p><p>注意：这里查询是从 Linux 后台系统数据库中取数据，所以不需要路径，任何位置都可以直接执行相应的命令。</p><p>(2)查询软件包详细信息，-i 查询软件包信息（information），-p 查询未安装包信息（package）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询已安装包信息</span><br><span class="line">rpm -qi 包名</span><br><span class="line"></span><br><span class="line"># 查询未安装包信息</span><br><span class="line">rpm -qip 包全名</span><br></pre></td></tr></table></figure></p><p>(3)查询包中文件安装位置，-l 列表（list），-p 查询未安装包信息（package）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询已安装包文件安装位置</span><br><span class="line">rpm -ql 包名</span><br><span class="line"></span><br><span class="line"># 查询未安装包文件安装位置</span><br><span class="line">rpm -qlp 包全名</span><br></pre></td></tr></table></figure></p><p>注意：软件包中文件的安装位置，一个软件包中不止有一个文件，所以使用 list，文件的安装位置（默认安装位置）是固定的，是在生产这个包的时候就已经决定了这个文件装在哪里是合理的，rpm 包可以手动指定安装位置，但是手动指定安装位置会带来一系列的问题，比如：服务管理命令找不到 rpm 的一些功能服务，很多服务其搜索的位置都是默认的，从而会带来一些问题。所以最好采用默认安装位置。  </p><p>(4)查询系统文件属于哪个 RPM 包，-f 指定要查询的系统文件名（file）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf 系统文件名</span><br></pre></td></tr></table></figure></p><p>注意：这个系统文件必须是通过包装出来的，才能通过文件反查包。</p><p>(5)查询软件包的依赖性，-R 查询软件包依赖性（requires），-p 查询未安装包信息（package）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qR 包名</span><br></pre></td></tr></table></figure></p><p>6、RPM 包校验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 选项 -V 作用：校验指定 RPM 包中的文件（verify）</span><br><span class="line">rpm -V 已安装的包名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 如果结果没有任何输出，则表示没有任何改变；只有改变的情况才会有输出</span><br><span class="line">    rpm -V httpd</span><br></pre></td></tr></table></figure></p><p>什么是校验？RPM 包安装之后，先把它的特征记录下来，然后当我需要的时候把现在的文件和原先的文件进行比较，查看文件之间的变化，从而判断现在的文件是否做了修改。我们使用校验是为了判断我们的系统文件是否被人进行了更改。</p><p><img src="/upload_image/rpm_V_show.png" alt="rpm -V" title="rpm -V"><br><img src="/upload_image/rpm_V_introduction.png" alt="解析 rpm -V" title="解析 rpm -V"><br><img src="/upload_image/rpm_V_filetype.png" alt="解析 rpm -V" title="解析 rpm -V"><br><img src="/upload_image/rpm_V_introductions.png" alt="解析 rpm -V" title="解析 rpm -V"></p><p>如上图所示，如果有字母则表示其对应的项做了修改，如果用点表示，则表示其对应项没有修改，c 是标称文件的类型，c 表示 config 即配置文件的意思。</p><p>7、从 RPM 包中提取文件，即从 RPM 包中提取指定的某个或某些文件，主要是用来做修复的，如日常工作中不小心把某个文件给误删除了，这时候可能并不需要重新安装整个包，只需要把对应的文件提取出去并放到相应位置即可修复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm2cpio 包全名 | cpio -idv .文件在包中的绝对路径</span><br><span class="line"></span><br><span class="line"># rpm2cpio 命令的作用：将 rpm 包转换为 cpio 格式的文件</span><br><span class="line"></span><br><span class="line"># cpio 是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件</span><br></pre></td></tr></table></figure></p><p>rpm2cpio，由于 2 的英文发音 two 和 to 很像，所在 Linux 命令中经常用 2 表示从什么到什么的意思，此处表示从 rmp 格式转换为 cpio 格式。所有的 rmp 包都是 rpm 包格式的，只有把它转换成 cpio 格式的，才可以通过 cpio 命令把这个包中指定的文件提取出来。「\」在 Linux 表示一条命令没有输入完换行下面接着来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    cpio 命令</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cpio [选项] &lt; [文件|设备]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -i   copy-in 模式，还原</span><br><span class="line">    -d   还原时自动新建目录</span><br><span class="line">    -v   显示还原过程</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查询 ls 命令属于哪个软件包</span><br><span class="line">    rpm -qf /bin/ls</span><br><span class="line">    # 造成 ls 命令误删假象</span><br><span class="line">    mv /bin/ls /tmp</span><br><span class="line">    # 提取 rpm 包中 ls 命令到当前目录的 /bin/ls 下</span><br><span class="line">    rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls</span><br><span class="line">    # 把 ls 命令复制到 /bin 目录，修复丢失文件</span><br><span class="line">    cp /root/bin/ls /bin/</span><br></pre></td></tr></table></figure><h2 id="RPM-包管理之-yum-在线管理"><a href="#RPM-包管理之-yum-在线管理" class="headerlink" title="RPM 包管理之 yum 在线管理"></a>RPM 包管理之 yum 在线管理</h2><p>注意：yum 是一个命令，管理的是 RPM 包，在红帽系列的 Linux 中认为 yum 是一个售后服务，所以有的是收费的。</p><p>1、IP 地址配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 启动网卡</span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0 将 ONBOOT 的值改为 yes</span><br><span class="line"></span><br><span class="line"># 重启网络服务</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure></p><p>注意：有 IP 和子网掩码就可以在局域网内使用；如果要想访问互联网，Ip、子网掩码、DNS、网关缺一不可。</p><p>2、网络 yum 源<br><img src="/upload_image/yum_base_config.png" alt="网路 yum 源配置格式" title="网路 yum 源配置格式"><br><img src="/upload_image/network_yum_repository.png" alt="网络 yum 源" title="网络 yum 源"><br>在 /etc/yum.repos.d/ 这个目录中，只要是以 .repo 结尾的，都是合法的 yum 源。默认是 Base 生效即网络 yum 源生效。</p><p>3、常用 yum 命令<br>(1) 查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查询对应 yum 源中所有可用软件包列表</span><br><span class="line">yum list</span><br><span class="line"></span><br><span class="line"># 统计对应 yum 源中有多少个软件包</span><br><span class="line">yum list | wc -l</span><br><span class="line"></span><br><span class="line"># 搜索服务器上所有和关键字相关的包</span><br><span class="line">yum search 关键字</span><br></pre></td></tr></table></figure></p><p>注意：前面讲解的包名和包全名，只对 rpm 手工管理命令生效，即其使用范围仅限 rpm 手工管理范围。在 yum 中没有包名和包全名之分，只有包名。</p><p>(2) 安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># install 安装，-y 自动回答 yes</span><br><span class="line">yum -y install 包名</span><br></pre></td></tr></table></figure></p><p>gcc 是 c 语言的编译器，在源码包安装的时候，必须有 gcc 存在，源码包才可以正常安装。</p><p>(3) 升级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># update 升级，-y 自动回答 yes</span><br><span class="line">yum -y update 包名</span><br></pre></td></tr></table></figure></p><p>注意：这个升级命令如果没有指定包名，只写了「yum -y update」，它的意思是升级所有的软件包，包括 Linux 内核都会升级，Linux 内核升级完成之后，是需要在本地做一定的配置，你的内核才可以正常使用，才可以启动，如果你是在远程执行的这条命令，你就会发现你的服务器怎么也开不了机了，永远也无法连接，这个时候，这条命令会导致服务器直接崩溃，所以升级命令慎重使用！！！</p><p>(4) 卸载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># remove 卸载，-y 自动回答 yes</span><br><span class="line">yum -y remove 包名</span><br></pre></td></tr></table></figure></p><p>注意：在使用 yum 卸载的时候，它会自动把依赖这个包的包全部卸载掉，有可能会造成系统崩溃。Linux 安装原则：安装的时候最小化安装，不安装多余软件。使用什么软件就安装什么软件，手工装，尽量不卸载，<strong>尤其是 yum 卸载，尽量不要多用。这个命令不建议使用！！！</strong></p><p>4、yum 软件组管理命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有可用的软件组列表</span><br><span class="line">yum grouplist</span><br><span class="line"></span><br><span class="line"># 安装指定软件组，组名可以由 grouplist 查询出来</span><br><span class="line">yum groupinstall 软件组名</span><br><span class="line"></span><br><span class="line"># 卸载指定软件组</span><br><span class="line">yum groupremove 软件组名</span><br></pre></td></tr></table></figure></p><p>注意：如果软件包组名之间有空格，要用双引号括起来，使用的时候要使用英文组名，中文组名是不会被识别的。</p><p>5、光盘 yum 源搭建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、挂载光盘</span><br><span class="line">mount /dev/cdrom /mnt/cdrom</span><br><span class="line"></span><br><span class="line">2、让网络 yum 源失效，即停用所有的网络 yum 源。取巧办法是将 /etc/yum.repos.d/ 文件夹下所有以 .repo 结尾的网络 yum 源改名</span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br><span class="line">mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak</span><br><span class="line">mv CentOs-Vault.repo CentOs-Vault.repo.bak</span><br><span class="line"></span><br><span class="line">3、修改光盘 yum 源，配置光盘地址，enabled 设置为 1 表示开启光盘 yum 源</span><br><span class="line">vim CentOS-Media.repo</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/media_yum_repo.png" alt="光盘 yum 源配置信息" title="光盘 yum 源配置信息"></p><p>注意：系统在检测是否为有效 yum 源的时候是通过 .repo 这个后缀的，我们为了不打开一个个去修改，即将配置文件中的 yum 源容器的 enabled 全部设置为 0，所以此处选择了修改文件名的方式，这个简单粗暴省力。</p><p>光盘 yum 优点：本地不需要网络，下载更快；缺点：版本不能升级，即版本是固定的，需要连接光盘；注意：file 后面有三个 ///，前两个是固定格式「file://」最后一个代表根目录。对于多余的光盘地址，建议注释掉，虽然不影响使用，但是每次系统都会提示你多余的光盘地址找不的的信息。<strong>注意：指定 baseurl 为自己的光盘挂载地址。</strong></p><p>注意：绝大多 Linux 的配置文件对注释都是有严格要求的，不光 # 前面不能加缩进，有一些配置文件甚至在 # 后面都不能加空格。如下所示：这种缩进的就会报错！！！<br><img src="/upload_image/linux_comment.png" alt="错误注释示例" title="错误注释示例"></p><h2 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h2><p>1、rpm 包和源码包的区别</p><blockquote><p>安装之前的区别：概念上的区别<br>安装之后的区别：安装位置不同</p></blockquote><p>2、RPM 包默认安装位置<br><img src="/upload_image/rpm_default_install_location.png" alt="RPM 包默认安装路径" title="RPM 包默认安装路径"></p><p>3、源码包安装位置<br>源码包的安装位置是要手工指定的，一般是「/usr/local/软件名」。/usr 目录是 Unix 系统资源目录，有一个 local 目录，本地的意思，是系统专门为我们准备安装外来应用的地方。我们在目录下创建一个对应软件名进行安装即可。</p><p>4、安装位置不同带来的影响<br>(1)RPM 包安装的服务可以使用系统服务管理命令（service）来管理，例如 RPM 包安装的 apache 的启动方法是：<code>/etc/rc.d/init.d/httpd start</code> 或 <code>service httpd start</code>。Linux 要想启动一个可执行文件（服务），都应该是利用绝对路径启动的。service 是 red hat 特有的，service 命令会自动的去 /etc/rc.d/init.d/ 下去寻找，找到了就执行，找不到就报错。类似 service 这种系统服务都会去默认的安装目录下去寻找，主要是 rmp 默认安装的位置，所以可以使用，但是源码包不行，只能是绝对路径启动。</p><p>(2)而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：<code>/usr/local/apache2/bin/apachectl start</code>。</p><p>小结：rpm 包和源码包由于安装的位置不同，所以带来了服务的管理方法不同。</p><p>5、源码包安装方法<br>（1）安装准备</p><blockquote><p>安装 C 语言编译器</p></blockquote><p>（2）安装注意事项</p><blockquote><p>源代码保存位置：/usr/local/src<br>软件安装位置：/usr/local<br>如何确定安装过程是否报错？(1) echo $? 查看上条命令执行结果 (2) 安装过程停止，并且出现 error、warning 或 no 的提示</p></blockquote><p>（3）源码包安装过程</p><blockquote><p>下载源码包<br>解压缩下载的源码包<br>进入解压缩目录</p></blockquote><p>（4）进入解压缩以后的安装目录，注意以下两个文件</p><blockquote><p><strong>INSTALL 安装说明，注意名字大写。README  使用说明，注意名字大写。</strong> 在 Linux 当中，任何一个源码包都有 INSTALL、README 类似的文件，碰到陌生的源代码的时候，需要先查看说明，再安装或使用源码包。</p></blockquote><p>（5）软件配置与检查</p><p><img src="/upload_image/source_package_configure.png" alt="软件配置与检查" title="软件配置与检查"></p><blockquote><p>可以使用「./configure –help」查看该源码包可用的配置项的帮助信息，会发现源码包安装会有很多的安装配置选项。此处我们只定义安装的目录为 <code>./configure --prefix=/usr/local/apache2</code>，源码包的安装路径选项在安装的时候是一定要定义的，其他选项可以不定义。configure 配置的意思，即在安装源码包之前，把源代码中需要的配置都先配置好，为随后的检查、编译、安装做好准备。注意：Makefile 文件是要等到 ./configure 这条命令执行之后才会生成，里面包含软件的各种配置，是用来安装软件的。</p></blockquote><p>（6）编译、安装</p><blockquote><p>如果前面都通过的话，则执行命令 make 表示编译，如果没有报错的话，则执行 make install 表示安装。到此源码安装就完成了。至于软件安装完成以后如何启动的问题，可以参看源码包中的 INSTALL 等文档的说明。</p><p>注意：在执行 ./configure 和 make 命令的时候不会向 /usr/local 里面写入任何数据。如果在执行 make 的时候报错，则可以使用 make clean 清空编译的数据，这样可以达到完全清空。make install 才会向真正的目录写入数据。</p></blockquote><p>6、源码包的卸载<br>不需要卸载命令，直接删除安装目录即可。不会遗留任何垃圾文件。</p><p>7、在 Linux 中，如果已经安装了 rpm 包的 httpd，可以再安装源码包的 httpd，因为安装位置不同，所以可以安装，但是没必要同时安装两个相同的软件。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://fukun.org/archives/12131599.html" target="_blank" rel="noopener">Bash 快捷建</a><br><a href="https://blog.csdn.net/yjz_sdau/article/details/52765611" target="_blank" rel="noopener">Linux 上安装源码包</a><br><a href="http://18810098265.iteye.com/blog/2400559" target="_blank" rel="noopener">centos 软件包管理之 rpm 的使用</a><br><a href="https://coderschool.cn/641.html" target="_blank" rel="noopener">Linux 下 /usr 和 /var 的含义和内容</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(七) —— 软件包管理 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端基础(一)</title>
    <link href="yanchongsheng.github.io/2018/10/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
    <id>yanchongsheng.github.io/2018/10/09/前端基础-一/</id>
    <published>2018-10-09T06:45:29.000Z</published>
    <updated>2018-10-09T07:51:02.546Z</updated>
    
    <content type="html"><![CDATA[<p>1、注释</p><ul><li>HTML 的注释方法 <!--注释内容--></li><li>CSS 的注释方法 /<em>注释内容</em>/</li><li>JavaScript 的注释方法 /<em> 多行注释方式 </em>/ //单行注释方式</li></ul><p>2、BFC<br>块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、注释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML 的注释方法 &lt;!--注释内容--&gt;&lt;/li&gt;
&lt;li&gt;CSS 的注释方法 /&lt;em&gt;注释内容&lt;/em&gt;/&lt;/li&gt;
&lt;li&gt;JavaScript 的注释方法 /&lt;em&gt; 多行注释方式 &lt;/em&gt;/ //单行注释方式&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(六)</title>
    <link href="yanchongsheng.github.io/2018/09/25/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AD)/"/>
    <id>yanchongsheng.github.io/2018/09/25/Linux入门总结(六)/</id>
    <published>2018-09-25T13:45:15.000Z</published>
    <updated>2018-10-18T12:31:55.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(六) —— Vim 编辑器 </blockquote><a id="more"></a><h2 id="Vim-简介"><a href="#Vim-简介" class="headerlink" title="Vim 简介"></a>Vim 简介</h2><hr><p>Vim 在早期的 Linux 版本中又叫 Vi（visual interface），Vim 是 Vi 的升级版。Vim 是一个功能强大的全屏幕文本编辑器，是 Linux/Unix 上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。<strong>Vim 没有菜单，只有命令。</strong></p><p>Vim 有三种工作模式。可以使用 vim 加上任何一个已经存在或者你想创建的文件名就可以进入 Vim 默认的命令模式。vi 和 vim 都是命令，两个的效果一模一样，一个是早期的，一个是 Vi 的增强版（全名 Vi improved 简称 Vim） 。Vim 命令默认进入的是命令模式，在该模式下，你敲的任何一个字符系统都会当成命令来处理。要想进入文本的插入模式，你需要输入插入命令，比较常用的有 i、a、o 就会进入到插入模式，要想退出插入模式，则可以使用 Esc 键，表示退出插入模式，但是此时进入到的是命令模式，此时你输入的任何内容都会被当成命令。在命令模式里面按「：」冒号就会进入到编辑模式，此时输入的就是编辑模式的命令了，即你输入的内容都会被当成是编辑模式的命令。比如设置行号命令：set number（简写：set nu）。编辑模式的命令执行完成以后它会自动的回到命令模式，所以冒号后面输入的内容才是编辑模式的命令。保存退出命令模式：「:wq」。</p><p><img src="/upload_image/Vim_Model.png" alt="Vim 工作模式" title="Vim 工作模式"></p><h2 id="命令模式和编辑模式常用命令"><a href="#命令模式和编辑模式常用命令" class="headerlink" title="命令模式和编辑模式常用命令"></a>命令模式和编辑模式常用命令</h2><hr><p><img src="/upload_image/Insert_Command.png" alt="插入命令" title="插入命令"><br>注意：在使用小 a 的时候光标会自动往后跳一格，例如：we 光标现在在 w 上，按 a 以后光标自动跳到 e 上，然后在 e 的前面插入，实际上就是在 w 的后面插入。</p><p><img src="/upload_image/Position_Command.png" alt="定位命令" title="定位命令"><br>注意：上图中前面有冒号的表示编辑模式命令，没有冒号的表示命令模式命令。</p><p><img src="/upload_image/Delete_Command.png" alt="删除命令" title="删除命令"></p><p><img src="/upload_image/Copy_Move_Command.png" alt="复制和剪切命令" title="复制和剪切命令"></p><p><img src="/upload_image/Replace_Cancel_Command.png" alt="替换和取消命令" title="替换和取消命令"></p><p><img src="/upload_image/Explore_Replace_Command.png" alt="搜索和搜索替换命令" title="搜索和搜索替换命令"><br>Linux 中的查找是严格区分大小写的，但是可以使用「:set ic」(注意冒号)设置不区分大小写；可以使用「:set noic」(注意冒号)设置区分大小写。「:%s 表示全局替换」「g 表示替换的时候不询问」「c 表示替换的时候要询问」</p><p><img src="/upload_image/Save_Exit_Command.png" alt="保存和退出命令" title="保存和退出命令"></p><p>其他 Vim 常用操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">J          // 合并光标所在行及下一行为一行(在命令模式下)</span><br><span class="line">U          // 撤销对当前行的所有操作</span><br><span class="line">/string    // 向光标下搜索 string 字符串</span><br><span class="line">?string    // 向光标上搜索 string 字符串</span><br><span class="line">N          // 向上搜索前一个搜索动作</span><br><span class="line">yw         // 复制从光标开始到词尾的字符</span><br><span class="line">nyw        // 复制从光标开始的 n 个单词</span><br><span class="line">y^         // 复制从光标到行首的内容</span><br><span class="line">y$         // 复制从光标到行尾的内容</span><br><span class="line">f          // 在当前行查找字符，fx 找到光标后第一个为 x 的字符，3fd 找到第三个为 d 的字符</span><br><span class="line">F          // 同 f 反向查找</span><br><span class="line">:!命令     // 执行外部命令</span><br><span class="line"></span><br><span class="line"># 命令模式下移动光标</span><br><span class="line">h 向左、j 向下 、k 向上、l 向右</span><br><span class="line">空格键向右、Backspace 向左、Enter 移动到下一行首、- 移动到上一行首</span><br></pre></td></tr></table></figure></p><p><strong>总结：以下为 vim 必须掌握的常用命令：dd 剪切当前行，ndd 剪切当前行以下 n 行；x 删除光标所在处字符；yy 复制当前行，nyy 复制当前行以下 n 行；小写 p 粘贴在当前光标所在行的行下，大写 P 粘贴到行上；R 从光标所在处开始替换字符，按 Esc 结束；u 取消上一步操作！Ctrl+r 反向撤销；ZZ 保存退出的快捷键；当如果不知道自己处在什么模式时可以按 2 次 Esc 键即可回到命令模式。</strong></p><h2 id="Vim-使用技巧"><a href="#Vim-使用技巧" class="headerlink" title="Vim 使用技巧"></a>Vim 使用技巧</h2><hr><p>「:r 文件名」可以导入一个文件的内容到当前 vim 编辑的文件之中。eg：「:r /etc/issue」导入的位置为刚才你光标所在的位置。</p><p>「:!命令」可以在不退出 vim 的情况下，执行系统响应的操作命令。eg：「:!which ls」</p><p>「:r!命令」将一个命令的执行结果导入到当前的 vim 文件里面。eg：「:r!date」</p><p>自定义快捷键「:map 快捷键 触发命令」。eg：「:map ^p I#<esc>」^p 表示 ctrl + p 的快捷键，该快捷键代表的命令是：跳到行首并进入插入模式，插入 # 号，然后退出。eg：「:map ^b 0x」表示用快捷键 ctrl + b 表示删除行首字母。<strong>^ 表示 ctrl 的意思，如：^c 就表示 ctrl + c。</strong></esc></p><p><strong>注意：设置快捷键的方式是，使用 ctrl + v + 所需字母；或者先按 ctrl + v，再按 ctrl + 所需字母，效果是一样的。这种是构造 ctrl + 字母的快捷键的方法。</strong></p><p>连续行注释：「n1,n2s/^/#/g」表示从 n1 行开始到 n2 行，每行的行首都增加 # 号，并且替换的时候不询问。  去掉连续行注释：「n1,n2s/^#//g」表示从 n1 行开始到 n2 行，每行的行首的 # 号都替换为空，并且替换的时候不询问。  如果注释符是「//」则需要转义：「:n1,n2s/^/\/\//g」表示从 n1 行开始到 n2 行，每行的行首都增加 // 号，并且替换的时候不询问。注意：「^」表示行首的意思。注意：在 Linux 中「\/」中「\」表示转义符的意思「/」它才是真正的符号。</p><p>替换命令：「:ab 旧内容 新内容」即「:ab a b」这个命令可以简单的理解为：当你输入 a，它会自动的帮你转换成 b。eg: 「:ab sb hello」 当前输入 sb 的时候，会自动的替换成 hello。</p><p>注意：以上定义的快捷键重启以后都不存在，要想永久生效，你需要将其定义在每个用户的宿主（家）目录中的配置文件里面。以 root 为例：vi /root/.vimrc (注意这个配置文件叫 .vimrc)这里面只能放一些<strong>编辑模式</strong>的命令，比如：设置行号、设置快捷键、ab 命令（前面可以没有冒号「:」）。</p><p>/root/.vimrc 文件中自定义永久有效的快捷键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vim 自动设置行号</span><br><span class="line">set nu</span><br><span class="line"></span><br><span class="line"># ctrl + p 表示 I#&lt;Esc&gt;</span><br><span class="line">map ^p I#&lt;Esc&gt;</span><br><span class="line"></span><br><span class="line"># 设置 ab 命令</span><br><span class="line">ab sb hello</span><br></pre></td></tr></table></figure></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://www.jianshu.com/p/6aa2e0e39f99" target="_blank" rel="noopener">Vim速查表</a><br><a href="http://www.pchou.info/linux/2016/11/10/vim-skill.html" target="_blank" rel="noopener">vim 使用技巧</a><br><a href="https://zhinan.sogou.com/guide/detail/?id=316512949354&amp;utm_source=wechat_search&amp;utm_medium=organic" target="_blank" rel="noopener">Vim 的使用方法</a><br><a href="https://mp.weixin.qq.com/s/PxLzWlzqhhNrFMlm0hg2_A" target="_blank" rel="noopener">增强 Vim 编辑器</a><br><a href="https://mp.weixin.qq.com/s/k9PBlG5D6ylzTXfrj2ZI6g" target="_blank" rel="noopener">Vim 命令、操作、快捷键全集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(六) —— Vim 编辑器 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="yanchongsheng.github.io/2018/09/21/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>yanchongsheng.github.io/2018/09/21/工厂模式/</id>
    <published>2018-09-21T07:45:07.000Z</published>
    <updated>2018-09-21T11:10:57.172Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"> 工厂模式 </blockquote></p><p>&lt;! – more –&gt;</p><p>1、工厂模式（Factory Pattern），属于创建型模式，它提供了一种创建对象的最佳方式。<strong>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象</strong>。即告诉对象工厂我需要一个什么样的对象，然后就可以坐等对象工厂返回你需要的对象了。</p><p>2、简单工厂模式<br>到底要实例化哪个类，将来会不会增加实例化对象的种类，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>[大话设计模式]<br>[菜鸟教程]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt; 工厂模式 &lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;! – more –&amp;gt;&lt;/p&gt;
&lt;p&gt;1、工厂模式（Factory Pattern），属于创建型模式，它提供了一种创建对象的最佳方
      
    
    </summary>
    
      <category term="设计模式" scheme="yanchongsheng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="yanchongsheng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>推荐阅读</title>
    <link href="yanchongsheng.github.io/2018/09/20/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/"/>
    <id>yanchongsheng.github.io/2018/09/20/推荐阅读/</id>
    <published>2018-09-20T08:41:53.000Z</published>
    <updated>2018-09-20T08:52:09.530Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 记录在工作学习个人认为优秀的博客 </blockquote><a id="more"></a><p>1、<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a></p><p>2、<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></p><p>3、<a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux 命令大全</a></p><p>4、<a href="https://coolshell.cn/" target="_blank" rel="noopener">左耳朵耗子</a></p><p>5、<a href="https://legacy.gitbook.com/explore?lang=zh" target="_blank" rel="noopener">GitBook</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 记录在工作学习个人认为优秀的博客 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人思考" scheme="yanchongsheng.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
    
      <category term="个人思考" scheme="yanchongsheng.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(六)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AD)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Java入门总结(六)/</id>
    <published>2018-09-19T11:45:19.000Z</published>
    <updated>2018-09-20T03:18:47.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(六) —— 剖析日期和时间 </blockquote><a id="more"></a><p>1、关于时区<br>英国格林尼治是 0 时区，北京是东八区，也就是说格林尼治凌晨 1 点，北京是早上 9 点。0 时区的时间也称为 GMT+0 时间，GMT 是格林尼治标准时间，北京的时间就是 GMT+8:00。</p><p>2、时刻和 Epoch Time(纪元时)<br>所有计算机系统内部都用一个整数表示时刻，这个整数是距离格林尼治标准时间 1970年1月1日0时0分0秒 的毫秒数。格林尼治标准时间 1970年1月1日0时0分0秒 也被称为 Epoch Time (纪元时)。这个整数表示的是一个时刻，与时区无关，世界上各个地方都是同一个时刻。而对于 1970 年以前的时间则使用负数表示。</p><p>3、年历<br>公历和农历都是年历。年历就是对一年有多少月，每月有多少天，甚至一天有多少小时的规则定义。</p><p>时刻是一个绝对时间，对时刻的解读，如年月日周时分秒等，则是相对的，与年历和时区相关。</p><p>Date：表示时刻，即绝对时间，与年月日无关。</p><p>Calendar：表示年历，Calendar 是一个抽象类，其中表示公历的子类是 GregorianCalendar。</p><p>DateFormat：表示格式化，能够将日期和时间与字符串进行相互转换，DateFormat 也是一个抽象类，其中最常用的子类是 SimpleDateFormat。</p><p>TimeZone: 表示时区。Locale: 表示国家和语言。</p><p>4、Date 表示时刻，内部主要是一个 long 类型的值 <code>private transient long fastTime;</code> 几乎所有的未过时的方法都是对该值进行操作的。</p><p>5、Calendar 类是日期和时间操作中的主要类，它表示与 TimeZone 和 Locale 相关的日历信息，可以进行各种相关的运算。</p><p>Calendar.MONTH：表示月，一月份是 0。Calendar.DAY_OF_MONTH：表示日，每月的第一天是 1。Calendar.DAY_OF_WEEK：表示星期几，周日是 1，周一是 2，周六是 7。</p><p>内部，Calendar 会将表示时刻的毫秒数，按照 TimeZone 和 Locale 对应的年历，计算各个日历字段的值，存放在 fields 数组中，Calendar.get 方法获取的就是 fields 数组中对应字段的值。</p><p>内部，根据字段设置或修改时间时，Calendar 会更新 fields 数组对应字段的值，但一般不会立即更新其他相关字段或内部的毫秒数的值，不过在获取时间或字段值的时候，Calendar 会重新计算并更新相关字段。</p><p>6、DateFormat 类主要在 Date 和字符串表示之间进行相互转换。</p><p>7、DateFormat/SimpleDateFormat 不是线程安全的，因为 DateFormat 内部使用了一个 Calendar 实例对象，多线程同时调用的时候，这个 Calendar 实例的状态可能就会紊乱。</p><p>8、总结：Date 表示时刻，与年月日无关，Calendar 表示日历，与时区和 Locale 相关，可进行各种运算，是日期时间操作的主要类，DateFormat/SimpleDateFormat 在 Date 和字符串之间进行相互转换。</p><p>9、Joda 的主要工作都是在毫秒和年月日等年历信息之间进行相互转换。</p><p>10、Joda-Time 中的主要类都被设计为了不可变类，不可变类有一个很大的优点，那就是简单、线程安全，所有看似的修改操作都是通过创建新对象来实现的。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5774483.html" target="_blank" rel="noopener">Java编程的逻辑 —— 剖析日期和时间</a><br><a href="http://www.cnblogs.com/swiftma/p/5794390.html" target="_blank" rel="noopener">Java编程的逻辑 —— Joda-Time</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(六) —— 剖析日期和时间 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(七)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%83)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Java入门总结(七)/</id>
    <published>2018-09-19T11:45:19.000Z</published>
    <updated>2018-09-21T07:27:59.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(七) —— 随机 </blockquote><a id="more"></a><p>1、Random 类的构造方法可以接受一个 long 类型的种子参数。种子决定了随机产生的序列，种子相同，产生的随机数序列就是相同的。</p><p>2、为什么要指定种子？指定种子是为了实现可重复的随机。</p><p>3、Random 产生的随机数不是真正的随机数，相反，它产生的随机数一般称之为伪随机数，真正的随机数比较难以产生，计算机程序中的随机数一般都是伪随机数。</p><p>4、伪随机数都是基于一个种子数的，然后每需要一个随机数，都是对当前种子进行一些数学运算，得到一个数，基于这个数得到需要的随机数和新的种子。</p><p>5、Random 类是线程安全的，也就是说，多个线程可以同时使用一个 Random 实例对象，不过，如果并发性很高，会产生竞争，这时，可以考虑使用多线程库中的 ThreadLocalRandom 类。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5808954.html" target="_blank" rel="noopener">Java编程的逻辑 —— 随机</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(七) —— 随机 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(五)</title>
    <link href="yanchongsheng.github.io/2018/09/19/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%94)/"/>
    <id>yanchongsheng.github.io/2018/09/19/Linux入门总结(五)/</id>
    <published>2018-09-19T06:36:12.000Z</published>
    <updated>2018-10-18T02:40:02.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(五) —— Linux 常用命令 </blockquote><a id="more"></a><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>1、帮助命令 man<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 manual；命令所在路径：/usr/bin/man；作用：获得帮助信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    man [命令或配置文件]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看命令的帮助信息</span><br><span class="line">    man ls</span><br><span class="line"></span><br><span class="line">    # 查看配置文件的帮助信息</span><br><span class="line">    man services</span><br></pre></td></tr></table></figure></p><p>manual 英文意思手册，指南；使用 man 命令相当于调用了一个 less 的浏览方式。</p><p>如何看命令的帮助信息？1、知道命令是干什么用的，通过查看帮助信息的第一行即 NAME 行。2、知道命令的选项是干什么用的，通过「/+关键字」的方式可以快速定位到你要找的内容，通过 n 键向下继续查找。</p><p>如何查看配置文件的帮助信息？1、这个配置文件是干什么用的，通过查看帮助信息的第一行即 NAME 行；2、这个配置文件的格式是什么样的，在 Linux 中任何配置文件都是有规律的，即格式，可以在配置文件的帮助文档中查看到。</p><p>注意在使用 man 来查看配置文件帮助的时候，不可以写成「man + 配置文件绝对路径」！！！此时你得到的并不是帮助信息，而是配置文件的内容。查看配置文件帮助的时候只要使用「man + 配置文件名称」即可。通过查看第一行即 NAME 行，它会告诉你这个配置文件是一个什么样的文件。</p><p>man 命令的帮助类型：「1」表示命令的帮助，「5」表示配置文件的帮助。eg：如 passwd 既对应一个命令又对应一个配置文件，使用 man 会优先显示命令的帮助。要想查看配置文件的帮助，则 <code>man 5 passwd</code> 加一个数字 5 声明你要查看配置文件的帮助。</p><p>执行指令 man services 等查看配置文件帮助文档的时候出现「没有 services 的手册页条目」。解决办法：安装 man 帮助文档包。指令为：<code>yum install man-pages</code>。</p><p>「whatis + 命令名称」它可以直接读取到这个命令 NAME 部分的信息。</p><p>「apropos + 配置文件的名称」只想查看一个配置文件的简短信息。</p><p><code>命令 --help</code> 只想查看命令的选项，不想看到其他的描述语言。</p><p>命令 info 即 infomation，也可以获得帮助信息，其作用跟 man 大同小异，只是在帮助信息的显示有所差别，包括方式上支持一些跳转。</p><p>2、帮助命令 help<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：Shell 内置命令；作用：获得 Shell 内置命令的帮助信息</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看 umask 命令的帮助信息</span><br><span class="line">    help umask</span><br></pre></td></tr></table></figure></p><p>Shell 其实就是一个命令解释器，找不到命令所在路径的命令都是 Shell 内置命令，eg：cd、umask。这些命令不能使用 man 来查看帮助，它会列出 Shell 所有的帮助信息。可以使用 help 来获取 Shell 内置命令的帮助信息。</p><p>3、Linux 中的命令大致可分为两类，内部命令和外部命令。内部命令：也称 Shell 内嵌命令；外部命令：存放在一个文件中，使用时需要去文件中查找，这些文件被定义在 $PATH 中。<strong>type 命令可以查看命令类型，以区别是内部命令还是外部命令，格式 <code>type 命令名称</code>。</strong></p><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><p>1、用户管理命令 useradd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/sbin/useradd；作用：添加新用户</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    useradd 用户名</span><br></pre></td></tr></table></figure></p><p>useradd 命令只有 root 用户可以使用。</p><p>useradd 命令在添加的时候只是添加了用户的基本信息，例如家目录、相关的命令解释器的分配等，并没有给它设置一个验证密码。</p><p>2、用户管理命令 passwd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/passwd；作用：设置用户密码</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    passwd 用户名</span><br></pre></td></tr></table></figure></p><p>注意：更改密码的时候只有管理员可以随意更改密码，普通用户必须要满足密码原则才可以更改密码成功。每个普通用户只能用 passwd 更改自己的密码，而管理员 root 可以用 passwd 更改任何人的密码。</p><p>3、用户管理命令 who<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/who；作用：查看登录用户信息</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/Command_who_show.png" alt="who 命令显示内容" title="who 命令显示内容"><br>who 命令显示内容解释：登录用户名（一个用户可以多次登录）、登录的终端（tty 表示本地终端，即在 Linux 机器本身上登录，tty 又叫本地登录）（pts 表示远程终端，即远程登录）、登录时间、括号里的内容是登录的主机的 IP 地址，如果没有写就表示本机登录。</p><p>4、用户管理命令 w<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/w；作用：查看登录用户详细信息</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/Command_w_show.png" alt="w 命令显示内容" title="w 命令显示内容"></p><p>w 命令的第一行信息解释：当前系统时间、系统连续运行多久、当前一共有几个用户登录、负载均衡指数（这个指数有 3 个数值，分别记录了过去的 1 分钟、5 分钟和 15 分钟，系统的一个负载情况，一般来讲系统的负载值主要指的就是 cup 和内存的负载情况）。IDLE 表示该用户登录过来已经空闲多久了；PCPU 指的是该用户当前登录过来执行的操作占用的 cpu 的时间（下面的数字指的是当前执行的命令占用的 cpu 时间，因为进程在执行的时候是排队依次执行，每个进程在一个 cpu 循环周期里面会分配一定的 cpu 时间，如果一个进程在 cpu 循环周期里多次，它就会占用多个 cpu 时间）；WHAT 指的是他当前执行了什么操作；JCPU 累计占用的 cpu 时间。</p><h2 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h2><p>1、压缩命令 gzip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/gzip；作用：压缩文件；压缩后文件格式：.gz</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    gzip [文件]</span><br></pre></td></tr></table></figure></p><p>解压命令 gunzip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/gunzip；作用：解压缩 .gz 的压缩文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    gunzip [选项] 压缩文件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -S    指定后缀以取代 .gz，suffix</span><br></pre></td></tr></table></figure></p><p><img src="/upload_image/gzip_gunzip.png" alt="gzip&amp;gunzip" title="gzip&amp;gunzip"></p><p>注意：gzip 只能压缩文件，不能压缩目录。而且使用 gzip 压缩是不保留源文件的，使用 gunzip 解压缩也是不保留源文件的。解压缩命令：gunzip（即在 gzip 压缩命令中间加入 un）或者使用 gzip -d 命令，两种命令的效果是一样的。gzip 的压缩比约为 5:1。</p><p>2、压缩解压命令 tar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/tar；作用：打包目录；压缩后文件格式：.tar.gz</span><br><span class="line"></span><br><span class="line">格式：tar [选项] [压缩后文件名] [文件或目录]    </span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c  打包，create</span><br><span class="line">    -x  解包，extract</span><br><span class="line">    -v  显示详细信息，verbose</span><br><span class="line">    -f  指定文件名，file</span><br><span class="line">    -z  打包的同时用 gzip 或 gunzip 压缩或解压</span><br></pre></td></tr></table></figure></p><p>tar 本身的意思是打包，它可以把一个目录打包成一个文件，同时也可以在打包的同时做一个压缩。tar -cvzf 的压缩比约为 5:1。<strong>使用此组命令会保留源文件。</strong></p><p><strong>注意：在使用 tar 的压缩解压命令的时候，-f 后面一定要紧跟它要指定的文件，否则可能会报错。如果 -f 后面没有紧跟它要指定的文件，则 tar 命令的选项中不能加「-」，否则会报错 <code>Cannot stat: No such file or directory</code>。</strong></p><p>3、压缩命令 zip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/zip；作用：压缩文件或目录；压缩后文件格式：.zip</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    zip [选项] [压缩后文件名] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  压缩目录</span><br></pre></td></tr></table></figure></p><p>解压命令 unzip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/unzip；作用：解压 .zip 的压缩文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    unzip [压缩文件]</span><br></pre></td></tr></table></figure></p><p>一般来讲，Linux 里面的压缩包的格式 windows 的压缩软件几乎都支持。但反过来就要看具体情况了。默认在使用的过程中，只有一种压缩格式 windows 和 Linux 双方都不需要再额外装什么软件都可以进行解压缩处理的就是 .zip 格式。<strong>使用 zip 命令：会保留源文件，可以压缩目录。</strong> 压缩比没有 gzip 那么可观，所以使用的会比较少。使用 unzip 命令进行解压缩的时候，不分压缩文件是目录还是文件，都可以进行解压缩。</p><p>4、压缩命令 bzip2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/bzip2；作用：压缩文件；压缩后文件格式：.bz2</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    bzip2 [选项] [文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -k  产生压缩文件后保留原文件，keep</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 压缩</span><br><span class="line">    bzip2 -k test</span><br><span class="line"></span><br><span class="line">    # 跟 tar 命令结合使用，采用 bzip2 的方式压缩</span><br><span class="line">    tar -cjf test.tar.bz2 test</span><br></pre></td></tr></table></figure></p><p>这是一个 gzip 的升级版本。值得注意的是 bzip2 的压缩比是非常惊人的，一般往往用来压缩大的文件。还可以跟 tar 一起来使用：即用 tar 命令里的 z（z 表示 tar 命令中的压缩方式）替换为 j（j 表示 bzip2 的压缩方式）。注意 bzip2 只能处理文件，不能处理目录。</p><p>解压命令 bunzip2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/bunzip2；作用：解压缩</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    bunzip2 [选项] [压缩文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -k    解压缩后保留原文件，keep</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 解压</span><br><span class="line">    bunzip2 -k test.bz2</span><br><span class="line"></span><br><span class="line">    # 跟 tar 命令结合使用，解压 bzip2 方式的压缩</span><br><span class="line">    tar -xjf test.tar.bz2</span><br></pre></td></tr></table></figure></p><p>如果该目录下有跟解压后的文件同名的文件则该命令会拒绝解压缩，不会像其他命令询问你是否覆盖等。要想解压则必须先删除或更改同名文件。在解压缩 .tar.bz2 文件的时候同样适用 tar 命令，注意把 z 替换为 j 即可。</p><p>小结：</p><ol><li>.gz 类型的压缩文件 gzip 进行压缩 gunzip（或 gzip -d）进行解压缩。不能压缩目录，不能保留源文件。</li><li>.tar 类型的文件 可以生成打包文件 tar -cf 打包，-xf 解包，可以利用此命令进行压缩目录。</li><li>.tar.gz 类型的压缩文件 tar -zcf 打包并压缩，tar -zxf 解包并解压缩。</li><li>.zip 类型的压缩文件 zip 压缩文件 zip -r 压缩目录，unzip 解压缩文件或者目录（压缩比不是特别高，windows 和 Linux 通过格式）。</li><li>.bz2 类型的压缩文件 bzip2 进行压缩，bunzip2（或者是 bzip2 -d）进行解压缩。</li><li>.tar.bz2 类型的压缩文件 tar -cjf 生成压缩包，tar -xjf 进行解压缩。</li></ol><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><p>1、网络命令 write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/write；作用：给用户发信息，以 Ctrl + D 保存 结束</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    write 用户名</span><br></pre></td></tr></table></figure></p><p>注意：在 write 命令的输入界面，按退格键是不行的，需要按 Ctrl + 退格键或者按 Delete 键，表示退格的意思。内容输入结束后按回车，然后使用 Ctrl + D 保存并结束。<strong>特别注意的是只能给在线用户发送，如果用户不在线消息是发不出去的。</strong></p><p>2、网络命令 wall<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 write all；命令所在路劲：/usr/bin/wall；作用：发广播信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    wall 消息</span><br></pre></td></tr></table></figure></p><p>给当前所有在线用户发送信息。在使用该命令发送广播信息的时候，自己也会受到一条发的广播信息。本地终端也会收到广播信息。<strong>注意只有在线用户可以收到消息。</strong></p><p>3、网络命令 ping<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/ping；作用：测试网络连通性</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ping [选项] IP地址</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c   指定发送次数</span><br></pre></td></tr></table></figure></p><p>现在使用最多的远程探测命令，工作机制：给远程主机发送一个信息包，判断你是否存在即看看你是否回应我，只要你回应，就证明咱们两个之间网络是通的。注意在使用 ping 命令的时候，重点看 package loss 即丢包率这个属性。如果丢包率非常高，即使你 ping 通了，证明你的网状态其实也非常差 。</p><p>4、网络命令 ifconfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 interface configure；命令所在路径：/sbin/ifconfig；作用：查看和设置网卡信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ifconfig 网卡名称 IP地址</span><br></pre></td></tr></table></figure></p><p>Linux 系统中默认有两块网卡，eth0 代表的是本地的真实网卡，lo 回环网卡，用来本机通信和测试的，地址也是固定的，都是 127.0.0.1，不插网线甚至网卡驱动不安装，都可以 ping 通。</p><p><img src="/upload_image/ifconfig_command_show.png" alt="ifconfig" title="ifconfig"></p><ol><li>eth0:网卡接口名称；flags：标志位，UP 表示网卡启用激活状态； mtu：maximum transmission unit，网卡最大传输单元为 1500 字节；</li><li>inet：IPv4 地址； netmask：子网掩码；broadcast：广播地址；</li><li>inet6：IPv6 地址；</li><li>ether(HWaddr)：以太网地址；txqueuelen 1000  (Ethernet)：以太网传输队列长度；网卡的硬件地址即我们所说的 MAC 地址，它是用十六进制表示的，48 位的地址，表示我的网卡的物理地址。MAC 地址是固化在网卡的只读存储器中的一个地址，位于网卡的芯片上，理论上来讲一般是不能改的。</li><li>RX packets 13245  bytes 1989908 (1.8 MiB)：此次网卡激活后接搜到的报文数量，总大小；</li><li>RX errors：接收时错误的个数；dropped：丢包个数；overruns：溢出个数；frame：帧。</li><li>TX packets 162  bytes 18461 (18.0 KiB)：传输的报文数量，总大小；</li><li>TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0：传输时错误、丢包、溢出、搬运、碰撞的个数。</li></ol><p>5、网络命令 mail<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/mail；作用：查看发送电子邮件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mail [用户名]</span><br></pre></td></tr></table></figure></p><p>mail 命令比 write 命令有一个好处，就是不管对方在不在线，都可以给对方发送邮件。Linux 的纯字符界面也可以进行邮件的收发，它利用的并不是真正的搭建好的邮件服务器，而是如果是本机用户给本机用户发信，它利用的是本地的内存。</p><p>mail 命令编辑完邮件后点击 Ctrl + D 保存结束。使用 mail 命令直接按回车，用来接受邮件，N 表示 new，即这是新收到的邮件还未阅读。想看第几分信，邮件前面有一个序列号，输入序列号回车就能看到这份邮件的具体内容，使用 h 键可以回到刚才的邮件列表，发现 N 消失了，表示邮件已读，要想删除邮件则「d 邮件序列号」，再按 h 查看邮件发现没有邮件了，q 键退出。</p><p>学习 mail 命令主要是有的时候系统会给 root 发一些系统信息的邮件，当你在用 root 登录以后系统会提示你有新的邮件需要接受，这个时候就需要我们知道怎么样来收到系统发给你（root）的信息。系统给 root 发送的信息都是非常重要的，例如日志的统计信息、系统的报错信息，当我们发现 root 有这样的邮件的时候，千万不可以忽略它，应该仔细的查看它，因为这说明你对的系统当中可能出现了一些问题，有可能会影响到你的系统的安全。</p><p>6、网络命令 last<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/last；作用：列出目前与过去登入系统的用户信息</span><br></pre></td></tr></table></figure></p><p>该命令会统计我的计算机的所有用户的登陆的时间信息，包括计算机重启时间也会被记录下来。这是一个重要的日志查询点，可以查看系统是否有异常登陆重启等信息。该命令是一个非常有效，非常重要，非常常用的日志查询命令，在服务器上可能会多次使用这样的命令。只想知道用户最后一次登陆的时间，不想知道所有的登陆信息，则可以使用另外一条命令：lastlog。last 统计的是只要有人登陆它就会记录，包括你多次登陆的信息。而 lastlog 会先把所有的用户都列出来，包括一些不能登陆的系统用户。</p><p>7、网络命令 lastlog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/lastlog；作用：检查某特定用户上次登录的时间</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # -u 指的是用户的 UID，查看特定用户的最后一次登陆的时间</span><br><span class="line">    lastlog -u 500</span><br></pre></td></tr></table></figure></p><p>8、网络命令 traceroute<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/traceroute；作用：显示数据包到主机间的路径</span><br></pre></td></tr></table></figure></p><p>作用：探测到达某一个指定网站（某一个主机）的路径。这条命令非常有用，可以事先探测好你访问某网站的路径，然后当你访问该网站出现问题的时候，可以对照然后得出哪里出现了问题。我们 traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了返回信息，所以我们得不到什么相关的数据包返回数据。</p><p>9、网络命令 netstat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/netstat；作用：显示网路相关信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    netstat [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -t   查询 TCP 协议的网络信息</span><br><span class="line">    -u   查询 UDP 协议的网络信息</span><br><span class="line">    -l   查看监听的端口，listening</span><br><span class="line">    -r   查看路由即查看网关，route</span><br><span class="line">    -n   用 IP 地址和端口号显示查询结果，而不是用域名或服务的名称，这样更快，因为省略了解析过程，numeric</span><br><span class="line">    -a   all</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看本机监听的端口，即查询当前计算机下，我开了哪些计算机端口</span><br><span class="line">    netstat -tuln</span><br><span class="line"></span><br><span class="line">    # 查看本机所有的网络连接</span><br><span class="line">    netstat -an</span><br><span class="line"></span><br><span class="line">    # 查看本机路由表，即查询路由列表</span><br><span class="line">    netstat -rn</span><br></pre></td></tr></table></figure></p><p>net 网络的意思，stat 即 state 状态的意思，查询网络状态的命令。这条命令的用途在服务器上非常广泛的。TCP 是传输控制协议的简称；UDP 用户数据报协议的简称。一般情况下服务的端口号是固定的，我们可以通过判断本机开了哪些监听端口来判断我的计算机开启了哪些服务。注意：TCP 协议才可以直接接受访问，所以它有 listen，代表状态是监听的。而 UDP 是没有的，它可以直接发送，不监听即不顾你在不在线。访问服务的时候不管访问的是 22 还是访问其他的服务，你的发起端口即源端口是 1024 以上的随机端口，只有目标端口是固定的。</p><p><img src="/upload_image/netstat_an.png" alt="netstat -an" title="netstat -an"><br>发现该命令的输出分了两大类，一类是上面的这些网络服务，除了有监听的协议之外，状态还出现了 ESTABLISHED 表示正在连接的。另一类就是下面的除了服务状态计算机中会有很多网络程序，它也会使用网络协议，使用网络端口，你可以看到这些程序所占用的端口，这个对我们意义不大。主要看到还是上面的信息。它跟 netstat -tlun最大的区别在于 netstat -tlun 只能查看监听，而它可以查看到正在连接的网络程序。</p><p><img src="/upload_image/netstat-rn.png" alt="netstat -rn" title="netstat -rn"><br>Destination 为 0.0.0.0 那行是当前计算机的默认路由列表，其实就是自己的网关。可以通过该命令查询当前计算机的网关。还可以通过 <code>route -n</code> 或 <code>cat /etc/resolv.conf</code> 查看当前计算机的网关。</p><p>10、网络命令 setup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/setup；作用：配置网络</span><br></pre></td></tr></table></figure></p><p>setup 是 redhat 开发的一个管理工具集合，它在其它的版本的 Linux 中不存在，这是 redhat 系类专有的。注意在配置完成后一点要重启网络服务：service network restart。使用 setup 配置的 IP 地址是永久生效的。该命令简单了解即可。</p><h2 id="挂载命令-mount"><a href="#挂载命令-mount" class="headerlink" title="挂载命令 mount"></a>挂载命令 mount</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/mount</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mount [-t 文件系统] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    mount -t iso9660 /dev/sr0 /mnt/cdrom</span><br></pre></td></tr></table></figure><p>该命令的作用是把我的设备连接到我给它分配的挂载点（可以理解为 windows 中的盘符，只是我们的挂载点是目录，而 windows 中的是 CDEF）。分区都是自动挂载的，只要安装了，分区了，每次启动不需要手动参与直接就可以挂载。但是 Linux 的 U 盘、光盘、移动硬盘等外接存储设备不能实现自动挂载，每次开机都只能手工来挂载。</p><p>挂载步骤：</p><ol><li>先创建挂载点：mkdir  /mnt/cdrom。</li><li>开始实现挂载：mount -t （-t 后面指定光盘的文件系统）iso9660（光盘的文件系统是固定的） /dev/sr0（设备文件名称，其来源是系统默认指定的，Linux 系统在 redhat centOS6.0 以上的系统中，设备文件名默认就叫 sr0，只要记住就可以了，不需要知道它是怎么来的，当然也可以写 cdrom，实际上就是一个软连接，通过命令：ll  /dev/cdrom 可以查看到）。这条命令中其实 -t iso9660 是可以省略的，因为该命令的这个选项或者说分区的光盘的文件系统是默认的，系统就知道它就叫  iso 9660，不写也可以。</li></ol><p>挂载其实就是找到这个硬件，给它分配一个设备文件名，再给它找一个盘符（即目录），把它的设备文件名和盘符连接起来，就是挂载。（挂载的本质：就是把设备文件名连接到挂载点上）。如果之前你的这个挂载点上做过挂载，那么你需要把它卸载以后再进行挂载：umonut  /dev/sr0。正常挂载完，mount 命令是没有任何提示的，这里提示的作用是报错，它尝试把它挂成写权限，但是光驱是只读的，所以被迫挂成了只读的，光盘绝大多数都是只读的。（windows 是光盘符下访问，而 Linux 中的盘符是目录）挂载完成后通过 cd（即cd  /mnt/cdrom）切换到盘符目录下去访问它的数据。（/dev/sr0 是一个文件，cd 命令是进不去的）。注意：必须要执行卸载命令，才可以弹出光盘。切记不可以在光盘挂载点下面卸载，因为系统会认为光盘正在使用，不允许卸载。你需要退出挂载点，直接 cd 即可返回到自己的宿主目录。在卸载的时候，因为 /dev/sr0 和 /mnt/cdrom 它们两个通过 mount 命令已经连接了，所以后面加其中任何一个都是可以的，但是只能跟一个，要是跟两个它就会卸载两遍，第二遍它就会报错。直接回车没有任何提示表示卸载成功，再回到 /mnt/cdrom 执行 ls 命令发现变成了空目录了。</p><h2 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h2><p>1、shutdown 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：shutdown [选项] 时间</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c   取消前一个关机命令，cancel</span><br><span class="line">    -h   关机，halt</span><br><span class="line">    -r   重启，reboot</span><br></pre></td></tr></table></figure></p><p>除了 shutdown 命令之外还有其他命令可以实现关机或重启，只是早期的时候只有 shutdown 命令会在关机和重启之前正确的保存它正在启动的服务，尽管现在 Linux 中绝大多数的关机重启命令都已经实现了正确的关闭服务和保存数据，只是我们已经习惯了 shutdown 命令了。虽然其他命令也可以做到，但是 shutdown 命令更安全一点，我们更信任它。</p><p>2、其他关机命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 关机</span><br><span class="line">halt</span><br><span class="line"></span><br><span class="line"># 关机</span><br><span class="line">power off</span><br><span class="line"></span><br><span class="line"># 关机</span><br><span class="line">init 0</span><br></pre></td></tr></table></figure></p><p>注意：poweroff 相当于直接断电，谨慎使用！！！</p><p>3、其他重启命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重启</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">init 6</span><br></pre></td></tr></table></figure></p><p>4、系统运行级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0   关机</span><br><span class="line">1   单用户</span><br><span class="line">2   不完全多用户，不含 NFS 服务</span><br><span class="line">3   完全多用户</span><br><span class="line">4   未分配</span><br><span class="line">5   图形界面</span><br><span class="line">6   重启</span><br></pre></td></tr></table></figure></p><p>单用户类似于 windows 中的安全模式，其实就是启动最小的服务，其他多余的东西、附加的程序都不要，甚至连网都不要，只启动最核心的程序，进去是用来做修复的。只能是 root 登录进去，其他用户都不行，顾名思义即为单用户。运行级别 1 是没有图形界面的，不光 1 级别没有图形界面，1、2、3 这 3 个运行级别都是没有图形界面的，4 是没有使用的，即可以自己定义，5 是标准的图形界面。2、3 其实都是命令行，区别是：3 是完全的命令行，而 2 是不包含 NFS 服务的命令行，即它也是命令行只是不完整（2 级别也没有网络服务）。NFS 服务：（network file system）网络文件系统，使用 NFS 是实现两个 Linux 之间的文件共享或者是 Linux 和 Unix 之间的文件共享的服务。由于 NFS 用户验证的机制比较弱，即可能不是太安全，有它自己的安全隐患在里面，所以不太建议使用 NFS 来进行文件共享，当然使用它进行文件共享确实很简单方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看系统默认运行级别</span><br><span class="line">cat /etc/inittab</span><br><span class="line"></span><br><span class="line"># 修改系统默认运行级别，注意：id 最后是有冒号的「:」，千万不可以丢！！！</span><br><span class="line">id:3:initdefault:</span><br><span class="line"></span><br><span class="line"># 查看系统运行级别</span><br><span class="line">runlevel</span><br></pre></td></tr></table></figure><p>注意：0 和 6 不能设为系统默认运行级别。在 Linux 中用 X11 代表图形界面，大写的 X 指的是 Xwindow，一般来讲，在 Linux 中看到类似于这样的表示（包括只有一个大写的 X）都表示 Linux 的一个图形环境的意思。</p><p>执行 runlevel 命令之后会有「N  3」这样的显示，3 表示当前运行的级别号，N 代表上一个运行级别，即进入 3 级别之前我在哪个级别（由于我们是开机之后直接进来的，所以是 N 表示 null 的意思）。</p><p><code>init 5</code> 表示切换到运行级别 5 即图形界面，由于我没有装图形界面它不会执行，且远程工具上是不会报错的，但是在 Linux 本地上会有报错提示，它尝试去启动 5 级别，但是没有启动成功。但是系统以为你进去了，所以执行 runlevel 命令的时候会有显示 <code>5 3</code>。</p><p>5、退出登录命令 logout<br>退出一个登录 Shell。注意：在使用完 Linux 后，一定要 logout！！！否则后果很严重！！！</p><p>6、Linux 中的管道符<br>利用 Linux 所提供的管道符「|」将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="http://blog.51cto.com/9762617/1678917" target="_blank" rel="noopener">centOS 7 安装 man 中文版手册</a><br><a href="https://blog.csdn.net/qq_36838191/article/details/80314101" target="_blank" rel="noopener">Linux 中的内部命令和外部命令</a><br><a href="http://blog.51cto.com/xuding/1728866" target="_blank" rel="noopener">Linux 网络属性配置命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(五) —— Linux 常用命令 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 入门总结(五)</title>
    <link href="yanchongsheng.github.io/2018/09/18/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%94)/"/>
    <id>yanchongsheng.github.io/2018/09/18/Java入门总结(五)/</id>
    <published>2018-09-18T10:54:55.000Z</published>
    <updated>2018-09-18T11:03:01.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(五) —— Arrays 类 </blockquote><a id="more"></a><p>1、Java 中的 Arrays 类中包含一些对数组操作的静态方法。</p><p>2、Arrays 的 toString 方法可以方便的输出一个数组的字符串形式。</p><p>3、数组排序之基本类型，对指定类型的数组按升序进行排序。sort 方法还可以指定排序范围 [fromIndex, toIndex)。</p><p>4、数组排序之对象类型，sort 还可以直接接受对象类型，但对象需要实现 Comparable 接口。</p><p>5、数组排序之自定义比较器，sort 还可以接受一个比较器作为参数。Comparator 就是比较器，它是一个接口，最主要的是 compare 这个方法，它比较两个对象，返回一个表示比较结果的值，-1 表示 o1 小于 o2，0 表示相等，1表示 o1 大于 o2。排序是通过比较来实现的，sort 方法在排序的过程中，需要对对象进行比较的时候，就调用比较器的 compare 方法。</p><p>6、需要注意的是 binarySearch 针对的必须是已排序数组，如果指定了 Comparator，需要和排序时指定的 Comparator 保持一致，另外，如果数组中有多个匹配的元素，则返回哪一个是不确定的。</p><p>7、在创建多维数组时，除了第一维的长度需要指定外，其他维的长度不需要指定，甚至，第一维中，每个元素的第二维的长度可以不一样。</p><p>8、多维数组到底是什么呢？其实，可以认为，多维数组只是一个假象，只有一维数组，只是数组中的每个元素还可以是一个数组，这样就形成二维数组，如果其中每个元素还都是一个数组，那就是三维数组。</p><p>9、Arrays 类的 sort 实现原理：  </p><blockquote><ul><li>基本数据类型数据：双枢轴快速排序(Dual-Pivot Quicksort)；是一种对快速排序（不稳定）进行优化后的算法；  </li><li>引用数据类型数据：TimSort；是一种对归并排序（稳定）进行优化后的算法；</li></ul></blockquote><p>它们之所以没有采用相同的排序算法，跟排序算法的稳定性有关。快速排序更快，但不稳定，而归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没有关系。但对于对象类型，相同只是比较结果一样，它们还是不同的对象，其他实例变量也不见得一样，稳定不稳定可能就很有关系了，所以采用归并排序。</p><p>10、Comparator 接口和 Comparable 接口？<br><a href="https://blog.csdn.net/zolalad/article/details/30060499" target="_blank" rel="noopener">Comparable 接口和 Comparator 接口的比较</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.cnblogs.com/swiftma/p/5747942.html" target="_blank" rel="noopener">Java编程的逻辑 —— 剖析 Arrays</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(五) —— Arrays 类 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/17/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/17/Linux入门总结(四)/</id>
    <published>2018-09-17T11:53:18.000Z</published>
    <updated>2018-10-26T02:34:31.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(四) —— Linux 常用命令 </blockquote><a id="more"></a><h2 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h2><p>1、命令格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    命令 [-选项] [参数]</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">    1. 个别命令使用不遵循此格式</span><br><span class="line">    2. 当有多个选项时，可以写在一起</span><br><span class="line">    3. 简化选项与完整选项，eg：-a 等于 --all</span><br></pre></td></tr></table></figure></p><p>关于选项：在大多数的命令中，选项前面会有一个小横杆，用来标记这是一个选项；选项的作用：使用命令的时候用来做不同的操作，使命令结果呈现不同的形式或者信息内容，就可以加上不同的选项来实现，即选项是用来调整命令功能的。我们使用的选项都是简化选项，完整选项需要两个「-」 来调用，选项的顺序一般都是可以调整的。[] 里的内容是选择性加入的。加了选项是调整功能，加了参数是指定操作对象。</p><p>2、目录处理命令 ls<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 list；命令所在路径：/bin/ls；作用：显示目录文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ls [选项] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a  a 表示 all</span><br><span class="line">    -l  l 表示 long</span><br><span class="line">    -d  d 表示 directory，显示当前目录本身，而不显示目录下的数据</span><br><span class="line">    -h  h 表示 human，人性化显示文件大小</span><br><span class="line">    -i  i 表示 iNode，显示 i 结点号</span><br></pre></td></tr></table></figure></p><p>在 Linux 中，以「.」开头的是隐藏文件。隐藏文件的初衷是为了告诉用户这是一个系统文件，没有特殊情况一般不要修改它。在 Linux 中要想把一个文件隐藏，则需要给它改名，改成以点开头的文件名即可隐藏。</p><p>3、ls -l 显示结果分析<br><img src="/upload_image/ls_Analyse_Result.png" alt="ls -l" title="ls -l"></p><ol><li>x 表示执行权限，是 execute 的缩写；可执行文件 .exe 的缩写也来源于这个单词。</li><li>引用计数，代表这个文件曾经被引用或者调用过几次。这个引用计数对文件和目录来讲只在硬链接中才有作用。</li><li>文件大小默认单位是字节。可以使用 -h 选项来调整。</li><li>上图中的时间表示该文件最后被修改的时间；如果没有被修改过，则就是它的创建时间。需要注意的是 Linux 中没有创建时间这个概念，它只有文件的最后一次访问时间，文件的状态修改时间，文件的数据修改时间这三个时间。</li><li>i 节点，在 Linux 系统中每个文件或者目录都有它自己的一个唯一标识编号，系统靠这个 i 节点号搜索或者查找文件或者目录。</li></ol><p>4、目录处理命令 mkdir<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 make directories；命令所在路径：/bin/mkdir；作用：创建新目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mkdir [选项] 目录名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -p  p 表示 parents，如果新创建的目录的父目录不存在，则自动递归创建父目录</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可同时创建多个目录，多个目录之间以空格进行分割</span><br><span class="line">    mkdir /tmp/test1 /tmp/test2 /tmp/test3</span><br></pre></td></tr></table></figure></p><p>目录在 windows 中又称为文件夹。不要轻易在根目录下创建新的目录或者文件。可以在 /tmp 目录下进行练习，该目录是用来存放临时文件的。</p><p>5、目录处理命令 cd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change directory；命令所在路径：shell 内置命令；作用：切换目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cd [目录]</span><br></pre></td></tr></table></figure></p><p>「.」 表示当前目录，「..」表示当期目录的上一级目录。</p><p>注意：在 Dos 窗口下 cd.. 中间是可以不加空格的，但是在 Linux 中，中间必须有空格。</p><p>6、目录处理命令 pwd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 print working directory；命令所在路径：/bin/pwd；作用：显示当前所在目录的绝对路径</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></p><p>7、目录处理命令 rmdir<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 remove empty directories；命令所在路径：/bin/rmdir；作用：删除空目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    rmdir [空目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可同时删除多个空目录，多个空目录之间以空格进行分割</span><br><span class="line">    rmdir /tmp/test1 /tmp/test2 /tmp/test3</span><br></pre></td></tr></table></figure></p><p>注意：rmdir 只能删除空的目录！！！要想使用 rmdir 删除目录，必须先把该目录下的所有子目录和文件都删除掉，才可以使用。实际操作中此命令用的并不是很多。</p><p>8、目录处理命令 cp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 copy；命令所在路径：/bin/cp；作用：复制文件或目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cp [选项] [原文件或目录] [目标目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  复制目录，copy directories recursively</span><br><span class="line">    -p  保留文件属性，same as --preserve=mode,ownership,timestamps</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 将 /tmp 下 test1、test2、test3 目录一次性复制到 /root 下，并保持目录属性</span><br><span class="line">    cp -rp /tmp/test1 /tmp/test2 /tmp/test3 /root</span><br></pre></td></tr></table></figure></p><p>在 cp 复制文件的时候是不需要加选项的；但是要复制目录的话要增加选项 -r；cp 可以同时复制多个文件或者目录。</p><p>当把一个文件或目录复制到另一个地方的时候，相当于在另一个地方创建了一个新的文件或目录，所以复制出来的文件或目录的最后更改时间就是当前时间。如果希望复制出来的文件或目录的最后更改时间跟源文件一样，则使用 -p 选项。</p><p>在 Linux 中，复制文件或者目录的同时，可以更改目录或者文件的名字。</p><p>9、目录处理命令 mv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 move；命令所在路径：/bin/mv；作用：剪切文件、改名</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mv [原文件或目录] [目标目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # /tmp 下 test1、test2、test3 目录一次性剪切到 /root 目录</span><br><span class="line">    # 当一次剪切多个目录或文件的时候就不能改名了，改名操作只支持一次一个，不支持一次多个文件或目录进行改名</span><br><span class="line">    mv /tmp/test1 /tmp/test2 /tmp/test3 /root</span><br><span class="line">改名：</span><br><span class="line">    mv 要改名的文件名 新的文件名</span><br></pre></td></tr></table></figure></p><p>在 Linux 中剪切和改名是同一个命令。在执行复制剪切等命令的时候，如果你的位置是在当前目录的话，可以省略绝对路径，但是在不清楚当前目录的情况下要写绝对路径。mv 命令是不需要加 -r 选项的，直接使用 mv 可以同时剪切一个或多个目录或者文件的，而且在剪切的同时可以改名。</p><p>10、目录处理命令 rm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 remove；命令所在路径：/bin/rm；作用：删除文件或目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    rm [选项] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  删除目录，recursive</span><br><span class="line">    -f  强制删除，force</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 同时删除目录 test1 test2 文件 h1.txt h2.txt</span><br><span class="line">    rm -rf test1 test2 h1.txt h2.txt</span><br></pre></td></tr></table></figure></p><p>注意：Linux 中是没有回收站这一说的，文件一旦删除，就没有了。</p><p>在删除文件的时候每次都会询问你是否删除，如果你不想有这个提示的话，则可以加 -f 选项。</p><p>小结：mkdir 创建一个新的目录，选项 -p 递归创建目录；cd 切换目录；pwd 查看当前的工作目录；rmdir 删除一个空目录；cp 复制文件 -r 复制目录 -p 复制的时候保持文件的属性；mv 剪切或者给一个文件改名；rm 删除文件 -r 删除目录 -f 删除目录或者文件的同时不希望询问确认。</p><h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><p>1、文件处理命令 touch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/touch；作用：创建空文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    touch [文件名]</span><br></pre></td></tr></table></figure></p><p>注意：在 Linux 的命令里面，如果这个命令的参数没有详细的指定它的绝对路径，就表示要在当前目录下执行这个操作。要想在其他目录下执行这个操作，一定要指明它的绝对路径。</p><p>在 Linux 的文件命名里，除了「/」不能使用外，其它特殊符号都是合法的文件名，其后缀名是可以随便起的，这跟 windows 不一样。注意空格这个特殊符号，在 Linux 中并不建议将空格作为文件名组成部分，由于 Linux 系统把空格作为分隔符，要想使用空格作为文件名则必须用引号扩起来，这样虽然可以用空格作为文件名，但是对以后该文件的查找、修改、复制等操作造成麻烦，所以不建议这样使用。</p><p>2、文件处理命令 cat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/cat；作用：一次性显示整个文件内容</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cat [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n  显示行号，number</span><br></pre></td></tr></table></figure></p><p>cat 命令适合看简短的文件。cat 不适合浏览比较长的文件。cat 命令会一次性列出文件所有内容</p><p>3、文件处理命令 tac<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/tac；作用：一次性显示整个文件内容（反向列示）</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    tac [选项] [文件名]</span><br></pre></td></tr></table></figure></p><p>4、文件处理命令 more<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/more；作用：分页显示文件内容</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    more [文件名]</span><br><span class="line"></span><br><span class="line">快捷键：</span><br><span class="line">    空格或 f   翻页</span><br><span class="line">    Enter     换行</span><br><span class="line">    q 或 Q    退出</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    more /etc/services</span><br></pre></td></tr></table></figure></p><p>more 命令是一个常用的分页显示文件内容的命令。该命令不可以往上翻。</p><p>5、文件处理命令 less<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/less；作用：分页显示文件内容（可向上翻页）</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    less [文件名]</span><br></pre></td></tr></table></figure></p><p>使用 less 命令，不仅可以像 more 命令一样进行浏览，还可以往上翻，使用 PgUp 表示一页一页往上翻，使用向上的剪头表示一行一行往上翻。还可以进行搜索：直接在 less 的浏览状态里面按一个「/」+ 你要搜索的关键词，就会把行里所有包含这个关键词的进行反白显示，同时如果在你当前查看的页里没有你要得到的搜索的关键词所在行的信息，可以按 n 表示 next 接着往下找。</p><p>6、文件处理命令 head<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/head；作用：显示文件前面几行</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    head [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n   指定行数</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    head -n 20 /etc/services</span><br></pre></td></tr></table></figure></p><p>如果只想看文件的前几行，则可以使用此命令。如果不用 -n 指定要显示的行数，则默认显示的是前 10 行。</p><p>7、文件处理命令 tail<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">      命令所在路径：/usr/bin/tail；作用：显示文件后面几行</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    tail [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n   指定行数</span><br><span class="line">    -f   动态显示文件末尾内容</span><br></pre></td></tr></table></figure></p><p>显示文件最后面几行内容，默认是 10 行。-f 动态显示文件末尾的内容。使用该命令以后它会显示文件最末尾的位置，但是它并没有回到命令行，如果这时你这个文件的内容进行了变化，在这个命令操作状态下它也会实时变化的。一般来说用的也不会太多，一般用来监控一些日志。</p><p>小结：touch 创建一个文件；cat 查看文件的内容（浏览一些短文件），-n 用来显示行号；tac 反向显示文件内容（反向显示并不支持 -n 这个选项）；more 分页显示文件内容（主要指一些长的文件，不可以向上翻）；less 分页显示文件内容（可以向上/下翻，使用 「/ + 要搜索的关键词」在浏览的过程中遍历整个的文件进行搜索，可以用 n 键查找下一个匹配的位置）；head 查看一个文件的前几行，-n 指定要查看前几行，默认为 10 行；tail 查看一个文件的最后几行，-n 指定要查看后几行，-f 动态显示文件最后的内容，默认为 10 行。</p><p>8、文件处理命令 ln<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 link；命令所在路径：/bin/ln；作用：生成链接文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ln [选项] [原文件] [目标文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -s  创建软链接，s 代表 symbolic，make symbolic links instead of hard links，即创建符号链接而不是硬链接</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 创建 /etc/issue 的软链接 /root/issue.soft</span><br><span class="line">    ln -s /etc/issue /root/issue.soft</span><br><span class="line"></span><br><span class="line">    # 创建文件 /etc/issue 的硬链接 /root/issue.hard</span><br><span class="line">    ln /etc/issue /root/issue.hard</span><br></pre></td></tr></table></figure></p><p>9、软链接特征<br>类似 windows 快捷方式。作用：方便快捷的让你找到你最常使用的一些东西，便于规划，方便管理。  </p><ol><li>在 Linux 系统里面，它前面的 10 个文件权限的标识全部都是 lrwxrwxrwx，意味着所有的人都有全部的操作权限，每个用户在对这个软链接进行操作的时候，到底他能具有什么样的权限，是由这个文件对应的源文件的权限最终决定的。</li><li>软链接文件大小很小，因为它只是一个符号链接。</li><li>有一个箭头指向到它所对应的源文件（硬链接是没有箭头指向的）。</li></ol><p>10、硬链接特征</p><ol><li>拷贝「cp -p」+ 同步更新。cp -p 是拷贝文件并且保留文件的属性不变；同步更新即不管是修改原文件还是硬链接文件，两者的内容始终会自动保持一致，即同步更新。</li><li>通过 i 结点识别，硬链接的 i 节点与源文件的 i 节点一样。</li><li>不能跨分区。</li><li>不能针对目录使用。</li></ol><p>软链接与硬链接的区别：硬链接就类似于拷贝，但是可以同步更新，源文件即使不在了，硬链接照样可以访问，因为是类似拷贝的。如果软链接源文件不在了，则它会报错找不到源文件。一个文件一定有一个 i 节点，但是一个 i 节点不一定只对应一个文件，硬链接就是一个特殊案例，一个 i 节点映射到了多个文件。注意硬链接在 Linux 中用的非常少！</p><h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><p>1、权限管理命令 chmod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change the permissions mode of a file；命令所在路径：/bin/chmod；作用：改变文件或目录权限</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chmod [选项] [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [文件或目录]</span><br><span class="line">    chmod [选项] [mode] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -R   递归修改</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可以同时做多个授权，中间用「,」逗号分隔</span><br><span class="line">    chmod u+rwx,g+rw,o=r test.txt</span><br><span class="line"></span><br><span class="line">    # 注意 u、g、o 可以连在一起写</span><br><span class="line">    chmod u=rwx,go+rwx test.txt</span><br></pre></td></tr></table></figure></p><p><strong>一个文件或目录的权限只有两个人可以更改：一个是该文件或目录的所有者，另一个就是管理员 root。</strong></p><p>权限数字表示：r=4，w=2，x=1。</p><p>2、文件目录权限总结<br><img src="/upload_image/File_Directories_Permission.png" alt="文件目录权限总结" title="文件目录权限总结"></p><p>注意：读写执行权限对目录的含义！！！要想删除一个文件，你必须有这个文件所在的目录的写权限。对于目录，r（查看目录内容）、x（进入目录）权限一般都是一起出现的。</p><p>3、权限管理命令 chown<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change file ownership；命令所在路径：/bin/chown；作用：改变文件或目录的所有者</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chown [用户] [文件或目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 改变文件 test.txt 的所有者为 root</span><br><span class="line">    chown root test.txt</span><br><span class="line"></span><br><span class="line">    # 同时改变文件或目录的所有者所属组</span><br><span class="line">    chown root:root test.txt</span><br><span class="line">    或</span><br><span class="line">    chown root.root test.txt</span><br><span class="line"></span><br><span class="line">    # 该变文件或目录的所属组，注意「:」或「.」</span><br><span class="line">    chown .root test.txt</span><br><span class="line">    或</span><br><span class="line">    chown :root test.txt</span><br></pre></td></tr></table></figure></p><p><strong>在 Linux 系统中，改变一个文件或者目录的所有者，只有管理员 root 可以做这样的操作。</strong><br>可以使用 useradd 命令来添加一个用户，使用 passwd 为该用户设置一个密码。</p><p>4、权限管理命令 chgrp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change file group ownership；命令所在路径：/bin/chgrp；作用：改变文件或目录的所属组</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chgrp [用户组] [文件或目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 改变文件 test.txt 的所属组为 family</span><br><span class="line">    chgrp family test.txt</span><br></pre></td></tr></table></figure></p><p><strong>在 Linux 系统中，改变一个文件或者目录的所属组，只有管理员 root 可以做这样的操作。</strong></p><p>添加用户组命令：groupadd。</p><p>所有者：谁创建的文件谁就是文件的所有者；所属组：一个用户可以属于多个组，但是他总有个缺省组（缺省，即系统默认状态，意思与「默认」相同），每个用户创建文件的时候，它（该文件）的所属组就是该用户的缺省组，每个用户只能有一个缺省组。所以在创建一个文件的时候，它的所有者就是他自己即文件的创建者，它的所属组就是这个文件创建者的缺省组（了解即可）。</p><p>5、权限管理命令 umask<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 the user file-creation mask（mask 掩码的意思）；命令所在路径：Shell 内置命令；作用：显示、设置文件的缺省权限</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    umask [-S]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -S   以 rwx 形式显示新建文件缺省权限（注意 S 大写）</span><br></pre></td></tr></table></figure></p><p>在 Linux 权限管理有一个最基本的定义：缺省创建的文件是不能具有可执行权限的。所以在 Linux 系统中任何新建的文件都会把可执行权限去掉。这样做的目的是为了安全。<strong>注意只针对文件，对目录没有这样的限制。</strong></p><p>直接执行 umask 命令会得到一个 4 位的数字：0022。第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认的权限 rwxr-xr-x。而 Linux 系统中任何新建的文件都会把可执行权限去掉，所以你新建的任何一个文件的权限就是：rw-r–r–。</p><p>要想更改缺省权限，则需要先写出你要更改权限的数字，eg：rwxr-xr– 即 754，然后用 777-754=023，最后 umask 023 将缺省创建的权限改为 rwxr-xr–。虽然缺省创建的权限是可以更改的，但是并不建议这样去做。</p><h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><p>注意：尽量减少搜索这个操作，因为搜索它会占用大量的系统资源。在服务器高峰期里面，是不建议用搜索这个命令的。原则：不要在服务器使用高峰期的时候使用 find 命令来进行查找；在查找的过程中搜索的范围越小越好；搜索的条件越精准越好。</p><p>1、文件搜索命令 find<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/find；作用：文件搜索</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    find [搜索范围] [匹配条件]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 在目录 /etc 中查找文件 init</span><br><span class="line">    find /etc -name init</span><br><span class="line"></span><br><span class="line">    # -iname 不区分大小写</span><br><span class="line">    find /etc -iname init</span><br><span class="line"></span><br><span class="line">    # （注意数据块概念）在根目录下查找大于 100MB 的文件；+n 大于</span><br><span class="line">    # -n 小于，n 等于</span><br><span class="line">    find / -size +204800</span><br><span class="line"></span><br><span class="line">    # 在 /etc 下查找大于 80MB 且小于 100MB 的文件</span><br><span class="line">    # -a 两个条件同时满足，and</span><br><span class="line">    # -o 两个条件满足任意一个即可，or</span><br><span class="line">    find /etc -size +163840 -a -size -204800</span><br><span class="line"></span><br><span class="line">    # 在根目录下查找所有者为 root 的文件</span><br><span class="line">    find / -user root</span><br><span class="line"></span><br><span class="line">    # 在根目录下查找所属组为 root 的文件</span><br><span class="line">    find / -group root</span><br><span class="line"></span><br><span class="line">    # 在 /etc 下查找 5 分钟内被修改过属性的文件和目录</span><br><span class="line">    # -amin 访问时间 access；-cmin 文件属性 change；-mmin 文件内容 modify</span><br><span class="line">    # +n 大于多长时间，-n 多长时间以内，n 等于</span><br><span class="line">    find /etc -cmin -5</span><br><span class="line"></span><br><span class="line">    # -type 根据文件类型查找</span><br><span class="line">    # f 文件；d 目录；l 软链接文件</span><br><span class="line">    find /etc -type f</span><br><span class="line"></span><br><span class="line">    # -inum 根据 i 节点查找</span><br><span class="line">    find /etc -inum 12345</span><br><span class="line"></span><br><span class="line">    # 在当前目录中查找 iNode 为 666 的文件或目录并删除</span><br><span class="line">    find . -inum 666 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>注意利用 -name 搜索的话，它只会搜索文件名是 init的文件，而不像 windows 里面那样只要文件名包含 init 就都会被搜素到，可以理解为这是一种非常精准的搜索。要想像 windows 一样，可以做一个模糊的搜索即只要是包含 init 这 4 个连续的字母，就可以被搜素到，则：find /etc -name <em>init</em>，「<em>」号表示通配符，意思是只要文件名里有 init 就会被搜索到。init</em> 表示以 init 开头的；init??? 表示 init 以后有 3 个字符，问号匹配单个字符。Linux 中常用的两种通配符：* 号可以匹配任意字符，? 号可以匹配某个单个字符。</p><p>注意：在 Linux 系统中，一个数据块默认是 512 字节即 0.5kb；数据块是 Linux 系统中存储文件的最小单位。而 -size 的大小是用数据块换算的，所以 100MB 的文件所对应的就是 204800 个数据块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在 /etc 下查找 inittab 文件并显示其详细信息</span><br><span class="line"># 「-exec/-ok 命令 &#123;&#125; \;」对搜索结果执行操作</span><br><span class="line">find /etc -name inittab -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>前面还是正常写 find 要执行的查找的命令，找到这个结果以后，可以使用 -exec/-ok 直接连接一个命令即对 find 查找的结果做一些操作，再加上固定格式「{} \;」。{} 表示的是 find 查找的结果，表示对 find 查找的结果做一个替换，因为 find 查找的结果可能有多个，所有使用 {} 表示。「\」表示转义符，「;」表示结束。<br>注意：「;」分号，不要丢掉，而且「\」和「;」之间没有空格分隔！！！ -exec 和 -ok 的区别：-exec 直接执行，-ok 会一个个询问你是否执行（即会有询问确认环节）。</p><p>find -inum 使用场景，确定一个文件是否有硬链接。查看一个文件是否有硬链接：首先查看该文件的 i 节点，然后在整个它所在的分区里面（硬链接不能跨分区）做一个搜索，找 i 节点是你这个指定数字的文件，它就会把它的硬链接文件找到。</p><p>小结：find 命令 -name 根据文件名来查找；-iname 查找的时候不区分大小写；使用的通配符：* 匹配任意字符，? 匹配单个字符；-size 根据文件大小来查找，+ 大于多少，- 小于多少；-user 根据所有者来查找；-group 根据所属组来查找；-amin 根据访问时间来查找；-cmin 根据文件属性的更改查找；-mmin 根据文件内容更改来查找；-type 根据文件类型来查找，f 文件，d 目录，l 软链接；-inum 根据 i 节点来查找；-a 连接两个条件，表示两个条件都满足；-o 表示两个条件只有满足一个就可以；-exec 或者-ok 对搜索的结果直接进行操作，二者的区别只有一个就是 -ok 会询问确认，固定格式「{} \;」。</p><h2 id="其他搜索命令"><a href="#其他搜索命令" class="headerlink" title="其他搜索命令"></a>其他搜索命令</h2><p>1、文件搜索命令 locate<br><a href="https://blog.csdn.net/feifeilyj/article/details/52238209" target="_blank" rel="noopener">centos locate 命令安装</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/locate；作用：在文件资料库中查找文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    locate 文件名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    locate inittab</span><br></pre></td></tr></table></figure></p><p>该命令在查找的时候不像 find 来遍历你所搜索的范围，而是建立了一个文件资料库（该资料库会定期更新），它在找的时候不是在硬盘上找，而是在资料库里面找你有搜索的文件，所以速度很快。虽然使用 locate 命令查找的速度非常快，但是新建的文件使用该命令是找不到的，因为 locate 的文件资料库并没有更新。手动更新文件资料库命令：updatedb。</p><p>注意：/tmp 临时文件目录，并不在文件资料库所收录的文件范围之中，如果你要找的文件在 /tmp 目录下面，使用该命令是找不到的。如果希望 locate 命令在查找的时候不区分大小写，可以使用选项「-i」。</p><p>2、文件搜索命令 which<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/which；作用：搜索命令所在目录及别名信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    which 命令</span><br></pre></td></tr></table></figure></p><p>which 提供了一种快速查找一个命令所在的绝对路径的方法。除了可以找到命令所在的目录还可以找到该命令的别名，查看该命令本身是否有别名相关的信息。    实际上在 Linux 系统中，本身是没有询问确认的机制，之所以现在在 Linux 系统中有询问确认的选项，是因为它加了一个 -i 的选项，eg：在使用 rm 命令的时候，系统在找的时候找到的是一个别名而不是一个命令，它的别名等于「rm -i」，「-i」这个选项实际上就是一个询问确认的选项，所以这是别名的作用。</p><p>3、文件搜索命令 whereis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/whereis；作用：搜索命令所在目录及帮助文档路径</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    whereis [命令名称]</span><br></pre></td></tr></table></figure></p><p>whereis 除了可以找到命令所在的绝对路径，还可以找到这个命令它相关的帮助文档所在的位置，这个帮助文档就是 man 命令所展示的文件。</p><p>4、文件搜索命令 grep<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/grep；作用：在文件中搜寻字符匹配的行并输出，属于精确匹配</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    grep [选项] [指定字串] [文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -i   不分区大小写</span><br><span class="line">    -v   显示排除指定字串的行</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 列出在 /etc/issue 文件中包含 hello 字串的行，且忽略大小写</span><br><span class="line">    grep -i hello /etc/issue</span><br><span class="line"></span><br><span class="line">    # 列出 /etc/issue 文件中所有不包含 Hello 字串的行</span><br><span class="line">    grep -v Hello /etc/issue</span><br></pre></td></tr></table></figure></p><p>「-v  #」表示把 # 号所在的行都去掉，不管 # 号在什么位置，只要该行有 # 号，就都去掉。这样做是不太合理的，可能 # 位于中间，前面是有有效代码的。所以要想把行首以 # 开始的注释行去掉，要在 # 前面加一个表示行首的「^」即「^#」。使用 grep 命令查找文件中除注释以外的内容：<code>grep -v ^# 文件名</code>，需要注意的是针对 Shell 脚本的首行 # 号，应该做特殊处理。</p><p>小结：locate 快速定位到一个文件所在的路径（文件资料库），updatedb 更新文件资料库（有个别目录下的文件并不被收录到文件资料库中 /tmp），-i 不区分大小写；which 或者 whereis 查找命令所在的绝对路径；grep 在文件内容中查找，-i 不区分大小写，-v 排除查找。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(四) —— Linux 常用命令 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/12/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/12/Linux入门总结(三)/</id>
    <published>2018-09-12T12:28:43.000Z</published>
    <updated>2018-10-18T11:42:09.235Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(三) —— Linux 网络 </blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(三) —— Linux 网络 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(二)</title>
    <link href="yanchongsheng.github.io/2018/09/12/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/12/求实英语(二)/</id>
    <published>2018-09-12T11:27:16.000Z</published>
    <updated>2018-09-12T12:17:05.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(二) —— 主谓宾 </blockquote><a id="more"></a><p>1、他整天没地方去也没事儿干。<br>He goes nowhere and has nothing to do every day.</p><p>2、她天天在哪儿吃午饭？<br>Where does she have lunch every day?</p><p>3、你怎么不常和他们一块儿来？<br>Why don’t you often come with them?</p><p>4、王芳有姐姐吗？<br>Does WangFang have any sisters?</p><p>5、为什么他总听你的而不听我的？我不知道。<br>Why does he always listen to you but doesn’t listen to me? I don’t know.</p><p>6、他了解你多少？你非常了解他吗？<br>How much does he know you? Do you know him very well?</p><p>7、你们每周怎么去那儿?<br>How do you get there every week?</p><p>8、李梅不知道那事儿，但我知道。<br>LiMei doesn’t know that but me.</p><p>9、每天下班后，Tod 都载我回家。<br>Tod picks me up home after work every day.</p><p>10、这些小狗都叫什么？它的名字是 TianTian,那只叫 LeLe。<br>What are these dogs’ names? Its name is TianTian, that is called LeLe.</p><p>11、他准时上学并及时做作业。<br>He goes to school on time and does his homework in time.</p><p>12、没人相信他，因为他经常撒谎。他太丢人了。<br>Nobody believes him because he often tell lies. He is very shameful.</p><p>13、你妈把我的手表放什么里边了？<br>what does your mother put my watch in?</p><p>14、我像他，但却不喜欢他。<br>I am like hime, but I don’t like him.</p><p>15、你这么辛苦工作是为了什么？<br>what do you work hard for?</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>on time 准时<br>in time 及时</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(二) —— 主谓宾 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(三)</title>
    <link href="yanchongsheng.github.io/2018/09/12/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/12/求实英语(三)/</id>
    <published>2018-09-12T11:27:16.000Z</published>
    <updated>2018-09-21T03:15:34.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(三) —— 过去时 </blockquote><a id="more"></a><p>1、你去年经常拜访他们吗？<br>Did you ofter visit them last year?</p><p>2、三年前你对这种工作有多少经验？<br>我的：How much experience did you have for this job three years ago?<br>答案：How much experience in this kind of work did you have three years age?  </p><p>3、我没及时告诉她，因为我病了。<br>我的：I don’t tell her in time, because i was ill.<br>答案：I din’t tell her in time, because i was ill.</p><p>4、我上周就认知他了，可他却一点儿也不了解我。<br>我的：I knew him last week, but he don’t know me little.<br>答案：I knwe him last wekk, but he didn’t know me at all.</p><p>5、昨天你和王先生在哪儿？<br>where were you with Mr. Wang yesterday?</p><p>6、你见过那个新来的老板了吗？<br>我的：Do you have seen the new boss?<br>答案：Have you seen that new boss?</p><p>7、去年她像妈妈，可今年谁也不像。(此处 like 当介词)<br>我的：She was like her mother last year, but she isn’t like anyone this year.<br>答案：She was like her mother last year, but she is like no noe this year.</p><p>8、 谁问有关我学习的事儿来着？<br>我的：Who was asked me about my study？<br>答案：Who has asked something about my study?</p><p>9、爸爸昨晚没有责怪我。<br>Our father did’t scold me last night.</p><p>10、昨天你在哪儿听到的那个消息？我是从报纸上看到的。<br>where did you hear that news yesterday？I read it from the paper.</p><p>11、我的电脑又出毛病了。<br>我的：My computer has broken again.<br>答案：Something was wrong again with my computer.</p><p>12、昨天我很紧张，你呢？<br>I was very nervous yesterday, and how were you?</p><p>13、你们的值日生昨天擦黑板了吗？<br>Did your students on duty clean the blackboard yesterday?</p><p>14、今天上午李先生出什么事了？<br>我的：What did happend with Mr.Li this forenoon？<br>答案：What happended to Mr. Li this morning?</p><p>15、由于贫穷他去年就辍学了，我们去看看他吧。<br>我的：Because of poverty he droped out school last year, we are looking  at him tomorrow.<br>答案：He quit school last year because of being poor, Let’s go to see him tomorrow.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(三) —— 过去时 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker 入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/11/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/11/Docker入门总结(四)/</id>
    <published>2018-09-11T13:33:57.000Z</published>
    <updated>2018-09-12T08:41:27.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Docker 入门总结(四) </blockquote><a id="more"></a><p>1、Docker 包括三个基本概念：<br>镜像（Image）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>容器（Container）：容器的实质是进程。镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p><p>仓库（Repository）：一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>2、<code>$ docker run -it --rm ubuntu:16.04 bash</code><br>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</p><p>3、<code>$ docker system df</code><br>通过以上命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><p>4、docker image ls 选项：<br>默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。<br>docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。<br>-q 只列出镜像的 ID。</p><p>5、Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>1、FROM 指定基础镜像，一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p><p>2、RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><blockquote><p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。<br>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</p></blockquote><p>3、COPY 复制文件</p><blockquote><p>COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</p></blockquote><p>4、ADD 更高级的复制文件<br>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。这个功能其实并不实用，而且不推荐使用。</p><p>5、CMD 容器启动命令</p><blockquote><p>shell 格式：CMD &lt;命令&gt;<br>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]<br>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</p></blockquote><p>6、ENTRYPOINT 入口点<br>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。</p><p>7、ENV 设置环境变量</p><blockquote><p>ENV <key> <value><br>ENV <key1>=<value1> <key2>=<value2>…</value2></key2></value1></key1></value></key></p></blockquote><p>8、VOLUME 定义匿名卷</p><blockquote><p>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]<br>VOLUME &lt;路径&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Docker 入门总结(四) &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求实英语(一)</title>
    <link href="yanchongsheng.github.io/2018/09/11/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%80)/"/>
    <id>yanchongsheng.github.io/2018/09/11/求实英语(一)/</id>
    <published>2018-09-11T11:31:00.000Z</published>
    <updated>2018-09-12T12:17:05.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(一) —— 主系表 </blockquote><a id="more"></a><p>1、我姐姐在那儿吗？她和谁在一起呢？</p><blockquote><p>我的：Is my sister at there? whom is my sister with?<br>答案：Is my sister there? whom is she with?</p></blockquote><p>解析：there 在这里是名词，表示哪个地方的意思，所以不用 at。问句中用她来指代我姐姐。</p><p>2、我妈妈没在家，她和街坊出去了。</p><blockquote><p>我的：My mother is not at home, she is with neighborhood out.<br>答案：My mother is not at home, she is out with some neighbors.</p></blockquote><p>解析：out 在 这里是形容词，表示外面的。</p><p>3、那本书怎么样？它在你的手里吗？</p><blockquote><p>我的：How is that book? Is it in your hand?<br>答案：</p></blockquote><p>4、这是给我的，那些是给谁的？</p><blockquote><p>我的：This is for me, whom are those for?<br>答案：</p></blockquote><p>5、Sam Sterm 根本就没在这儿，他每天在二楼办公。</p><blockquote><p>我的：Sam Sterm is not here at all, he is at second floor everday.<br>答案：Sam Sterm is not here at all, he is at work on the 2nd floor ever day.</p></blockquote><p>解析：在工作用 at work 表示，在二楼用 at 2nd floor 表示，everday 是形容词每天的，而不是每天，这个是副词。</p><p>6、他是干什么的？他不是经理吗？</p><blockquote><p>我的：What is he? Is not he a manager?<br>答案：</p></blockquote><p>7、你的小狗在哪儿？它在什么里边？</p><blockquote><p>我的：Where is your dog? What is it in?<br>答案：</p></blockquote><p>8、这是谁的办公室？里边有人吗？哪间办公室是你的？</p><blockquote><p>我的：Whom is this office? Who is in the office? Which is your  office?<br>答案：Whose office is this? Is anyone in? Which office is yours?</p></blockquote><p>9、我的电话出了毛病，手机在哪儿？</p><blockquote><p>我的：My phone is wrong, where is cell phone?<br>答案：Something is wrong with my telephone,where is the cellphone?</p></blockquote><p>10、电视开着呢，把它关上吧！</p><blockquote><p>我的：The TV is on, turn it off!<br>答案：</p></blockquote><p>11、我的备份没在你的电脑里吗？</p><blockquote><p>我的：Is not my copy in your computer?<br>答案：</p></blockquote><p>12、这是干什么用的？</p><blockquote><p>我的：What is this for?<br>答案：</p></blockquote><p>13、我的手机昨天就在这儿放着呢!</p><blockquote><p>我的：My cellphone was right here yesterday!<br>答案：</p></blockquote><p>14、这个书包是谁的？那是谁的书包？我的在这儿！她的呢？  </p><blockquote><p>我的：Whose bag is this? Whose bag is that? My bag is here! Where is her bag?<br>答案：Whose is this bag? Whose bag is that? Mine is here! where is hers?</p></blockquote><p>15、这本字典不像我的，但那本像。  </p><blockquote><p>我的：This dictionary is not like mine,bug that is like.<br>答案：This dictionary is not like mine,bug that one is.</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、注意区分以下两种形式：<br>Whose is this bag？这个包是谁的？ This bag is whose.<br>Whose bag is this？这是谁的包？   This is whose bag.</p><p>2、区分 我、你、他 这些代词的各种形式：  </p><table><thead><tr><th>主格</th><th>宾格</th><th>属格</th><th>属格(名词性)</th></tr></thead><tbody><tr><td>I</td><td>me</td><td>my</td><td>mine</td></tr><tr><td>you</td><td>your</td><td>your</td><td>yours</td></tr><tr><td>he</td><td>him</td><td>his</td><td>his</td></tr><tr><td>she</td><td>her</td><td>her</td><td>hers</td></tr><tr><td>it</td><td>its</td><td>its</td><td>its</td></tr><tr><td>they</td><td>them</td><td>their</td><td>theirs</td></tr></tbody></table><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://zhidao.baidu.com/question/140269" target="_blank" rel="noopener">英语代词有哪些？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(一) —— 主系表 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
