<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有才的博客</title>
  
  <subtitle>不孤独，无自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="yanchongsheng.github.io/"/>
  <updated>2018-09-13T06:01:22.981Z</updated>
  <id>yanchongsheng.github.io/</id>
  
  <author>
    <name>Yan ChongSheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/12/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/12/Linux入门总结(三)/</id>
    <published>2018-09-12T12:28:43.000Z</published>
    <updated>2018-09-13T06:01:22.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(三) —— Linux 网络 </blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(三) —— Linux 网络 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>求实英语(二)</title>
    <link href="yanchongsheng.github.io/2018/09/12/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/12/求实英语(二)/</id>
    <published>2018-09-12T11:27:16.000Z</published>
    <updated>2018-09-12T12:17:05.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(二) —— 主谓宾 </blockquote><a id="more"></a><p>1、他整天没地方去也没事儿干。<br>He goes nowhere and has nothing to do every day.</p><p>2、她天天在哪儿吃午饭？<br>Where does she have lunch every day?</p><p>3、你怎么不常和他们一块儿来？<br>Why don’t you often come with them?</p><p>4、王芳有姐姐吗？<br>Does WangFang have any sisters?</p><p>5、为什么他总听你的而不听我的？我不知道。<br>Why does he always listen to you but doesn’t listen to me? I don’t know.</p><p>6、他了解你多少？你非常了解他吗？<br>How much does he know you? Do you know him very well?</p><p>7、你们每周怎么去那儿?<br>How do you get there every week?</p><p>8、李梅不知道那事儿，但我知道。<br>LiMei doesn’t know that but me.</p><p>9、每天下班后，Tod 都载我回家。<br>Tod picks me up home after work every day.</p><p>10、这些小狗都叫什么？它的名字是 TianTian,那只叫 LeLe。<br>What are these dogs’ names? Its name is TianTian, that is called LeLe.</p><p>11、他准时上学并及时做作业。<br>He goes to school on time and does his homework in time.</p><p>12、没人相信他，因为他经常撒谎。他太丢人了。<br>Nobody believes him because he often tell lies. He is very shameful.</p><p>13、你妈把我的手表放什么里边了？<br>what does your mother put my watch in?</p><p>14、我像他，但却不喜欢他。<br>I am like hime, but I don’t like him.</p><p>15、你这么辛苦工作是为了什么？<br>what do you work hard for?</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>on time 准时<br>in time 及时</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(二) —— 主谓宾 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker 入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/11/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/11/Docker入门总结(四)/</id>
    <published>2018-09-11T13:33:57.000Z</published>
    <updated>2018-09-12T08:41:27.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Docker 入门总结(四) </blockquote><a id="more"></a><p>1、Docker 包括三个基本概念：<br>镜像（Image）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>容器（Container）：容器的实质是进程。镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p><p>仓库（Repository）：一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>2、<code>$ docker run -it --rm ubuntu:16.04 bash</code><br>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</p><p>3、<code>$ docker system df</code><br>通过以上命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><p>4、docker image ls 选项：<br>默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。<br>docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。<br>-q 只列出镜像的 ID。</p><p>5、Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>1、FROM 指定基础镜像，一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p><p>2、RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><blockquote><p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。<br>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</p></blockquote><p>3、COPY 复制文件</p><blockquote><p>COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</p></blockquote><p>4、ADD 更高级的复制文件<br>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。这个功能其实并不实用，而且不推荐使用。</p><p>5、CMD 容器启动命令</p><blockquote><p>shell 格式：CMD &lt;命令&gt;<br>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]<br>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</p></blockquote><p>6、ENTRYPOINT 入口点<br>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。</p><p>7、ENV 设置环境变量</p><blockquote><p>ENV <key> <value><br>ENV <key1>=<value1> <key2>=<value2>…</value2></key2></value1></key1></value></key></p></blockquote><p>8、VOLUME 定义匿名卷</p><blockquote><p>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]<br>VOLUME &lt;路径&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Docker 入门总结(四) &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求实英语(一)</title>
    <link href="yanchongsheng.github.io/2018/09/11/%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%80)/"/>
    <id>yanchongsheng.github.io/2018/09/11/求实英语(一)/</id>
    <published>2018-09-11T11:31:00.000Z</published>
    <updated>2018-09-12T12:17:05.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> 求实英语(一) —— 主系表 </blockquote><a id="more"></a><p>1、我姐姐在那儿吗？她和谁在一起呢？</p><blockquote><p>我的：Is my sister at there? whom is my sister with?<br>答案：Is my sister there? whom is she with?</p></blockquote><p>解析：there 在这里是名词，表示哪个地方的意思，所以不用 at。问句中用她来指代我姐姐。</p><p>2、我妈妈没在家，她和街坊出去了。</p><blockquote><p>我的：My mother is not at home, she is with neighborhood out.<br>答案：My mother is not at home, she is out with some neighbors.</p></blockquote><p>解析：out 在 这里是形容词，表示外面的。</p><p>3、那本书怎么样？它在你的手里吗？</p><blockquote><p>我的：How is that book? Is it in your hand?<br>答案：</p></blockquote><p>4、这是给我的，那些是给谁的？</p><blockquote><p>我的：This is for me, whom are those for?<br>答案：</p></blockquote><p>5、Sam Sterm 根本就没在这儿，他每天在二楼办公。</p><blockquote><p>我的：Sam Sterm is not here at all, he is at second floor everday.<br>答案：Sam Sterm is not here at all, he is at work on the 2nd floor ever day.</p></blockquote><p>解析：在工作用 at work 表示，在二楼用 at 2nd floor 表示，everday 是形容词每天的，而不是每天，这个是副词。</p><p>6、他是干什么的？他不是经理吗？</p><blockquote><p>我的：What is he? Is not he a manager?<br>答案：</p></blockquote><p>7、你的小狗在哪儿？它在什么里边？</p><blockquote><p>我的：Where is your dog? What is it in?<br>答案：</p></blockquote><p>8、这是谁的办公室？里边有人吗？哪间办公室是你的？</p><blockquote><p>我的：Whom is this office? Who is in the office? Which is your  office?<br>答案：Whose office is this? Is anyone in? Which office is yours?</p></blockquote><p>9、我的电话出了毛病，手机在哪儿？</p><blockquote><p>我的：My phone is wrong, where is cell phone?<br>答案：Something is wrong with my telephone,where is the cellphone?</p></blockquote><p>10、电视开着呢，把它关上吧！</p><blockquote><p>我的：The TV is on, turn it off!<br>答案：</p></blockquote><p>11、我的备份没在你的电脑里吗？</p><blockquote><p>我的：Is not my copy in your computer?<br>答案：</p></blockquote><p>12、这是干什么用的？</p><blockquote><p>我的：What is this for?<br>答案：</p></blockquote><p>13、我的手机昨天就在这儿放着呢!</p><blockquote><p>我的：My cellphone was right here yesterday!<br>答案：</p></blockquote><p>14、这个书包是谁的？那是谁的书包？我的在这儿！她的呢？  </p><blockquote><p>我的：Whose bag is this? Whose bag is that? My bag is here! Where is her bag?<br>答案：Whose is this bag? Whose bag is that? Mine is here! where is hers?</p></blockquote><p>15、这本字典不像我的，但那本像。  </p><blockquote><p>我的：This dictionary is not like mine,bug that is like.<br>答案：This dictionary is not like mine,bug that one is.</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、注意区分以下两种形式：<br>Whose is this bag？这个包是谁的？ This bag is whose.<br>Whose bag is this？这是谁的包？   This is whose bag.</p><p>2、区分 我、你、他 这些代词的各种形式：  </p><table><thead><tr><th>主格</th><th>宾格</th><th>属格</th><th>属格(名词性)</th></tr></thead><tbody><tr><td>I</td><td>me</td><td>my</td><td>mine</td></tr><tr><td>you</td><td>your</td><td>your</td><td>yours</td></tr><tr><td>he</td><td>him</td><td>his</td><td>his</td></tr><tr><td>she</td><td>her</td><td>her</td><td>hers</td></tr><tr><td>it</td><td>its</td><td>its</td><td>its</td></tr><tr><td>they</td><td>them</td><td>their</td><td>theirs</td></tr></tbody></table><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://zhidao.baidu.com/question/140269" target="_blank" rel="noopener">英语代词有哪些？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; 求实英语(一) —— 主系表 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语基础" scheme="yanchongsheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="英语基础" scheme="yanchongsheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java入门总结(四)</title>
    <link href="yanchongsheng.github.io/2018/09/10/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/09/10/Java入门总结(四)/</id>
    <published>2018-09-10T13:14:54.000Z</published>
    <updated>2018-09-10T11:15:18.823Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/10/Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/10/Java入门总结(三)/</id>
    <published>2018-09-10T12:35:49.000Z</published>
    <updated>2018-09-10T11:02:30.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 入门总结(三) —— NIO </blockquote><a id="more"></a><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>1、在 Java 中，已有的 IO 操作大部分都属于阻塞的操作。为了提升服务器操作的性能，在 JDK1.4 之后增加了 NIO，在整个 NIO 的操作中，基本上都是使用缓冲区完成的。</p><p>2、<code>public abstract class Bufferextends Object</code> 抽象类 Buffer 是一个用于<strong>特定基本类型数据的容器</strong>。</p><p>3、<strong>缓冲区是特定基本类型元素的线性有限序列</strong>。除内容外，缓冲区的基本属性还包括容量、限制和位置：</p><blockquote><p>缓冲区的 容量(capacity) 是它所包含的元素的数量。缓冲区的容量不能为负并且不能更改。<br>缓冲区的 限制(limit) 是第一个不应该读取或写入的元素的索引。缓冲区的限制不能为负，并且不能大于其容量。<br>缓冲区的 位置(position) 是下一个要读取或写入的元素的索引。缓冲区的位置不能为负，并且不能大于其限制。  </p></blockquote><p>对于每个非 boolean 基本类型，此类都有一个子类与之对应。</p><p>4、标记、位置、限制和容量值遵守以下不变式： <code>0 &lt;= 标记 &lt;= 位置 &lt;= 限制 &lt;= 容量</code> 。</p><p>5、清除、反转和重绕   </p><blockquote><p>clear() 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为<strong>容量大小</strong>，将位置设置为 0。<br>flip() 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为<strong>当前位置</strong>，然后将位置设置为 0。<br>rewind() 使缓冲区为重新读取已包含的数据做好准备：它使<strong>限制保持不变</strong>，将位置设置为 0。  </p></blockquote><p>6、直接 与 非直接缓冲区<br>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</p><p>直接字节缓冲区可以通过调用此类的 allocateDirect 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</p><p>直接字节缓冲区还可以通过 mapping 将文件区域直接映射到内存中来创建。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</p><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>1、在 NIO 中，通道是一个可以用来读取和写入数据的一种形式。Channel 接口，用于 I/O 操作的连接。通道表示到实体的开放连接。 通道表示到实体，如硬件设备、文件、网络套接字或可以执行一个或多个不同 I/O 操作（如读取或写入）的程序组件的开放的连接。<strong>通道都是通过操作缓冲区来完成全部功能的。所有的内容都是先读或写到缓冲区之中，再通过缓冲区读或写入到通道中的，即程序不会直接操作通道。</strong><br><img src="/upload_image/Java_Channel.png" alt="Channel 简介" title="Channel 简介"></p><p>2、Java NIO Channel 通道和流非常相似，主要有以下几点区别：  </p><blockquote><p>通道可以读也可以写，流一般来说是单向的（只能读或者写）。<br>通道可以异步读写。<br>通道总是基于缓冲区Buffer来读写。  </p></blockquote><p>3、什么是内存映射？<br>将文件中的某个区域直接映射到内存中；对于较大的文件，这通常比调用普通的 read 或 write 方法更为高效。 在通道中还有一种方式成为内存映射。内存映射是速度最快的，MapperedByteBuffer，使用此种方式读取的内容是最快的，需要将一个输入的操作流绑定在内存映射上。</p><p>内存映射在读取的时候是最快的，但是如果执行的是写入操作则有可能是非常危险的，因为仅仅只是改变数组中的单个元素这样简单的操作就可能直接修改磁盘上的文件，因为修改数据与将数据保存在磁盘上是一样的。</p><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>在 Java NIO 中提供了文件锁的功能，这样当一个线程将文件锁定之后，其他线程是无法操作此文件的，要想进行文件的锁定操作，则要使用 FileLock 类完成，此类的对象需要依靠 FileChannel 进行实例化操作。</p><p>锁定方式：</p><blockquote><p>共享锁：允许多个线程进行文件的读取操作。<br>独占锁：只允许一个线程进行文件的读/写操作。</p></blockquote><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO 浅析</a><br><a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-channel.html" target="_blank" rel="noopener">Java NIO Channel 通道</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 入门总结(三) —— NIO &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(二)</title>
    <link href="yanchongsheng.github.io/2018/09/06/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/06/Linux入门总结(二)/</id>
    <published>2018-09-06T12:00:23.000Z</published>
    <updated>2018-09-12T12:23:48.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(二) —— Linux 系统安装 </blockquote><a id="more"></a><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>磁盘分区又叫系统分区，是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。从字面意思来讲，磁盘分区指的就是把大的硬盘按照我的需求划分成几个分区，不同类目录与文件可以存储进不同的分区。</p><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><ol><li>主分区：最多只能有 4 个。  </li><li><p>扩展分区「是从主分区的 4 个分区之中拿出 1 个分区作为扩展分区」：</p><blockquote><ul><li>扩展分区最多只能有 1 个（注意：针对一块硬盘来讲，一个硬盘最多只能有一个扩展分区）。</li><li>主分区加扩展分区最多只能有 4 个。</li><li>扩展分区本身不能写入数据也不能格式化，唯一的作用就是用来包含逻辑分区。</li></ul></blockquote></li><li><p>逻辑分区「即扩展分区中的逻辑分区」：可以正确的写入数据和格式化。按照硬盘的限制，一块硬盘最多只能分 4 个分区，即 4 个主分区。这种限制不是 Linux 系统的限制而是硬盘本身的限制，只要硬盘结构不发生变化，这种限制会一直存在。</p></li></ol><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>硬盘正确分区以后还不能写入数据，硬盘还必须经过格式化以后才可以写入数据。</p><p>格式化 (高级格式化) 又称逻辑格式化，它是指根据用户选定的文件系统（如 fat16、fat32、NTFS、ext2、ext3、ext4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。</p><p>在 windows 中可以识别的文件系统有 fat16、fat32、NTFS，在 linux 中可以识别的文件系统有 ext2、ext3、ext4，centOS 默认使用的是 ext4。</p><p>硬盘的格式化最主要的目的就是为了在硬盘当中写入文件系统，写入文件系统最主要的工作就是按照文件系统的规则把硬盘分成等大小的数据块，然后建立 iNode 表，我们把表里的编号称为 i 节点号又名 iNode 号。</p><p>当在查找文件的时候，是通过 iNode 表找到 i 节点号来找到这个文件的条款，从而知道这个文件保存在哪几个数据块之中，从而找到这几个数据块拿出文件，拼凑成我们的文件。这个格子就叫做数据块，又名 block。</p><p>在 centos 当中，默认的文件系统是 ext4，它在进入格式化的时候，它需要把硬盘划分为一个又一个等大小的数据块，这个数据块默认的标准大小为 4kb。假如有一个数据是 10kb，需要占用 3 个格子，最后一个格子只放了 2kb 数据，剩余的 2kb 空闲空间是不能再被其它文件所占用的，这 3 个格子不一定在一块。windows 中有一个磁盘碎皮整理，它的原理就是将保存的同一个文件的格子尽量放到一起，这样更有利于数据的读取。</p><h2 id="硬件设备文件名"><a href="#硬件设备文件名" class="headerlink" title="硬件设备文件名"></a>硬件设备文件名</h2><p>如果是 windows，在进行了分区、格式化之后，给分区分配盘符然后就可以直接使用了。但是 Linux 不行，Linux 在进行了分区、格式化，格式化完成之后，要想给分区分配盘符之前，<strong>还必须给每一个分区起一个设备文件名，或者说给每一个分区起一个硬件设备文件名。</strong></p><p>在 Linux 中所有的硬件设备都是文件。</p><p><img src="/upload_image/Hardware_Name.png" alt="硬件设备文件名" title="硬件设备文件名"></p><p>「/」表示 Linux 中的最高一级目录，也就是根目录。在根目录下有一个 dev 的一级子目录，在 dev 目录中放入的所有的文件都是<strong>硬件文件</strong>。我们将<strong>硬件文件名</strong>，称为<strong>硬件的设备文件名</strong>。</p><p>为什么 Linux 需要「硬件设备文件名」而 windows 不需要？<br>在 windows 中，硬盘分区、格式化之后，然后可以直接分配盘符是因为我们可以在 windows 的图形界面中直接看到这个硬盘在哪（注意：一台机器可能有多个硬盘），所以可以直接分配盘符（windows 有完善的图形界面）。但是 Linux 最早出现的时候，是没有图形界面的，为了让系统知道我要给哪一个硬盘分配盘符，所以被迫需要给每一个硬盘或者硬件设备指定设备文件名。</p><p><strong>硬件设备文件名是固定的，系统自动检测的，我们能看懂就行。</strong> 关于硬盘，我们现在主要使用的是 SATA 硬盘接口，IDE、SCSI 硬盘接口基本被淘汰了。</p><h2 id="分区设备文件名"><a href="#分区设备文件名" class="headerlink" title="分区设备文件名"></a>分区设备文件名</h2><p>硬盘有了「硬件设备文件名」，还要给分区也要分配文件名，这就是「分区设备文件名」。「分区设备文件名」是在硬盘「硬件设备文件名」之后，直接加分区号就可以了。即硬盘有设备文件名，分区也应该有设备文件名，区别是一个是硬件设备文件名，一个是分区设备文件名。</p><p>分区设备文件名：分区文件名是在硬盘文件名之后直接加分区号，1 表示这个硬盘当中的第一个分区，依次类推。<strong>注意分区号有主分区号和逻辑分区号。</strong></p><p>逻辑分区是从 5 开始的，1234 只能给主分区或者扩展分区使用，即使一个硬盘中没有分够 4 个主分区，逻辑分区也不能占用 1234 这 4 个分区号，即不管如何分区 5 都表示逻辑分区的第一个分区。</p><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>windows 中分配盘符的操作在 Linux 中叫做挂载，我们把给分区分配盘符的过程称为挂载，我们把盘符叫做挂载点。在 Linux 中是使用空的目录名称作为盘符，而不是使用 CDEF 作为盘符，理论上任何一个目录都可以作为盘符，实际上有些目录是不可以的。</p><p>对于 Linux 来讲有两个必须分区：根分区、swap 分区（交换分区，大小一般为内存的 2 倍，一般不超过 2GB）。这两个是必须分区，如果不分区，则 Linux 不能安装，只要有这两个分区，Linux 就可以正常使用。还有一个推荐分区，/boot（启动分区，大小一般为 200M)。</p><p>根分区用于存放剩余数据，swap 分区可以理解为虚拟内存，即当我真正的内存不够用的时候可以拿交换分区的硬盘空间来当内存来用，理论上讲 swap分 区应该是内存的两倍，但是最大不超过 2GB，因为虚拟内存到底不是真正的内存，如果给它给的再大，它也不能取代内存，当它达到 2GB 的时候，如果再给大，只会占用我们更多的硬盘空间，但是对我们的系统不会产生更多的影响，所以最大不超过 2GB。</p><p>Boot 分区是专门用来保存启动时候的数据，任何操作系统启动的时候都需要一些硬盘空间，如果不给 boot 分区，万一根分区写满了，系统可能就启动不了了，为了解决这个问题，一般都会给 boot 单独分区。Boot 分区 200MB 足够，不用太大，写完之后不再往 boot 分区写入任何数据，它永远都会有一定的空余空间，就算把根分区写满了，也不会影响 Linux 启动。</p><h2 id="Linux-文件系统结构"><a href="#Linux-文件系统结构" class="headerlink" title="Linux 文件系统结构"></a>Linux 文件系统结构</h2><p><img src="/upload_image/File_System_Structure.png" alt="Linux 文件系统结构" title="Linux 文件系统结构"></p><p>从 Linux 系统上看，boot、home 都是根分区的子目录。但是从硬盘上来看，它们每一个目录都可以有自己独立的硬盘空间，即每一个目录都可以有自己独立的分区，而每个分区又对应某块硬盘空间，所以每个目录都可以有自己独立的硬盘空间。</p><p>挂载点就是分区的盘符，swap 分区即交换分区没有盘符，swap 分区不是给用户用的，是由 Linux 操作系统或者内核直接调用的，所以它根本不需要盘符，有了盘符反而不正确了。swap 对系统性能的影响极小，所以分的空间不用太大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>分区：把大硬盘分为小的逻辑分区；<br>格式化：格式化的目的是为了写入文件系统，当然在写入文件系统的时候会附带的把硬盘当中的数据清空；<br>分区设备文件名：给每个分区定义设备文件名；<br>挂载：给每个分区分配挂载点，这个挂载点必须是目录，而且必须是空的目录才可以进行挂载点分配。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(二) —— Linux 系统安装 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 入门总结(一)</title>
    <link href="yanchongsheng.github.io/2018/09/06/Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>yanchongsheng.github.io/2018/09/06/Linux入门总结(一)/</id>
    <published>2018-09-06T11:18:24.000Z</published>
    <updated>2018-09-12T12:21:26.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(一) —— Linux 系统简介 </blockquote><a id="more"></a><h2 id="Unix-发展史"><a href="#Unix-发展史" class="headerlink" title="Unix 发展史"></a>Unix 发展史</h2><p>Unix 与 Linux 的关系就像是父子关系，Unix 是父亲，Linux 是儿子。肯.汤普森在 1969 年开发出了 Unix 系统。1971 年，肯.汤普森的同事丹尼斯.里奇发明了 C 语言，随后 Unix 系统绝大部分源代码用 C 语言重写，为提高 Unix 系统的可移植性打下基础。</p><h2 id="Unix-主要发行版本"><a href="#Unix-主要发行版本" class="headerlink" title="Unix 主要发行版本"></a>Unix 主要发行版本</h2><p><img src="/upload_image/Unix_Major_Version.png" alt="Unix 主要发行版本" title="Unix 主要发行版本"></p><h2 id="Linux-发展史"><a href="#Linux-发展史" class="headerlink" title="Linux 发展史"></a>Linux 发展史</h2><p>Linux 系统诞生于 1991 年，由芬兰大学生李纳斯(Linux Torvalds) 和后来陆续加入的爱好者共同完成。Unix 和 Linux 的内核都是用 c 语言写的。Linux 是开源软件。</p><h2 id="Linux-发行版和-Linux-内核的区别？"><a href="#Linux-发行版和-Linux-内核的区别？" class="headerlink" title="Linux 发行版和 Linux 内核的区别？"></a>Linux 发行版和 Linux 内核的区别？</h2><p>内核版是 Linux 官方发布的，仅仅是单纯的内核。在拿到内核以后，每个产商可以加入自己的桌面、应用程序等再进行开发，称为发行版。Linux 内核官网：www.kernel.org。</p><h2 id="Linux-主要发行版本"><a href="#Linux-主要发行版本" class="headerlink" title="Linux 主要发行版本"></a>Linux 主要发行版本</h2><p>Linux 主要分为两个系列：redhat 系列和 debian 系列。其本质是一样的，因为两者采用系统的内核。最主要的区别就是软件安装的方式不一样。Redhat 系列主要分为 HEL 和 federo 两个系列，其中 federo 是个人版，HEL 是企业版。对于 Linux 的企业版和个人版跟 windows 是不一样的，对于 windows 而言 windows7 是个人版，windows2008 是企业版，它们的区别是 windows7 可以看成是 windows2008 的一个阉割版，windows2008 才是完整的。但是 Linux 不同，个人版和企业版的区别在于，个人版是开发版，可能有的功能没有进行过测试，更像是一个实验体，而企业版是稳定版。</p><p><img src="/upload_image/Linux_Major_Version.png" alt="Linux 主要发行版本" title="Linux 主要发行版本"></p><h2 id="开源软件的特点"><a href="#开源软件的特点" class="headerlink" title="开源软件的特点"></a>开源软件的特点</h2><ol><li>使用的自由：绝大多数开源软件免费（注意的是开源和免费并不是等同的，开源软件也可以出售，但是卖给你的是源代码，并不是编译之后的代码给你）。</li><li>研究自由：可以获得软件源代码（开放源代码带来的好处——安全，足够多的眼睛可以发现更多的问题，可以容易的看到大神级人物的代码风格和注释）。</li><li>散步及改良自由：可以自由传播、改良甚至销售。</li></ol><h2 id="Linux-的应用领域"><a href="#Linux-的应用领域" class="headerlink" title="Linux 的应用领域"></a>Linux 的应用领域</h2><ol><li>基于 Linux 的企业服务器：企业服务器。</li><li>嵌入式应用：Android 平台就是一个典型的 Linux 嵌入式应用、智能家电如机顶盒、游戏机、数码相机等。</li><li>电影娱乐业：用于电影、图片的后期处理。</li></ol><h2 id="Linux-为什么选择命令行？"><a href="#Linux-为什么选择命令行？" class="headerlink" title="Linux 为什么选择命令行？"></a>Linux 为什么选择命令行？</h2><p>Linux 选用命令行界面主要是考虑到系统的稳定性和安全性，如果装了图形界面，对系统资源的占用是比较庞大的，所以比较不好用。而 windows 考虑的是易用性，windows 系统主要考虑的是系统的易用性。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>1、www.netcraft.com 是一个典型的扫描和踩点网站。只要输入你要查询的网站，就可以获取网站后台服务器所采用的操作系统。该网站是一个全球著名的信息统计网站。从攻击的角度叫踩点，从防御的角度叫扫描。</p><p>2、www.top500.org 会统计全球范围内运算能力排在前 500 的服务器或者叫群组。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Linux 入门总结(一) —— Linux 系统简介 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux 基础" scheme="yanchongsheng.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker 入门总结(三)</title>
    <link href="yanchongsheng.github.io/2018/09/04/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/09/04/Docker入门总结(三)/</id>
    <published>2018-09-04T11:41:20.000Z</published>
    <updated>2018-09-05T08:19:56.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Docker 入门总结(三) —— Nginx 容器教程 </blockquote><a id="more"></a><p>1、CentOS7 修改 Nginx 默认 web 目录后 403 ？<br>我这边的原因是：SElinux 没关导致的，直接使用命令 <code>setenforce 0</code> 关闭 SELinux 以后就正常了。具体原因查看：<a href="https://stackoverflow.com/questions/43302142/docker-nginx-selinux-centos-rhel-with-403-forbidden-access" target="_blank" rel="noopener">Docker nginx SELinux</a>。</p><p>2、CentOS7 修改 Nginx 默认 web 目录后 403 ？<br><code>docker container run -d -p 8000:80 --rm --name mynginx -v &quot;$PWD/html&quot;:/usr/share/nginx/html nginx</code><br><code>docker container run -d -p 8000:80 --rm --name mynginx -v &quot;$pwd/html&quot;:/usr/share/nginx/html nginx</code><br>注意：对 PWD 大小写敏感，深坑啊！！！否则会报 403 的错误。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html" target="_blank" rel="noopener">Nginx 容器教程</a><br><a href="http://www.56dr.com/info/iso/18848.html" target="_blank" rel="noopener">Nginx 报 403 forbidden 错误</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Docker 入门总结(三) —— Nginx 容器教程 &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker 入门总结(二)</title>
    <link href="yanchongsheng.github.io/2018/09/04/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/09/04/Docker入门总结(二)/</id>
    <published>2018-09-04T11:19:19.000Z</published>
    <updated>2018-09-05T11:12:00.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Docker 入门总结(二) —— Docker 微服务教程 </blockquote><a id="more"></a><p>1、站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器……Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。</p><p>2、如何在一台计算机上实现多个服务，让它们互相配合，组合出一个应用程序？</p><p>3、Docker 容器中是否可以再包含 Docker 容器，这样层层嵌套？</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">Docker 教程</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="noopener">Docker 微服务教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Docker 入门总结(二) —— Docker 微服务教程 &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ 入门总结</title>
    <link href="yanchongsheng.github.io/2018/08/30/RabbitMQ%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>yanchongsheng.github.io/2018/08/30/RabbitMQ入门总结/</id>
    <published>2018-08-30T11:16:04.000Z</published>
    <updated>2018-09-03T03:15:35.287Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> RabbitMQ 入门总结 </blockquote><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>关于 RabbitMQ 的安装参考：<a href="https://blog.csdn.net/qq_33382113/article/details/78853680" target="_blank" rel="noopener">windows7 RabbitMQ 的安装</a>。</p><h2 id="RabbitMQ-角色"><a href="#RabbitMQ-角色" class="headerlink" title="RabbitMQ 角色"></a>RabbitMQ 角色</h2><p>1.超级管理员 (administrator)<br>可登陆管理控制台(启用 management plugin 的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p><p>2.监控者 (monitoring)<br>可登陆管理控制台(启用 management plugin 的情况下)，同时可以查看 rabbitmq 节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p><p>3.策略制定者 (policymaker)<br>可登陆管理控制台(启用 management plugin 的情况下), 同时可以对 policy 进行管理。</p><p>4.普通管理者 (management)<br>仅可登陆管理控制台(启用 management plugin 的情况下)，无法看到节点信息，也无法对策略进行管理。</p><p>5.其他的<br>无法登陆管理控制台，通常就是普通的生产者和消费者。</p><h2 id="RabbitMQ-常用命令"><a href="#RabbitMQ-常用命令" class="headerlink" title="RabbitMQ 常用命令"></a>RabbitMQ 常用命令</h2><p>插件管理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开启某个插件： rabbitmq-plugins enable &#123;插件名&#125;</span><br><span class="line">关闭某个插件： rabbitmq-plugins disable &#123;插件名&#125;</span><br><span class="line">插件名可以在 rabbitmq 的安装目录下的 plugins 目录中查看</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">开启后台管理插件：rabbitmq-plugins enable rabbitmq_management</span><br><span class="line">列出可用插件：rabbitmq-plugins list</span><br></pre></td></tr></table></figure></p><p>用户管理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">添加用户：rabbitmqctl add_user &#123;username&#125; &#123;password&#125;</span><br><span class="line">删除用户：rabbitmqctl delete_user &#123;username&#125;</span><br><span class="line">修改密码：rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;</span><br><span class="line">设置用户角色：rabbitmqctl set_user_tags &#123;username&#125; &#123;tag&#125;</span><br><span class="line">tag 可以为 administrator、monitoring、management</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">添加用户：rabbitmqctl add_user root root</span><br><span class="line">设置用户角色：rabbitmqctl set_user_tags root administrator</span><br><span class="line">列出所有用户：rabbitmqctl list_users</span><br></pre></td></tr></table></figure></p><h2 id="RabbitMQ-概述"><a href="#RabbitMQ-概述" class="headerlink" title="RabbitMQ 概述"></a>RabbitMQ 概述</h2><p>RabbitMQ 是消息代理。它接受来自生产者的信息，并将它们传递给消费者。在两者之间，它可以根据你给它的路由，缓冲规则进行传递消息。</p><h2 id="RabbitMQ-术语"><a href="#RabbitMQ-术语" class="headerlink" title="RabbitMQ 术语"></a>RabbitMQ 术语</h2><p>1.生产者(Producer)</p><p>2.消费者(Consumer)</p><p>3.队列(Queue)</p><p>工作队列（即任务队列）的主要思想是不用一直等待资源密集型的任务处理完成，这就像一个生产线，将半成品放到生产线中，然后在生产线后面安排多个工人同时对半成品进行处理，这样比一个生产线对应一个工人的吞吐量大几个数量级。</p><p>为了确保消息或者任务不会丢失，RabbitMQ 支持消息确认 ACK。ACK 机制是消费者端从 RabbitMQ 收到消息并处理完成后，反馈给 RabbitMQ，RabbitMQ 收到反馈后才将此消息从队列中删除。如果一个消费者在处理消息时挂掉（网络不稳定、服务器异常、网站故障等原因导致频道、连接关闭或者 TCP 连接丢失等），那么他就不会有 ACK 反馈，RabbitMQ 会认为这个消息没有正常消费，会将此消息重新放入队列中。如果有其他消费者同时在线，RabbitMQ 会立即将这个消息推送给这个在线的消费者。这种机制保证了在消费者服务器故障的时候，能不丢失任何消息和任务。</p><p>如果 RabbitMQ 向消费者发送消息时，消费者服务器挂了，消息也不会有超时；即使一个消息需要非常长的时间处理，也不会导致消息超时。这样消息永远不会从 RabbitMQ 服务器中删除。只有当消费者正确的发送 ACK 确认反馈，RabbitMQ 确认收到后，消息才会从 RabbitMQ 服务器的数据中删除。 消息的 ACK 确认机制默认是打开的。</p><p>忘记通过 basicAck 返回确认信息是常见的错误。这个错误非常严重，将导致消费者客户端退出或者关闭后，消息会被退回 RabbitMQ 服务器，这会使 RabbitMQ 服务器内存爆满，而且 RabbitMQ 也不会主动删除这些被退回的消息。 如果要监控这种错误，可以使用 <code>rabbitmqctl messages_unacknowledged</code> 命令打印出出相关的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; RabbitMQ 入门总结 &lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 线程总结(十四)</title>
    <link href="yanchongsheng.github.io/2018/08/28/Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/08/28/Java线程总结(十四)/</id>
    <published>2018-08-28T11:40:41.000Z</published>
    <updated>2018-08-28T12:49:12.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 线程总结(十四) —— CompletionService </blockquote><a id="more"></a><p>1、在异步任务程序中，一种常见的场景是，主线程提交多个异步任务，然后希望有任务完成就处理结果，并且按任务完成顺序逐个处理，对于这种场景，Java 并发包提供了一个方便的方法，使用 CompletionService，这是一个接口，它的实现类是 ExecutorCompletionService。</p><p>2、与 ExecutorService 一样，CompletionService 也可以提交异步任务，它的不同是，它可以按任务完成顺序获取结果，其具体定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompletionService</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span></span>;</span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(Runnable task, V result)</span></span>;</span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>submit 方法与 ExecutorService 是一样的，多了 take 和 poll 方法，它们都是获取下一个完成任务的结果，take() 会阻塞等待，poll() 会立即返回，如果没有已完成的任务，返回 null，带时间参数的 poll 方法会最多等待限定的时间。</p><p>2、CompletionService 的主要实现类是 ExecutorCompletionService，它依赖于一个 Executor 完成实际的任务提交，而自己主要负责结果的排队和处理。它的构造方法有两个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span></span></span><br></pre></td></tr></table></figure></p><p>至少需要一个 Executor 参数，可以提供一个 BlockingQueue 参数，用作完成任务的队列，没有提供的话，ExecutorCompletionService 内部会创建一个 LinkedBlockingQueue。</p><p>3、ExecutorCompletionService 是怎么让结果有序处理的呢？<br>因为它有一个额外的队列，每个任务完成之后，都会将代表结果的 Future 入队。在 FutureTask 中，任务完成后，不管是正常完成、异常结束、还是被取消，都会调用 finishCompletion 方法，而该方法会调用一个 done 方法 <code>protected void done() { }</code> 该方法的实现为空，但它是一个 protected 方法，子类可以重写该方法。ExecutorCompletionService 的内部类 QueueingFuture 中重写了该方法。</p><p>在 ExecutorCompletionService 中，提交的任务类型不是一般的 FutureTask，而是一个子类 QueueingFuture<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class="line">    <span class="comment">// 注意 QueueingFuture</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> QueueingFuture(f));</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------</span><br><span class="line"><span class="comment">// ExecutorCompletionService 类中的私有实例变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">        <span class="keyword">super</span>(task, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类重写了 done 方法，在任务完成时将结果加入到完成队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------</span><br></pre></td></tr></table></figure></p><p>而 ExecutorCompletionService 的 take/poll 方法就是从该队列获取结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、AbstractExecutorService 的 invokeAny 的实现，就利用了 ExecutorCompletionService，它的基本思路是，提交任务后，通过 take 方法获取结果，获取到第一个有效结果后，取消所有其他任务。</p><p>5、CompletionService 它通过一个额外的结果队列，方便了对于多个异步任务结果的处理。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/swiftma/p/6691235.html" target="_blank" rel="noopener">Java编程的逻辑 - 方便的 CompletionService</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 线程总结(十四) —— CompletionService &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java线程总结(十三)</title>
    <link href="yanchongsheng.github.io/2018/08/27/Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%B8%89)/"/>
    <id>yanchongsheng.github.io/2018/08/27/Java线程总结(十三)/</id>
    <published>2018-08-27T11:32:28.000Z</published>
    <updated>2018-08-27T14:10:15.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 线程总结(十三) —— 线程池 </blockquote><a id="more"></a><p>1、Java 并发包中的任务执行服务的主要实现机制是线程池。线程池，顾名思义，就是一个线程的池子，里面有若干线程，它们的目的就是执行提交给线程池的任务，执行完一个任务后不会退出，而是继续等待或执行新任务。<strong>线程池主要由两个概念组成，一个是任务队列，另一个是工作者线程，工作者线程主体就是一个循环，循环从队列中接受任务并执行，任务队列保存待执行的任务。</strong></p><p>线程池的优点：</p><blockquote><ul><li>它可以重用线程，避免线程创建的开销。</li><li>在任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争，确保任务有序完成。</li></ul></blockquote><p>Java 并发包中线程池的实现类是 ThreadPoolExecutor，它继承自 AbstractExecutorService，实现了 ExecutorService。</p><p>2、ThreadPoolExecutor 构造方法中的参数解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程池的大小主要与四个参数有关：</p><blockquote><ul><li><p>corePoolSize：线程池中核心线程个数。不过，这并不是说，一开始就创建这么多线程，刚创建一个线程池后，实际上并不会创建任何线程。一般情况下，有新任务到来的时候，如果当前线程个数小于 corePoolSiz，就会创建一个新线程来执行该任务，需要说明的是，即使其他线程现在也是空闲的，也会创建新线程。不过，如果线程个数大于等于 corePoolSiz，那就不会立即创建新线程了，它会先尝试排队，需要强调的是，它是「尝试」排队，而不是「阻塞等待」入队，如果队列满了或其他原因不能立即入队，它就不会排队，而是检查线程个数是否达到了 maximumPoolSize，如果没有，就会继续创建线程，直到线程数达到 maximumPoolSize。</p></li><li><p>maximumPoolSize：线程池中允许的最大线程数。</p></li><li><p>keepAliveTime：当实际线程数大于核心线程数时，此为终止前，多余的空闲线程，等待新任务的最长时间。keepAliveTime 的目的是为了释放多余的线程资源，它表示，当线程池中的线程个数大于 corePoolSize 时，额外空闲线程的存活时间，也就是说，一个非核心线程，在空闲等待新任务时，会有一个最长等待时间，即 keepAliveTime，如果到了时间还是没有新任务，就会被终止。如果该值为 0，表示所有线程都不会超时终止。</p></li><li><p>unit：keepAliveTime 参数的时间单位。</p></li></ul></blockquote><p>3、队列之线程参数「BlockingQueue<runnable> workQueue」<br>ThreadPoolExecutor 要求的队列类型是阻塞队列 BlockingQueue：</runnable></p><blockquote><ul><li>LinkedBlockingQueue：基于链表的阻塞队列，可以指定最大长度，但默认是无界的。</li><li>ArrayBlockingQueue：基于数组的有界阻塞队列。</li><li>PriorityBlockingQueue：基于堆的无界阻塞优先级队列。</li><li>SynchronousQueue：没有实际存储空间的同步阻塞队列。</li></ul></blockquote><p>如果用的是无界队列，需要强调的是，线程个数最多只能达到 corePoolSize，到达 corePoolSize 后，新的任务总会排队，参数 maximumPoolSize 也就没有意义了。</p><p>对于 SynchronousQueue，它没有实际存储元素的空间，当尝试排队时，只有正好有空闲线程在等待接受任务时，才会入队成功，否则，总是会创建新线程，直到达到 maximumPoolSize。</p><p>4、任务拒绝策略之线程参数「RejectedExecutionHandler handler」<br>如果队列有界，且 maximumPoolSize 有限，则当队列排满，线程个数也达到了 maximumPoolSize，这时，新任务来了，就会触发线程池的任务拒绝策略。默认情况下，提交任务的方法如 execute/submit/invokeAll 等会抛出异常，类型为 RejectedExecutionException。拒绝策略是可以自定义的，ThreadPoolExecutor 实现了四种处理方式：</p><blockquote><ol><li>ThreadPoolExecutor.AbortPolicy：这就是默认的方式，抛出异常。</li><li>ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛异常，也不执行。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：将等待时间最长的任务扔掉，然后自己排队。</li><li>ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，而不是交给线程池中的线程执行。</li></ol></blockquote><p>它们都是 ThreadPoolExecutor 的 public 静态内部类，都实现了 RejectedExecutionHandler 接口，RejectedExecutionHandler 接口定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当线程池不能接受任务时，调用其拒绝策略的 rejectedExecution 方法。</p><p>ThreadPoolExecutor 中的拒绝策略可以在构造方法中进行指定，也可以通过如下方法进行指定：<code>public void setRejectedExecutionHandler(RejectedExecutionHandler handler)</code>。</p><p>默认的 RejectedExecutionHandler 是一个 AbortPolicy 实例 <code>private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();</code> 而 AbortPolicy 的 rejectedExecution 实现就是抛出异常。</p><p><strong>拒绝策略只有在队列有界，且 maximumPoolSize 有限的情况下才会触发。 如果队列无界，服务不了的任务总是会排队，请求处理队列可能会消耗非常大的内存，甚至引发内存不够的异常。如果队列有界但 maximumPoolSize 无限，可能会创建过多的线程，占满 CPU 和内存，使得任何任务都难以完成。</strong> 在任务量非常大的场景中，让拒绝策略有机会执行是保证系统稳定运行很重要的方面。</p><p>5、线程工厂之线程参数「ThreadFactory threadFactory」<br>线程池还可以接受一个参数 ThreadFactory，它是一个接口，定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadFactory 接口根据 Runnable 创建一个 Thread，ThreadPoolExecutor 的默认实现是 Executors 类中的静态内部类 DefaultThreadFactory，主要就是创建一个线程，给线程设置一个名称，设置 daemon 属性为 false，设置线程优先级为标准默认优先级，线程名称的格式为： pool-&lt;线程池编号&gt;-thread-&lt;线程编号&gt;。</p><p>6、关于核心线程的特殊配置<br>线程个数小于等于 corePoolSize 时，我们称这些线程为核心线程，默认情况下：</p><blockquote><ul><li>核心线程不会预先创建，只有当有任务时才会创建。</li><li>核心线程不会因为空闲而被终止，keepAliveTime参数不适用于它。</li></ul></blockquote><p>ThreadPoolExecutor 有如下方法，可以改变这个默认行为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预先创建所有的核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个核心线程，如果所有核心线程都已创建，返回 false</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果参数为 true，则 keepAliveTime 参数也适用于核心线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span></span></span><br></pre></td></tr></table></figure></p><p>7、工厂类 Executors<br>类 Executors 提供了一些静态工厂方法，可以方便的创建一些预配置的线程池，主要方法有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newSingleThreadExecutor 只使用一个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止，该线程顺序执行所有任务。该线程池适用于需要确保所有任务被顺序执行的场合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="comment">// newFixedThreadPool 使用固定数目的 n 个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止。和 newSingleThreadExecutor 一样，由于是无界队列，如果排队任务过多，可能会消耗非常大的内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"><span class="comment">// newCachedThreadPool 的 corePoolSize 为 0，maximumPoolSize 为 Integer.MAX_VALUE，keepAliveTime 是 60 秒，队列为 SynchronousQueue</span></span><br><span class="line"><span class="comment">// 当新任务到来时，如果正好有空闲线程在等待任务，则其中一个空闲线程接受该任务，否则就总是创建一个新线程，创建的总线程个数不受限制，对任一空闲线程，如果60秒内没有新任务，就终止</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实际中，应该使用 newFixedThreadPool 还是 newCachedThreadPool 呢？</strong><br>在系统负载很高的情况下，newFixedThreadPool 可以通过队列使新任务排队，保证有足够的资源处理实际的任务，而 newCachedThreadPool 会为每个任务创建一个线程，导致创建过多的线程竞争 CPU 和内存资源，使得任何实际任务都难以完成，这时，newFixedThreadPool 更为适用。</p><p>如果系统负载不太高，单个任务的执行时间也比较短，newCachedThreadPool 的效率可能更高，因为任务可以不经排队，直接交给某一个空闲线程。</p><p>在系统负载可能极高的情况下，两者都不是好的选择，newFixedThreadPool 的问题是队列过长，而 newCachedThreadPool 的问题是线程过多，这时，应根据具体情况自定义 ThreadPoolExecutor，传递合适的参数。</p><p>8、线程的死锁<br>关于提交给线程池的任务，需要特别注意一种情况，就是任务之间有依赖，这种情况可能会出现死锁。<strong>对于相互依赖的任务，需要特别注意，避免出现死锁。</strong></p><p>避免死锁的策略：</p><blockquote><ul><li>替换 newFixedThreadPool 为 newCachedThreadPool，让创建线程不再受限。</li><li>使用 SynchronousQueue，它可以避免死锁。因为对于普通队列，入队只是把任务放到了队列中，而对于 SynchronousQueue 来说，入队成功就意味着已有线程接受处理，如果入队失败，可以创建更多线程直到 maximumPoolSize，如果达到了 maximumPoolSize，会触发拒绝机制，不管怎么样，都不会死锁。</li></ul></blockquote><p>9、ThreadPoolExecutor 实现了生产者/消费者模式，工作者线程就是消费者，任务提交者就是生产者，线程池自己维护任务队列。当我们碰到类似生产者/消费者问题时，应该优先考虑直接使用线程池，而非重新发明轮子，自己管理和维护消费者线程及任务队列。</p><p>10、小结：ThreadPoolExecutor 参数 corePoolSize, maximumPoolSize, keepAliveTime, unit 用于控制线程池中线程的个数，workQueue 表示任务队列，threadFactory 用于对创建的线程进行一些配置，handler 表示任务拒绝策略。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/swiftma/p/6691017.html" target="_blank" rel="noopener">Java编程的逻辑 - 线程池</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 线程总结(十三) —— 线程池 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程总结(十二)</title>
    <link href="yanchongsheng.github.io/2018/08/26/Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%BA%8C)/"/>
    <id>yanchongsheng.github.io/2018/08/26/Java线程总结(十二)/</id>
    <published>2018-08-26T14:38:19.000Z</published>
    <updated>2018-08-27T11:31:37.491Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 线程总结(十二) —— 异步任务执行服务 </blockquote><a id="more"></a><p>1、Java 并发包提供了一套框架，大大简化了<strong>执行异步任务所需的开发</strong>。在之前的学习中，线程 Thread 既表示要执行的任务，又表示执行的机制，<strong>而这套框架引入了一个「执行服务」的概念，它将「任务的提交」和「任务的执行」相分离，「执行服务」封装了任务执行的细节，对于任务提交者而言，它可以关注于任务本身，如提交任务、获取结果、取消任务，而不需要关注任务执行的细节，如线程创建、任务调度、线程关闭等。</strong></p><p>2、任务执行服务涉及的基本接口：</p><blockquote><ul><li>Runnable 和 Callable：表示要执行的异步任务。</li><li>Executor 和 ExecutorService：表示执行服务。</li><li>Future：表示异步任务的结果。</li></ul></blockquote><p>Runnable 和 Callable 都表示任务，Runnable 没有返回结果，而 Callable 有，Runnable 不会抛出异常，而 Callable 会。</p><p>Executor 表示最简单的执行服务，其定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在未来某个时间执行给定的任务 Runnable，没有返回结果。该任务可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。</p><p>ExecutorService 扩展了 Executor，定义了更多服务，基本方法有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这三个 submit 都表示提交一个任务，返回值类型都是 Future，返回后，只是表示任务已提交，不代表已执行，通过 Future 可以查询异步任务的状态、获取最终结果、取消任务等</span></span><br><span class="line">    <span class="comment">// 对于 Callable，任务最终有个返回值，而对于 Runnable 是没有返回值的</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交 Runnable 的方法可以同时提供一个结果，在异步任务结束时返回</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步任务的最终返回值为 null</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown 和 shutdownNow 表示关闭任务执行服务</span></span><br><span class="line">    <span class="comment">// shutdown 表示不再接受新任务，但已提交的任务会继续执行，即使任务还未开始执行</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdownNow 不仅不接受新任务，已提交但尚未执行的任务会被终止，对于正在执行的任务，一般会调用线程的 interrupt 方法尝试中断，不过，线程可能不响应中断，shutdownNow 会返回已提交但尚未执行的任务列表</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown 和 shutdownNow 不会阻塞等待，它们返回后不代表所有任务都已结束，不过 isShutdown 方法会返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用者可以通过 awaitTermination 等待所有任务结束，它可以限定等待的时间，如果超时前所有任务都结束了，即 isTerminated 方法返回 true，则返回 true，否则返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExecutorService 有两组批量提交任务的方法，invokeAll 和 invokeAny，它们都有两个版本，其中一个限定等待时间</span></span><br><span class="line">    <span class="comment">// invokeAll 等待所有任务完成，返回的 Future 列表中，每个 Future 的 isDone 方法都返回 true，不过 isDone 为 true 不代表任务就执行成功了，可能是被取消了，invokeAll 可以指定等待时间，如果超时后有的任务没完成，就会被取消</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invokeAny 只要有一个任务在限时内成功返回了，它就会返回该任务的结果，其他任务会被取消，如果没有任务能在限时内成功返回，抛出 TimeoutException，如果限时内所有任务都结束了，但都发生了异常，抛出 ExecutionException</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 ExecutorService 编写并发异步任务的代码就像写顺序程序一样，不用关心线程的创建和协调，只需要提交任务、处理结果就可以了，大大简化了开发工作。</p><p>3、Future 接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Future 表示异步计算的结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// cancel 用于取消异步任务，如果任务已完成、或已经取消、或由于某种原因不能取消，cancel 返回 false，否则返回 true</span></span><br><span class="line">    <span class="comment">// 如果任务还未开始或已经结束，则不再运行</span></span><br><span class="line">    <span class="comment">// 如果任务已经在运行，则不一定能取消，参数 mayInterruptIfRunning 表示，如果任务正在执行，是否调用 interrupt 方法中断线程，如果为 false 就不会，如果为 true，就会尝试中断线程，interrupt() 不一定能取消线程</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isDone 和 isCancelled 用于查询任务状态</span></span><br><span class="line">    <span class="comment">// isCancelled 表示任务是否被取消，只要 cancel 方法返回了 true，随后的 isCancelled 方法都会返回 true，即使执行任务的线程还未真正结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isDone 表示任务是否结束，不管什么原因都算，可能是任务正常结束、可能是任务抛出了异常、也可能是任务被取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 用于返回异步任务最终的结果，如果任务还未执行完成，会阻塞等待</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以限定阻塞等待的时间，如果超时任务还未结束，会抛出 TimeoutException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>get() 方法，任务最终大概有三个结果：</p><blockquote><ol><li>正常完成，get 方法会返回其执行结果，如果任务是 Runnable 且没有提供结果，返回 null。</li><li>任务执行抛出了异常，get 方法会将异常包装为 ExecutionException 重新抛出，通过异常的 getCause 方法可以获取原异常。</li><li>任务被取消了，get 方法会抛出异常 CancellationException。</li></ol></blockquote><p>如果调用 get 方法的线程被中断了，get 方法会抛出 InterruptedException。</p><p><strong>Future 是一个重要的概念，是实现「任务的提交」与「任务的执行」相分离的关键，是其中的纽带，任务提交者和任务执行服务通过它隔离各自的关注点，同时进行协作。</strong></p><p>4、ExecutorService 的主要实现类是 ThreadPoolExecutor，它是基于线程池实现的。ExecutorService 有一个抽象实现类 AbstractExecutorService，接下来简要分析下 AbstractExecutorService 的原理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService 提供了 submit、invokeAll、invokeAny 的默认实现，子类只需要实现如下方法即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 除了 execute 方法，其他方法都与执行服务的生命周期管理有关</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="comment">// submit/invokeAll/invokeAny 最终都会调用 execute，execute 决定了到底如何执行任务</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>5、AbstractExecutorService 抽象类中 submit() 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 调用 newTaskFor 生成了一个 RunnableFuture，RunnableFuture 是一个接口，既扩展了 Runnable，又扩展了 Future，没有定义新方法</span></span><br><span class="line">    <span class="comment">// 作为 Runnable，它表示要执行的任务，传递给 execute 方法进行执行</span></span><br><span class="line">    <span class="comment">// 作为 Future，它又表示任务执行的异步结果</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line">----------------------</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 就是创建了一个 FutureTask 对象，FutureTask 实现了 RunnableFuture 接口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line">----------------------</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 FutureTask 接受的是一个 Runnable 对象，它会调用 Executors.callable 转换为 Callable 对象</span></span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// RunnableFuture 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、FutureTask 源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Future 的主要实现类是 FutureTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 表示状态，可取值如下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;<span class="comment">// 刚开始的状态，或任务在运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;<span class="comment">// 临时状态，任务即将结束，在设置结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;<span class="comment">// 任务正常执行完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;<span class="comment">// 任务执行抛出异常结束</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;<span class="comment">// 任务被取消</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;<span class="comment">// 任务在被中断</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;<span class="comment">// 任务被中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示待执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">// 表示最终的执行结果或异常</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line">    <span class="comment">// 表示运行任务的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    <span class="comment">// 单向链表表示等待任务执行结果的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FutureTask 的构造方法会初始化 callable 和状态，如果 FutureTask 接受的是一个 Runnable 对象，它会调用 Executors.callable 转换为 Callable 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行服务会使用一个线程执行 FutureTask 的 run 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FutureTask 的 run() 方法的基本逻辑为：</p><blockquote><ul><li>调用 callable 的 call 方法，捕获任何异常。</li><li>如果正常执行完成，调用 set 设置结果，保存到 outcome。</li><li>如果执行过程发生异常，调用 setException 设置异常，异常也是保存到 outcome，但状态不一样。</li><li>set 和 setException 除了设置结果，修改状态外，还会调用 finishCompletion ，它会唤醒所有等待结果的线程。</li></ul></blockquote><p>7、FutureTask 中 get() 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">// 如果任务还未执行完毕，就等待</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="comment">// 最后调用 report 报告结果, report 根据状态返回结果或抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8、FutureTask 中 cancel() 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务已结束或取消，返回 false</span></span><br><span class="line">    <span class="comment">// 如果 mayInterruptIfRunning 为 false，设置状态为 CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="comment">// 如果 mayInterruptIfRunning 为 true，调用 interrupt 中断线程，设置状态为 INTERRUPTED</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 finishCompletion 唤醒所有等待结果的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9、<strong>Java 并发包中任务执行服务的基本概念和原理，该服务体现了并发异步开发中「关注点分离」的思想，使用者只需要通过 ExecutorService 提交任务，通过 Future 操作任务和结果即可，不需要关注线程创建和协调的细节。</strong></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/swiftma/p/6597018.html" target="_blank" rel="noopener">Java编程的逻辑 - 异步任务执行服务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 线程总结(十二) —— 异步任务执行服务 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程总结(十一)</title>
    <link href="yanchongsheng.github.io/2018/08/26/Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%B8%80)/"/>
    <id>yanchongsheng.github.io/2018/08/26/Java线程总结(十一)/</id>
    <published>2018-08-26T11:38:13.000Z</published>
    <updated>2018-08-27T01:41:03.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 线程总结(十一) —— 各种队列 </blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 线程总结(十一) —— 各种队列 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java容器总结(四)</title>
    <link href="yanchongsheng.github.io/2018/08/25/Java%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>yanchongsheng.github.io/2018/08/25/Java容器总结(四)/</id>
    <published>2018-08-25T13:33:22.000Z</published>
    <updated>2018-08-26T14:07:29.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 容器总结(四) —— HashSet </blockquote><a id="more"></a><p>1、HashSet 由两个单词组成，Hash 和 Set，Set 表示接口，实现 Set 接口有多种方式，HashSet 实现的方式利用了 Hash。Set 表示的是没有重复元素、<strong>且不保证顺序的容器接口，它扩展了 Collection，但没有定义任何新的方法</strong>，不过，对于其中的一些方法，它有自己的规范。</p><p>2、Set 接口定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">// 迭代遍历时，不要求元素之间有特别的顺序</span></span><br><span class="line">    <span class="comment">// HashSet 的实现就是没有顺序，但有的 Set 实现可能会有特定的顺序，比如 TreeSet</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="comment">// 如果集合中已经存在相同元素了，则不会改变集合，直接返回 false，只有不存在时，才会添加，并返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="comment">// 重复的元素不添加，不重复的添加，如果集合有变化，返回 true，没变化返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、注意：HashSet 要求元素重写 hashCode 和 equals 方法，且对两个对象，equals 相同，则 hashCode 也必须相同，如果元素是自定义的类，需要注意这一点。因为 HashSet 就是依靠 hashCode 和 equals 方法来判断对象是否相等的，所以使用 HashSet 的时候一定要注意重写这两个方法。</p><p>4、HashSet 内部组成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">      <span class="comment">// HashSet 内部是用 HashMap 实现的，它内部有一个 HashMap 实例变量    </span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">      <span class="comment">// HashSet 相当于只有键，值都是相同的固定值 PRESENT</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5、HashSet 的构造方法，主要就是调用了对应的 HashMap 的构造方法。</p><p>6、add() 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回值为 boolean 类型</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是调用 map 的 put 方法，元素 e 用于键，值就是那个固定值 PRESENT，put 返回 null 表示原来没有对应的键，添加成功了。HashMap 中一个键只会保存一份，所以重复添加 HashMap 不会变化。</p><p>7、remove() 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 map 的 remove 方法，返回值为 PRESENT 表示原来有对应的键且删除成功了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8、迭代器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 map 的 keySet 的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9、HashSet 特点分析<br>HashSet 实现了 Set 接口，内部是通过 HashMap 实现的，这决定了它有如下特点：</p><blockquote><ul><li>没有重复元素。</li><li>可以高效的添加、删除元素、判断元素是否存在，效率都为 O(1)。</li><li>没有顺序。</li></ul></blockquote><p>10、HashSet 实现了 Set 接口，不含重复元素，内部实现利用了 HashMap，可以方便高效地实现如去重、集合运算等功能。HashSet 没有顺序，如果要保持添加的顺序，可以使用 HashSet 的一个子类 LinkedHashSet。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/swiftma/p/5958979.html" target="_blank" rel="noopener">Java编程的逻辑 - 剖析 HashSet</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 容器总结(四) —— HashSet &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程总结(十)</title>
    <link href="yanchongsheng.github.io/2018/08/24/Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81)/"/>
    <id>yanchongsheng.github.io/2018/08/24/Java线程总结(十)/</id>
    <published>2018-08-24T13:20:57.000Z</published>
    <updated>2018-08-24T14:13:55.258Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 线程总结(十) —— 基于 SkipList 的 Map 和 Set </blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 线程总结(十) —— 基于 SkipList 的 Map 和 Set &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程总结(九)</title>
    <link href="yanchongsheng.github.io/2018/08/24/Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B9%9D)/"/>
    <id>yanchongsheng.github.io/2018/08/24/Java线程总结(九)/</id>
    <published>2018-08-24T12:39:09.000Z</published>
    <updated>2018-08-24T08:52:13.340Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 线程总结(九) —— ConcurrentHashMap </blockquote><a id="more"></a><p>1、ConcurrentHashMap，它是 HashMap 的并发版本，与 HashMap 相比，它有如下特点：</p><blockquote><ul><li>并发安全。</li><li>直接支持一些原子复合操作。</li><li>支持高并发、读操作完全并行、写操作支持一定程度的并行。</li><li>与同步容器 Collections.synchronizedMap 相比，迭代不用加锁，不会抛出 ConcurrentModificationException。</li><li>弱一致性。</li></ul></blockquote><p>2、HashMap 不是并发安全的，在并发更新的情况下，HashMap 的链表结构可能形成环，出现死循环，占满 CPU。死循环出现在多个线程同时扩容哈希表的时候，不是同时更新一个链表的时候，那种情况可能会出现更新丢失，但不会死循环。具体参考 <a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">Java HashMap 的死循环</a>。</p><p>使用 Collections.synchronizedMap 方法可以生成一个同步容器，可以避免该问题。在 Java 中，HashMap 还有一个同步版本 Hashtable，它与使用 synchronizedMap 生成的 Map 基本是一样的，也是在每个方法调用上加了 synchronized。然而同步容器存在以下问题：</p><blockquote><ul><li>每个方法都需要同步，支持的并发度比较低。</li><li>对于迭代和复合操作，需要调用方加锁，使用比较麻烦，且容易忘记。</li></ul></blockquote><p>3、ConcurrentHashMap 没有以上那些问题，它同样实现了 Map 接口，也是基于哈希表实现的。除了 Map 接口，ConcurrentHashMap 还实现了一个接口 ConcurrentMap，接口定义了一些条件更新操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 条件更新，如果 Map 中没有 key，设置 key 的值为 value，返回原来 key 对应的值，如果没有，返回 null</span></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">    <span class="comment">// 条件删除，如果 Map 中有 key，且对应的值为 value，则删除，如果删除了，返回 true，否则 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line">    <span class="comment">// 条件替换，如果 Map 中有 key，且对应的值为 oldValue，则替换为 newValue，如果替换了，返回 ture，否则 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</span><br><span class="line">    <span class="comment">// 条件替换，如果 Map 中有 key，则替换值为 value，返回原来 key 对应的值，如果原来没有，返回 null</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果使用同步容器，调用方必须加锁，而 ConcurrentMap 将它们实现为了原子操作。实际上，使用 ConcurrentMap，调用方也没有办法进行加锁，它没有暴露锁接口，也不使用 synchronized。</p><p>4、ConcurrentHashMap 是为高并发设计的，其主要思路有两点：</p><blockquote><ul><li>分段锁  </li><li>读不需要锁  </li></ul></blockquote><p>同步容器使用 synchronized，所有方法，竞争同一个锁，而 ConcurrentHashMap 采用分段锁技术，将数据分为多个段，而每个段有一个独立的锁，每一个段相当于一个独立的哈希表，分段的依据也是哈希值，无论是保存键值对还是根据键查找，都先根据键的哈希值映射到段，再在段对应的哈希表上进行操作。</p><p>采用分段锁，可以大大提高并发度，多个段之间可以并行读写。默认情况下，段是 16个，不过，这个数字可以通过构造方法进行设置:<br><code>public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</code><br>concurrencyLevel 表示估计的并行更新的线程个数，ConcurrentHashMap 会将该数转换为2的整数次幂，比如 14 转换为 16，25 转换为 32。</p><p>在对每个段的数据进行读写时，<strong>ConcurrentHashMap 也不是简单的使用锁进行同步，内部使用了 CAS、对一些写采用原子方式，实现比较复杂</strong>，实现的效果是，<strong>对于写操作，需要获取锁，不能并行，但是读操作可以，多个读可以并行，写的同时也可以读</strong>，这使得 ConcurrentHashMap 的并行度远远大于同步容器。</p><p>5、使用同步容器，在迭代中需要加锁，否则可能会抛出 ConcurrentModificationException。ConcurrentHashMap 没有这个问题，在迭代器创建后，在迭代过程中，如果另一个线程对容器进行了修改，迭代会继续，不会抛出异常。</p><p>但是迭代器是否会反映别的线程的修改，就需要视情况而定了。这是因为 ConcurrentHashMap 的弱一致性。类似的情况还会出现在 ConcurrentHashMap 的另一个方法：<code>public void putAll(Map&lt;? extends K, ? extends V&gt; m)</code> 该方法并非原子操作，而是调用 put 方法逐个元素进行添加的，在该方法没有结束的时候，部分修改效果就会体现出来。</p><p>6、ConcurrentHashMap 的弱一致性<br><strong>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</strong></p><p>7、ConcurrentHashMap 通过分段锁、CAS 等技术实现了高并发；实现了 ConcurrentMap 接口，支持原子条件更新操作；不会抛出 ConcurrentModificationException，实现了弱一致性。</p><p>8、Java 中没有并发版的 HashSet，但可以通过 Collections.newSetFromMap 方法基于 ConcurrentHashMap 构建一个。HashMap/HashSet 基于哈希，不能对元素排序，对应的可排序的容器类是 TreeMap/TreeSet，并发包中可排序的对应版本不是基于树，而是基于 Skip List（跳跃表）的，类分别是 ConcurrentSkipListMap 和 ConcurrentSkipListSet。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/swiftma/p/6557685.html" target="_blank" rel="noopener">Java编程的逻辑 - ConcurrentHashMap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 线程总结(九) —— ConcurrentHashMap &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程总结(八)</title>
    <link href="yanchongsheng.github.io/2018/08/24/Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%85%AB)/"/>
    <id>yanchongsheng.github.io/2018/08/24/Java线程总结(八)/</id>
    <published>2018-08-24T11:05:35.000Z</published>
    <updated>2018-08-24T08:52:13.315Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 线程总结(八) —— 写时拷贝的 List 和 Set </blockquote><a id="more"></a><p>1、Java 并发包中的容器类。注意这个是<strong>并发容器</strong>，要跟 Collections 返回的<strong>同步容器</strong>区分开。这里主要学习 CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个类，<strong>Copy-On-Write，即写时拷贝或写时复制，这是解决并发问题的一种重要思路。</strong></p><p>2、CopyOnWriteArrayList 基本用法<br>CopyOnWriteArrayList 实现了 List 接口，它的用法与其他 List 如 ArrayList 基本是一样的，它的区别是：  </p><blockquote><ul><li>它是线程安全的，可以被多个线程并发访问。</li><li>它的迭代器不支持修改操作，但也不会抛出 ConcurrentModificationException。</li><li>它直接以原子方式支持一些复合操作。</li></ul></blockquote><p>3、基于 synchronized 的同步容器迭代时，需要对整个列表对象加锁，否则会抛出 ConcurrentModificationException。但 CopyOnWriteArrayList 没有这个问题，迭代时不需要加锁。因为 CopyOnWriteArrayList 的迭代器根本不支持修改，这也是 CopyOnWriteArrayList 思想的本质，写时拷贝，<strong>CopyOnWriteArrayList 有点像 String，一旦创建，内容不可变，变的只是引用。</strong></p><p>在 <strong>JDK 1.8</strong> 之前的实现中，CopyOnWriteArrayList 的迭代器不支持修改操作，也不支持一些依赖迭代器修改方法的操作，比如 Collections 的 sort 方法，因为 Collections.sort 方法依赖迭代器的 set 方法。但是在 JDK 1.8 中，List 接口增加了 sort 方法，并提供了默认实现，而 CopyOnWriteArrayList 重写了该实现，从以下其源码可以看出，加锁了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, elements.length);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E[] es = (E[])newElements;</span><br><span class="line">        Arrays.sort(es, c);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于 synchronized 的同步容器的一个问题是复合操作，比如先检查再更新，也需要调用方加锁，而 CopyOnWriteArrayList 直接支持两个原子方法，其本质都是加锁了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在才添加，如果添加了，返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 批量添加 c 中的非重复元素，不存在才添加，返回实际添加的个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addAllAbsent</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure></p><p>4、CopyOnWriteArrayList 的基本原理<br><strong>CopyOnWriteArrayList 的内部也是一个数组，但这个数组是以原子方式被整体更新的。每次修改操作，都会新建一个数组，复制原数组的内容到新数组，在新数组上进行需要的修改，然后以原子方式设置内部的数组引用，这就是写时拷贝。</strong></p><p>所有的读操作，都是先拿到当前引用的数组，然后直接访问该数组，在读的过程中，可能内部的数组引用已经被修改了，但不会影响读操作，它依旧访问原数组内容。即数组内容是只读的，写操作都是通过新建数组，然后原子性的修改数组引用来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部数组，注意，它声明为了 volatile，这是必需的，保证内存可见性，写操作更改了之后，读操作能看到。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 默认构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 CopyOnWriteArrayList 中，读不需要锁，可以并行，读和写也可以并行，但多个线程不能同时写，每个写操作都需要先获取锁，CopyOnWriteArrayList 内部使用 ReentrantLock。</p><p>5、add() 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 拷贝到一个新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 调用 setArray 原子性的修改内部数组引用</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解析为什么 add() 方法需要加锁？内部数组 array 是被 volatile 关键字修饰的，其内存可见性是不存在问题的，但是却存在另一个问题 —— 竞态条件，所以通过加锁来解决并发写时的竞态条件问题。此处加锁的目的就是为了解决竞态条件问题。</p><p>6、indexOf() 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, elements, <span class="number">0</span>, elements.length);</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------</span><br><span class="line"><span class="comment">// 这个 indexOf 方法访问的所有数据都是通过参数传递进来的，数组内容也不会被修改，不存在并发问题</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, Object[] elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> index, <span class="keyword">int</span> fence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7、iterator() 迭代器方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// COWIterator 是内部类，传递给它的是不变的数组，它也只是读该数组，不支持修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="comment">// final 修饰，表明数组的引用不可变，而写时拷贝的特性，表明数组一旦被创建其内容不会再变，所以该数组是不可变的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8、CopyOnWriteArrayList 小结<br>每次修改都创建一个新数组，然后复制所有内容，如果数组比较大，修改操作又比较频繁，CopyOnWriteArrayList 的性能是很低的。<strong>CopyOnWriteArrayList 不适用于数组很大，且修改频繁的场景。它是以优化读操作为目标的，读不需要同步，性能很高，但在优化读的同时就牺牲了写的性能。</strong></p><p>保证线程安全的两种思路，一种是锁，使用 synchronized 或 ReentrantLock，另外一种是循环 CAS，<strong>写时拷贝体现了保证线程安全的另一种思路</strong>。对于绝大部分访问都是读，且有大量并发线程要求读，只有个别线程进行写，且只是偶尔写的场合，这种写时拷贝就是一种很好的解决方案。</p><p><strong>写时拷贝是一种重要的思维，用于各种计算机程序中，比如经常用于操作系统内部的进程管理和内存管理。</strong></p><p>9、CopyOnWriteArraySet 实现了 Set 接口，不包含重复元素，内部，它是通过 CopyOnWriteArrayList 实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部实现依赖 CopyOnWriteArrayList      </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了 CopyOnWriteArrayList 的 addIfAbsent 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于 CopyOnWriteArraySet 是基于 CopyOnWriteArrayList 实现的，所以与 Set 的实现类如 HashSet/TreeSet 相比，它的性能比较低，<strong>不适用于元素个数特别多的集合</strong>。如果元素个数比较多，可以考虑 ConcurrentHashMap 或  ConcurrentSkipListSet。</p><p>ConcurrentHashMap 与 HashMap 类似，适用于不要求排序的场景，ConcurrentSkipListSet 与 TreeSet 类似，适用于要求排序的场景。Java 并发包中没有与 HashSet 对应的并发容器，但可以很容易的基于 ConcurrentHashMap 构建一个，利用 Collections.newSetFromMap 方法即可。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/swiftma/p/6546505.html" target="_blank" rel="noopener">Java 编程的逻辑 - 写时拷贝的 List 和 Set</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 线程总结(八) —— 写时拷贝的 List 和 Set &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程总结(七)</title>
    <link href="yanchongsheng.github.io/2018/08/23/Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%83)/"/>
    <id>yanchongsheng.github.io/2018/08/23/Java线程总结(七)/</id>
    <published>2018-08-23T12:05:22.000Z</published>
    <updated>2018-08-24T08:52:13.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"> Java 线程总结(七) —— 显式条件 </blockquote><a id="more"></a><p>1、显式条件也可以被称做条件变量、条件队列、或条件。锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与 synchronzied 相对应，而<strong>显式条件与 wait/notify 相对应</strong>。wait/notify 与 synchronized 配合使用，显式条件与显式锁配合使用。条件与锁相关联，创建条件变量需要通过显式锁，Lock 接口定义了创建方法：<code>Condition newCondition();</code>。</p><p>2、Condition 接口表示条件变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 等待时间也是相对时间，但参数单位是纳秒，返回值是 nanosTimeout 减去实际等待的时间，即剩余未用的等待时间</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">// 等待时间是相对时间，如果由于等待超时返回，返回值为 false，否则为 true</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">// 等待时间是绝对时间，如果由于等待超时返回，返回值为 false，否则为 true</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除 awaitUninterruptibly() 之外，await 方法都是响应中断的，如果发生了中断，会抛出 InterruptedException，<strong>但中断标志位会被清空</strong>。awaitUninterruptibly() 方法不会由于中断结束，但当它返回时，如果等待过程中发生了中断，中断标志位会被设置。</p><p>3、一般而言，与 Object 的 wait 方法一样，<strong>调用 await 方法前需要先获取锁，如果没有锁，会抛出异常 IllegalMonitorStateException。await 在进入等待队列后，会释放锁，释放 CPU，当其他线程将它唤醒后，或等待超时后，或发生中断异常后，它都需要重新获取锁，获取锁后，才会从 await 方法中退出。</strong> 另外，与 Object 的 wait 方法一样，await 返回后，不代表其等待的条件就一定满足了，通常要将 await 的调用放到一个循环内，只有条件满足后才退出。</p><p>一般而言，signal/signalAll 与 notify/notifyAll 一样，调用它们需要先获取锁，如果没有锁，会抛出异常 IllegalMonitorStateException。signal 与 notify 一样，挑选一个线程进行唤醒，signalAll 与 notifyAll 一样，唤醒所有等待的线程，但这些线程被唤醒后都需要重新竞争锁，获取锁后才会从 await 调用中返回。</p><p>4、<strong>显式条件与显式锁配合，wait/notify 与 synchronized 配合。</strong></p><p>5、显示条件的实现原理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock 类中的 newCondition 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line">-------------------------</span><br><span class="line"><span class="comment">// ReentrantLock 内部类 Sync 中的 newCondition 方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ConditionObject 是 AQS 中定义的一个内部类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条件队列的头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 条件队列的尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ConditionObject 内部也有一个队列，表示条件等待队列。ConditionObject 是 AQS 的成员内部类，它可以直接访问 AQS 中的数据，比如 AQS 中定义的锁等待队列。</strong></p><p>6、await 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果等待前中断标志位已被设置，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 1.为当前线程创建节点，加入条件等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 2.释放持有的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.放弃CPU，进行等待，直到被中断或 isOnSyncQueue 变为 true</span></span><br><span class="line">    <span class="comment">// isOnSyncQueue 为 true 表示节点被其他线程从条件等待队列</span></span><br><span class="line">    <span class="comment">// 移到了外部的锁等待队列,等待的条件已满足</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.重新获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 5.处理中断，抛出异常或设置中断标志位</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7、signal 方法源码解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>doSignal 的代码就不列举了，其基本逻辑是：将节点从条件等待队列移到锁等待队列；调用 LockSupport.unpark 将线程唤醒。</p><p>8、<strong>总结：显示条件的本质就是一个队列，该队列提供了两个系列的方法，await 系列的方法用于条件不满足时将线程对象加入队列，signal 系列方法用于条件满足时从队列中释放线程对象。实际业务可以根据具体的条件是否满足来决定当前线程对象是加入队列等待，还是从队列中释放执行。</strong></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/swiftma/p/6528219.html" target="_blank" rel="noopener">Java编程的逻辑 - 显式条件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt; Java 线程总结(七) —— 显式条件 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java 基础" scheme="yanchongsheng.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
