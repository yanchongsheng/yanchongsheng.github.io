<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 入门总结(九)]]></title>
    <url>%2F2018%2F10%2F12%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(九) —— Linux 常用命令 帮助命令1、帮助命令 man123456789101112简介： 英文原意 manual；命令所在路径：/usr/bin/man；作用：获得帮助信息格式： man [命令或配置文件]举例： # 查看命令的帮助信息 man ls # 查看配置文件的帮助信息 man services manual 英文意思手册，指南；使用 man 命令相当于调用了一个 less 的浏览方式。 如何看命令的帮助信息？1、知道命令是干什么用的，通过查看帮助信息的第一行即 NAME 行。2、知道命令的选项是干什么用的，通过「/+关键字」的方式可以快速定位到你要找的内容，通过 n 键向下继续查找。 如何查看配置文件的帮助信息？1、这个配置文件是干什么用的，通过查看帮助信息的第一行即 NAME 行；2、这个配置文件的格式是什么样的，在 Linux 中任何配置文件都是有规律的，即格式，可以在配置文件的帮助文档中查看到。 注意在使用 man 来查看配置文件帮助的时候，不可以写成「man + 配置文件绝对路径」！！！此时你得到的并不是帮助信息，而是配置文件的内容。查看配置文件帮助的时候只要使用「man + 配置文件名称」即可。通过查看第一行即 NAME 行，它会告诉你这个配置文件是一个什么样的文件。 man 命令的帮助类型：「1」表示命令的帮助，「5」表示配置文件的帮助。eg：如 passwd 既对应一个命令又对应一个配置文件，使用 man 会优先显示命令的帮助。要想查看配置文件的帮助，则 man 5 passwd 加一个数字 5 声明你要查看配置文件的帮助。 执行指令 man services 等查看配置文件帮助文档的时候出现「没有 services 的手册页条目」。解决办法：安装 man 帮助文档包。指令为：yum install man-pages。 「whatis + 命令名称」它可以直接读取到这个命令 NAME 部分的信息。 「apropos + 配置文件的名称」只想查看一个配置文件的简短信息。 命令 --help 只想查看命令的选项，不想看到其他的描述语言。 命令 info 即 infomation，也可以获得帮助信息，其作用跟 man 大同小异，只是在帮助信息的显示有所差别，包括方式上支持一些跳转。 2、帮助命令 help123456简介： 命令所在路径：Shell 内置命令；作用：获得 Shell 内置命令的帮助信息举例： # 查看 umask 命令的帮助信息 help umask Shell 其实就是一个命令解释器，找不到命令所在路径的命令都是 Shell 内置命令，eg：cd、umask。这些命令不能使用 man 来查看帮助，它会列出 Shell 所有的帮助信息。可以使用 help 来获取 Shell 内置命令的帮助信息。 3、Linux 中的命令大致可分为两类，内部命令和外部命令。内部命令：也称 Shell 内嵌命令；外部命令：存放在一个文件中，使用时需要去文件中查找，这些文件被定义在 $PATH 中。type 命令可以查看命令类型，以区别是内部命令还是外部命令，格式 type 命令名称。 用户管理命令1、用户管理命令 useradd12345简介： 命令所在路径：/usr/sbin/useradd；作用：添加新用户格式： useradd 用户名 useradd 命令只有 root 用户可以使用。 useradd 命令在添加的时候只是添加了用户的基本信息，例如家目录、相关的命令解释器的分配等，并没有给它设置一个验证密码。 2、用户管理命令 passwd12345简介： 命令所在路径：/usr/bin/passwd；作用：设置用户密码格式： passwd 用户名 注意：更改密码的时候只有管理员可以随意更改密码，普通用户必须要满足密码原则才可以更改密码成功。每个普通用户只能用 passwd 更改自己的密码，而管理员 root 可以用 passwd 更改任何人的密码。 3、用户管理命令 who12简介： 命令所在路径：/usr/bin/who；作用：查看登录用户信息 who 命令显示内容解释：登录用户名（一个用户可以多次登录）、登录的终端（tty 表示本地终端，即在 Linux 机器本身上登录，tty 又叫本地登录）（pts 表示远程终端，即远程登录）、登录时间、括号里的内容是登录的主机的 IP 地址，如果没有写就表示本机登录。 4、用户管理命令 w12简介： 命令所在路径：/usr/bin/w；作用：查看登录用户详细信息 w 命令的第一行信息解释：当前系统时间、系统连续运行多久、当前一共有几个用户登录、负载均衡指数（这个指数有 3 个数值，分别记录了过去的 1 分钟、5 分钟和 15 分钟，系统的一个负载情况，一般来讲系统的负载值主要指的就是 cup 和内存的负载情况）。IDLE 表示该用户登录过来已经空闲多久了；PCPU 指的是该用户当前登录过来执行的操作占用的 cpu 的时间（下面的数字指的是当前执行的命令占用的 cpu 时间，因为进程在执行的时候是排队依次执行，每个进程在一个 cpu 循环周期里面会分配一定的 cpu 时间，如果一个进程在 cpu 循环周期里多次，它就会占用多个 cpu 时间）；WHAT 指的是他当前执行了什么操作；JCPU 累计占用的 cpu 时间。 压缩解压命令1、压缩命令 gzip12345简介： 命令所在路径：/bin/gzip；作用：压缩文件；压缩后文件格式：.gz格式： gzip [文件] 解压命令 gunzip12345678简介： 命令所在路径：/bin/gunzip；作用：解压缩 .gz 的压缩文件格式： gunzip [选项] 压缩文件选项： -S 指定后缀以取代 .gz，suffix 注意：gzip 只能压缩文件，不能压缩目录。而且使用 gzip 压缩是不保留源文件的，使用 gunzip 解压缩也是不保留源文件的。解压缩命令：gunzip（即在 gzip 压缩命令中间加入 un）或者使用 gzip -d 命令，两种命令的效果是一样的。gzip 的压缩比约为 5:1。 2、压缩解压命令 tar1234567891011简介： 命令所在路径：/bin/tar；作用：打包目录；压缩后文件格式：.tar.gz格式：tar [选项] [压缩后文件名] [文件或目录] 选项： -c 打包，create -x 解包，extract -v 显示详细信息，verbose -f 指定文件名，file -z 打包的同时用 gzip 或 gunzip 压缩或解压 tar 本身的意思是打包，它可以把一个目录打包成一个文件，同时也可以在打包的同时做一个压缩。tar -cvzf 的压缩比约为 5:1。使用此组命令会保留源文件。 注意：在使用 tar 的压缩解压命令的时候，-f 后面一定要紧跟它要指定的文件，否则可能会报错。如果 -f 后面没有紧跟它要指定的文件，则 tar 命令的选项中不能加「-」，否则会报错 Cannot stat: No such file or directory。 3、压缩命令 zip12345678简介： 命令所在路径：/usr/bin/zip；作用：压缩文件或目录；压缩后文件格式：.zip格式： zip [选项] [压缩后文件名] [文件或目录]选项： -r 压缩目录 解压命令 unzip12345简介： 命令所在路径：/usr/bin/unzip；作用：解压 .zip 的压缩文件格式： unzip [压缩文件] 一般来讲，Linux 里面的压缩包的格式 windows 的压缩软件几乎都支持。但反过来就要看具体情况了。默认在使用的过程中，只有一种压缩格式 windows 和 Linux 双方都不需要再额外装什么软件都可以进行解压缩处理的就是 .zip 格式。使用 zip 命令：会保留源文件，可以压缩目录。 压缩比没有 gzip 那么可观，所以使用的会比较少。使用 unzip 命令进行解压缩的时候，不分压缩文件是目录还是文件，都可以进行解压缩。 4、压缩命令 bzip2123456789101112131415简介： 命令所在路径：/usr/bin/bzip2；作用：压缩文件；压缩后文件格式：.bz2格式： bzip2 [选项] [文件]选项： -k 产生压缩文件后保留原文件，keep举例： # 压缩 bzip2 -k test # 跟 tar 命令结合使用，采用 bzip2 的方式压缩 tar -cjf test.tar.bz2 test 这是一个 gzip 的升级版本。值得注意的是 bzip2 的压缩比是非常惊人的，一般往往用来压缩大的文件。还可以跟 tar 一起来使用：即用 tar 命令里的 z（z 表示 tar 命令中的压缩方式）替换为 j（j 表示 bzip2 的压缩方式）。注意 bzip2 只能处理文件，不能处理目录。 解压命令 bunzip2123456789101112131415简介： 命令所在路径：/usr/bin/bunzip2；作用：解压缩格式： bunzip2 [选项] [压缩文件]选项： -k 解压缩后保留原文件，keep举例： # 解压 bunzip2 -k test.bz2 # 跟 tar 命令结合使用，解压 bzip2 方式的压缩 tar -xjf test.tar.bz2 如果该目录下有跟解压后的文件同名的文件则该命令会拒绝解压缩，不会像其他命令询问你是否覆盖等。要想解压则必须先删除或更改同名文件。在解压缩 .tar.bz2 文件的时候同样适用 tar 命令，注意把 z 替换为 j 即可。 小结： .gz 类型的压缩文件 gzip 进行压缩 gunzip（或 gzip -d）进行解压缩。不能压缩目录，不能保留源文件。 .tar 类型的文件 可以生成打包文件 tar -cf 打包，-xf 解包，可以利用此命令进行压缩目录。 .tar.gz 类型的压缩文件 tar -zcf 打包并压缩，tar -zxf 解包并解压缩。 .zip 类型的压缩文件 zip 压缩文件 zip -r 压缩目录，unzip 解压缩文件或者目录（压缩比不是特别高，windows 和 Linux 通过格式）。 .bz2 类型的压缩文件 bzip2 进行压缩，bunzip2（或者是 bzip2 -d）进行解压缩。 .tar.bz2 类型的压缩文件 tar -cjf 生成压缩包，tar -xjf 进行解压缩。 网络命令1、网络命令 write12345简介： 命令所在路径：/usr/bin/write；作用：给用户发信息，以 Ctrl + D 保存 结束格式： write 用户名 注意：在 write 命令的输入界面，按退格键是不行的，需要按 Ctrl + 退格键或者按 Delete 键，表示退格的意思。内容输入结束后按回车，然后使用 Ctrl + D 保存并结束。特别注意的是只能给在线用户发送，如果用户不在线消息是发不出去的。 2、网络命令 wall12345简介： 英文原意 write all；命令所在路劲：/usr/bin/wall；作用：发广播信息格式： wall 消息 给当前所有在线用户发送信息。在使用该命令发送广播信息的时候，自己也会受到一条发的广播信息。本地终端也会收到广播信息。注意只有在线用户可以收到消息。 3、网络命令 ping12345678简介： 命令所在路径：/bin/ping；作用：测试网络连通性格式： ping [选项] IP地址选项： -c 指定发送次数 现在使用最多的远程探测命令，工作机制：给远程主机发送一个信息包，判断你是否存在即看看你是否回应我，只要你回应，就证明咱们两个之间网络是通的。注意在使用 ping 命令的时候，重点看 package loss 即丢包率这个属性。如果丢包率非常高，即使你 ping 通了，证明你的网状态其实也非常差 。 4、网络命令 ifconfig12345简介： 英文原意 interface configure；命令所在路径：/sbin/ifconfig；作用：查看和设置网卡信息格式： ifconfig 网卡名称 IP地址 Linux 系统中默认有两块网卡，eth0 代表的是本地的真实网卡，lo 回环网卡，用来本机通信和测试的，地址也是固定的，都是 127.0.0.1，不插网线甚至网卡驱动不安装，都可以 ping 通。 eth0:网卡接口名称；flags：标志位，UP 表示网卡启用激活状态； mtu：maximum transmission unit，网卡最大传输单元为 1500 字节； inet：IPv4 地址； netmask：子网掩码；broadcast：广播地址； inet6：IPv6 地址； ether(HWaddr)：以太网地址；txqueuelen 1000 (Ethernet)：以太网传输队列长度；网卡的硬件地址即我们所说的 MAC 地址，它是用十六进制表示的，48 位的地址，表示我的网卡的物理地址。MAC 地址是固化在网卡的只读存储器中的一个地址，位于网卡的芯片上，理论上来讲一般是不能改的。 RX packets 13245 bytes 1989908 (1.8 MiB)：此次网卡激活后接搜到的报文数量，总大小； RX errors：接收时错误的个数；dropped：丢包个数；overruns：溢出个数；frame：帧。 TX packets 162 bytes 18461 (18.0 KiB)：传输的报文数量，总大小； TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0：传输时错误、丢包、溢出、搬运、碰撞的个数。 5、网络命令 mail12345简介： 命令所在路径：/bin/mail；作用：查看发送电子邮件格式： mail [用户名] mail 命令比 write 命令有一个好处，就是不管对方在不在线，都可以给对方发送邮件。Linux 的纯字符界面也可以进行邮件的收发，它利用的并不是真正的搭建好的邮件服务器，而是如果是本机用户给本机用户发信，它利用的是本地的内存。 mail 命令编辑完邮件后点击 Ctrl + D 保存结束。使用 mail 命令直接按回车，用来接受邮件，N 表示 new，即这是新收到的邮件还未阅读。想看第几分信，邮件前面有一个序列号，输入序列号回车就能看到这份邮件的具体内容，使用 h 键可以回到刚才的邮件列表，发现 N 消失了，表示邮件已读，要想删除邮件则「d 邮件序列号」，再按 h 查看邮件发现没有邮件了，q 键退出。 学习 mail 命令主要是有的时候系统会给 root 发一些系统信息的邮件，当你在用 root 登录以后系统会提示你有新的邮件需要接受，这个时候就需要我们知道怎么样来收到系统发给你（root）的信息。系统给 root 发送的信息都是非常重要的，例如日志的统计信息、系统的报错信息，当我们发现 root 有这样的邮件的时候，千万不可以忽略它，应该仔细的查看它，因为这说明你对的系统当中可能出现了一些问题，有可能会影响到你的系统的安全。 6、网络命令 last12简介： 命令所在路径：/usr/bin/last；作用：列出目前与过去登入系统的用户信息 该命令会统计我的计算机的所有用户的登陆的时间信息，包括计算机重启时间也会被记录下来。这是一个重要的日志查询点，可以查看系统是否有异常登陆重启等信息。该命令是一个非常有效，非常重要，非常常用的日志查询命令，在服务器上可能会多次使用这样的命令。只想知道用户最后一次登陆的时间，不想知道所有的登陆信息，则可以使用另外一条命令：lastlog。last 统计的是只要有人登陆它就会记录，包括你多次登陆的信息。而 lastlog 会先把所有的用户都列出来，包括一些不能登陆的系统用户。 7、网络命令 lastlog123456简介： 命令所在路径：/usr/bin/lastlog；作用：检查某特定用户上次登录的时间举例： # -u 指的是用户的 UID，查看特定用户的最后一次登陆的时间 lastlog -u 500 8、网络命令 traceroute12简介： 命令所在路径：/bin/traceroute；作用：显示数据包到主机间的路径 作用：探测到达某一个指定网站（某一个主机）的路径。这条命令非常有用，可以事先探测好你访问某网站的路径，然后当你访问该网站出现问题的时候，可以对照然后得出哪里出现了问题。我们 traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了返回信息，所以我们得不到什么相关的数据包返回数据。 9、网络命令 netstat1234567891011121314151617181920212223简介： 命令所在路径：/bin/netstat；作用：显示网路相关信息格式： netstat [选项]选项： -t 查询 TCP 协议的网络信息 -u 查询 UDP 协议的网络信息 -l 查看监听的端口，listening -r 查看路由即查看网关，route -n 用 IP 地址和端口号显示查询结果，而不是用域名或服务的名称，这样更快，因为省略了解析过程，numeric -a all举例： # 查看本机监听的端口，即查询当前计算机下，我开了哪些计算机端口 netstat -tuln # 查看本机所有的网络连接 netstat -an # 查看本机路由表，即查询路由列表 netstat -rn net 网络的意思，stat 即 state 状态的意思，查询网络状态的命令。这条命令的用途在服务器上非常广泛的。TCP 是传输控制协议的简称；UDP 用户数据报协议的简称。一般情况下服务的端口号是固定的，我们可以通过判断本机开了哪些监听端口来判断我的计算机开启了哪些服务。注意：TCP 协议才可以直接接受访问，所以它有 listen，代表状态是监听的。而 UDP 是没有的，它可以直接发送，不监听即不顾你在不在线。访问服务的时候不管访问的是 22 还是访问其他的服务，你的发起端口即源端口是 1024 以上的随机端口，只有目标端口是固定的。 发现该命令的输出分了两大类，一类是上面的这些网络服务，除了有监听的协议之外，状态还出现了 ESTABLISHED 表示正在连接的。另一类就是下面的除了服务状态计算机中会有很多网络程序，它也会使用网络协议，使用网络端口，你可以看到这些程序所占用的端口，这个对我们意义不大。主要看到还是上面的信息。它跟 netstat -tlun最大的区别在于 netstat -tlun 只能查看监听，而它可以查看到正在连接的网络程序。 Destination 为 0.0.0.0 那行是当前计算机的默认路由列表，其实就是自己的网关。可以通过该命令查询当前计算机的网关。还可以通过 route -n 或 cat /etc/resolv.conf 查看当前计算机的网关。 10、网络命令 setup12简介： 命令所在路径：/usr/bin/setup；作用：配置网络 setup 是 redhat 开发的一个管理工具集合，它在其它的版本的 Linux 中不存在，这是 redhat 系类专有的。注意在配置完成后一点要重启网络服务：service network restart。使用 setup 配置的 IP 地址是永久生效的。该命令简单了解即可。 挂载命令 mount12345678简介： 命令所在路径：/bin/mount格式： mount [-t 文件系统] 设备文件名 挂载点举例： mount -t iso9660 /dev/sr0 /mnt/cdrom 该命令的作用是把我的设备连接到我给它分配的挂载点（可以理解为 windows 中的盘符，只是我们的挂载点是目录，而 windows 中的是 CDEF）。分区都是自动挂载的，只要安装了，分区了，每次启动不需要手动参与直接就可以挂载。但是 Linux 的 U 盘、光盘、移动硬盘等外接存储设备不能实现自动挂载，每次开机都只能手工来挂载。 挂载步骤： 先创建挂载点：mkdir /mnt/cdrom。 开始实现挂载：mount -t （-t 后面指定光盘的文件系统）iso9660（光盘的文件系统是固定的） /dev/sr0（设备文件名称，其来源是系统默认指定的，Linux 系统在 redhat centOS6.0 以上的系统中，设备文件名默认就叫 sr0，只要记住就可以了，不需要知道它是怎么来的，当然也可以写 cdrom，实际上就是一个软连接，通过命令：ll /dev/cdrom 可以查看到）。这条命令中其实 -t iso9660 是可以省略的，因为该命令的这个选项或者说分区的光盘的文件系统是默认的，系统就知道它就叫 iso 9660，不写也可以。 挂载其实就是找到这个硬件，给它分配一个设备文件名，再给它找一个盘符（即目录），把它的设备文件名和盘符连接起来，就是挂载。（挂载的本质：就是把设备文件名连接到挂载点上）。如果之前你的这个挂载点上做过挂载，那么你需要把它卸载以后再进行挂载：umonut /dev/sr0。正常挂载完，mount 命令是没有任何提示的，这里提示的作用是报错，它尝试把它挂成写权限，但是光驱是只读的，所以被迫挂成了只读的，光盘绝大多数都是只读的。（windows 是光盘符下访问，而 Linux 中的盘符是目录）挂载完成后通过 cd（即cd /mnt/cdrom）切换到盘符目录下去访问它的数据。（/dev/sr0 是一个文件，cd 命令是进不去的）。注意：必须要执行卸载命令，才可以弹出光盘。切记不可以在光盘挂载点下面卸载，因为系统会认为光盘正在使用，不允许卸载。你需要退出挂载点，直接 cd 即可返回到自己的宿主目录。在卸载的时候，因为 /dev/sr0 和 /mnt/cdrom 它们两个通过 mount 命令已经连接了，所以后面加其中任何一个都是可以的，但是只能跟一个，要是跟两个它就会卸载两遍，第二遍它就会报错。直接回车没有任何提示表示卸载成功，再回到 /mnt/cdrom 执行 ls 命令发现变成了空目录了。 关机重启命令1、shutdown 命令123456格式：shutdown [选项] 时间选项： -c 取消前一个关机命令，cancel -h 关机，halt -r 重启，reboot 除了 shutdown 命令之外还有其他命令可以实现关机或重启，只是早期的时候只有 shutdown 命令会在关机和重启之前正确的保存它正在启动的服务，尽管现在 Linux 中绝大多数的关机重启命令都已经实现了正确的关闭服务和保存数据，只是我们已经习惯了 shutdown 命令了。虽然其他命令也可以做到，但是 shutdown 命令更安全一点，我们更信任它。 2、其他关机命令12345678# 关机halt# 关机power off# 关机init 0 注意：poweroff 相当于直接断电，谨慎使用！！！ 3、其他重启命令12345# 重启reboot# 重启init 6 4、系统运行级别12345670 关机1 单用户2 不完全多用户，不含 NFS 服务3 完全多用户4 未分配5 图形界面6 重启 单用户类似于 windows 中的安全模式，其实就是启动最小的服务，其他多余的东西、附加的程序都不要，甚至连网都不要，只启动最核心的程序，进去是用来做修复的。只能是 root 登录进去，其他用户都不行，顾名思义即为单用户。运行级别 1 是没有图形界面的，不光 1 级别没有图形界面，1、2、3 这 3 个运行级别都是没有图形界面的，4 是没有使用的，即可以自己定义，5 是标准的图形界面。2、3 其实都是命令行，区别是：3 是完全的命令行，而 2 是不包含 NFS 服务的命令行，即它也是命令行只是不完整（2 级别也没有网络服务）。NFS 服务：（network file system）网络文件系统，使用 NFS 是实现两个 Linux 之间的文件共享或者是 Linux 和 Unix 之间的文件共享的服务。由于 NFS 用户验证的机制比较弱，即可能不是太安全，有它自己的安全隐患在里面，所以不太建议使用 NFS 来进行文件共享，当然使用它进行文件共享确实很简单方便。 12345678# 查看系统默认运行级别cat /etc/inittab# 修改系统默认运行级别，注意：id 最后是有冒号的「:」，千万不可以丢！！！id:3:initdefault:# 查看系统运行级别runlevel 注意：0 和 6 不能设为系统默认运行级别。在 Linux 中用 X11 代表图形界面，大写的 X 指的是 Xwindow，一般来讲，在 Linux 中看到类似于这样的表示（包括只有一个大写的 X）都表示 Linux 的一个图形环境的意思。 执行 runlevel 命令之后会有「N 3」这样的显示，3 表示当前运行的级别号，N 代表上一个运行级别，即进入 3 级别之前我在哪个级别（由于我们是开机之后直接进来的，所以是 N 表示 null 的意思）。 init 5 表示切换到运行级别 5 即图形界面，由于我没有装图形界面它不会执行，且远程工具上是不会报错的，但是在 Linux 本地上会有报错提示，它尝试去启动 5 级别，但是没有启动成功。但是系统以为你进去了，所以执行 runlevel 命令的时候会有显示 5 3。 5、退出登录命令 logout退出一个登录 Shell。注意：在使用完 Linux 后，一定要 logout！！！否则后果很严重！！！ 6、Linux 中的管道符利用 Linux 所提供的管道符「|」将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。 参考博客centOS 7 安装 man 中文版手册Linux 中的内部命令和外部命令]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(八)]]></title>
    <url>%2F2018%2F10%2F09%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AB)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(八) —— Linux 常用命令 目录处理命令1、命令格式1234567命令格式： 命令 [-选项] [参数]说明： 1. 个别命令使用不遵循此格式 2. 当有多个选项时，可以写在一起 3. 简化选项与完整选项，eg：-a 等于 --all 关于选项：在大多数的命令中，选项前面会有一个小横杆，用来标记这是一个选项；选项的作用：使用命令的时候用来做不同的操作，使命令结果呈现不同的形式或者信息内容，就可以加上不同的选项来实现，即选项是用来调整命令功能的。我们使用的选项都是简化选项，完整选项需要两个「-」 来调用，选项的顺序一般都是可以调整的。[] 里的内容是选择性加入的。加了选项是调整功能，加了参数是指定操作对象。 2、目录处理命令 ls123456789101112简介： 英文原意 list；命令所在路径：/bin/ls；作用：显示目录文件格式： ls [选项] [文件或目录]选项： -a a 表示 all -l l 表示 long -d d 表示 directory，显示当前目录本身，而不显示目录下的数据 -h h 表示 human，人性化显示文件大小 -i i 表示 iNode，显示 i 结点号 在 Linux 中，以「.」开头的是隐藏文件。隐藏文件的初衷是为了告诉用户这是一个系统文件，没有特殊情况一般不要修改它。在 Linux 中要想把一个文件隐藏，则需要给它改名，改成以点开头的文件名即可隐藏。 3、ls -l 显示结果分析 x 表示执行权限，是 execute 的缩写；可执行文件 .exe 的缩写也来源于这个单词。 引用计数，代表这个文件曾经被引用或者调用过几次。这个引用计数对文件和目录来讲只在硬链接中才有作用。 文件大小默认单位是字节。可以使用 -h 选项来调整。 上图中的时间表示该文件最后被修改的时间；如果没有被修改过，则就是它的创建时间。需要注意的是 Linux 中没有创建时间这个概念，它只有文件的最后一次访问时间，文件的状态修改时间，文件的数据修改时间这三个时间。 i 节点，在 Linux 系统中每个文件或者目录都有它自己的一个唯一标识编号，系统靠这个 i 节点号搜索或者查找文件或者目录。 4、目录处理命令 mkdir123456789101112简介： 英文原意 make directories；命令所在路径：/bin/mkdir；作用：创建新目录格式： mkdir [选项] 目录名选项： -p p 表示 parents，如果新创建的目录的父目录不存在，则自动递归创建父目录举例： # 可同时创建多个目录，多个目录之间以空格进行分割 mkdir /tmp/test1 /tmp/test2 /tmp/test3 目录在 windows 中又称为文件夹。不要轻易在根目录下创建新的目录或者文件。可以在 /tmp 目录下进行练习，该目录是用来存放临时文件的。 5、目录处理命令 cd12345简介： 英文原意 change directory；命令所在路径：shell 内置命令；作用：切换目录格式： cd [目录] 「.」 表示当前目录，「..」表示当期目录的上一级目录。 注意：在 Dos 窗口下 cd.. 中间是可以不加空格的，但是在 Linux 中，中间必须有空格。 6、目录处理命令 pwd12345简介： 英文原意 print working directory；命令所在路径：/bin/pwd；作用：显示当前所在目录的绝对路径格式： pwd 7、目录处理命令 rmdir123456789简介： 英文原意 remove empty directories；命令所在路径：/bin/rmdir；作用：删除空目录格式： rmdir [空目录]举例： # 可同时删除多个空目录，多个空目录之间以空格进行分割 rmdir /tmp/test1 /tmp/test2 /tmp/test3 注意：rmdir 只能删除空的目录！！！要想使用 rmdir 删除目录，必须先把该目录下的所有子目录和文件都删除掉，才可以使用。实际操作中此命令用的并不是很多。 8、目录处理命令 cp12345678910111213简介： 英文原意 copy；命令所在路径：/bin/cp；作用：复制文件或目录格式： cp [选项] [原文件或目录] [目标目录]选项： -r 复制目录，copy directories recursively -p 保留文件属性，same as --preserve=mode,ownership,timestamps举例： # 将 /tmp 下 test1、test2、test3 目录一次性复制到 /root 下，并保持目录属性 cp -rp /tmp/test1 /tmp/test2 /tmp/test3 /root 在 cp 复制文件的时候是不需要加选项的；但是要复制目录的话要增加选项 -r；cp 可以同时复制多个文件或者目录。 当把一个文件或目录复制到另一个地方的时候，相当于在另一个地方创建了一个新的文件或目录，所以复制出来的文件或目录的最后更改时间就是当前时间。如果希望复制出来的文件或目录的最后更改时间跟源文件一样，则使用 -p 选项。 在 Linux 中，复制文件或者目录的同时，可以更改目录或者文件的名字。 9、目录处理命令 mv123456789101112简介： 英文原意 move；命令所在路径：/bin/mv；作用：剪切文件、改名格式： mv [原文件或目录] [目标目录]举例： # /tmp 下 test1、test2、test3 目录一次性剪切到 /root 目录 # 当一次剪切多个目录或文件的时候就不能改名了，改名操作只支持一次一个，不支持一次多个文件或目录进行改名 mv /tmp/test1 /tmp/test2 /tmp/test3 /root改名： mv 要改名的文件名 新的文件名 在 Linux 中剪切和改名是同一个命令。在执行复制剪切等命令的时候，如果你的位置是在当前目录的话，可以省略绝对路径，但是在不清楚当前目录的情况下要写绝对路径。mv 命令是不需要加 -r 选项的，直接使用 mv 可以同时剪切一个或多个目录或者文件的，而且在剪切的同时可以改名。 10、目录处理命令 rm12345678910111213简介： 英文原意 remove；命令所在路径：/bin/rm；作用：删除文件或目录格式： rm [选项] [文件或目录]选项： -r 删除目录，recursive -f 强制删除，force举例： # 同时删除目录 test1 test2 文件 h1.txt h2.txt rm -rf test1 test2 h1.txt h2.txt 注意：Linux 中是没有回收站这一说的，文件一旦删除，就没有了。 在删除文件的时候每次都会询问你是否删除，如果你不想有这个提示的话，则可以加 -f 选项。 小结：mkdir 创建一个新的目录，选项 -p 递归创建目录；cd 切换目录；pwd 查看当前的工作目录；rmdir 删除一个空目录；cp 复制文件 -r 复制目录 -p 复制的时候保持文件的属性；mv 剪切或者给一个文件改名；rm 删除文件 -r 删除目录 -f 删除目录或者文件的同时不希望询问确认。 文件处理命令1、文件处理命令 touch12345简介： 命令所在路径：/bin/touch；作用：创建空文件格式： touch [文件名] 注意：在 Linux 的命令里面，如果这个命令的参数没有详细的指定它的绝对路径，就表示要在当前目录下执行这个操作。要想在其他目录下执行这个操作，一定要指明它的绝对路径。 在 Linux 的文件命名里，除了「/」不能使用外，其它特殊符号都是合法的文件名，其后缀名是可以随便起的，这跟 windows 不一样。注意空格这个特殊符号，在 Linux 中并不建议将空格作为文件名组成部分，由于 Linux 系统把空格作为分隔符，要想使用空格作为文件名则必须用引号扩起来，这样虽然可以用空格作为文件名，但是对以后该文件的查找、修改、复制等操作造成麻烦，所以不建议这样使用。 2、文件处理命令 cat12345678简介： 命令所在路径：/bin/cat；作用：一次性显示整个文件内容格式： cat [选项] [文件名]选项： -n 显示行号，number cat 命令适合看简短的文件。cat 不适合浏览比较长的文件。cat 命令会一次性列出文件所有内容 3、文件处理命令 tac12345简介： 命令所在路径：/usr/bin/tac；作用：一次性显示整个文件内容（反向列示）格式： tac [选项] [文件名] 4、文件处理命令 more12345678910111213简介： 命令所在路径：/bin/more；作用：分页显示文件内容格式： more [文件名]快捷键： 空格或 f 翻页 Enter 换行 q 或 Q 退出举例： more /etc/services more 命令是一个常用的分页显示文件内容的命令。该命令不可以往上翻。 5、文件处理命令 less12345简介： 命令所在路径：/usr/bin/less；作用：分页显示文件内容（可向上翻页）格式： less [文件名] 使用 less 命令，不仅可以像 more 命令一样进行浏览，还可以往上翻，使用 PgUp 表示一页一页往上翻，使用向上的剪头表示一行一行往上翻。还可以进行搜索：直接在 less 的浏览状态里面按一个「/」+ 你要搜索的关键词，就会把行里所有包含这个关键词的进行反白显示，同时如果在你当前查看的页里没有你要得到的搜索的关键词所在行的信息，可以按 n 表示 next 接着往下找。 6、文件处理命令 head1234567891011简介： 命令所在路径：/usr/bin/head；作用：显示文件前面几行格式： head [选项] [文件名]选项： -n 指定行数举例： head -n 20 /etc/services 如果只想看文件的前几行，则可以使用此命令。如果不用 -n 指定要显示的行数，则默认显示的是前 10 行。 7、文件处理命令 tail123456789简介： 命令所在路径：/usr/bin/tail；作用：显示文件后面几行格式： tail [选项] [文件名]选项： -n 指定行数 -f 动态显示文件末尾内容 显示文件最后面几行内容，默认是 10 行。-f 动态显示文件末尾的内容。使用该命令以后它会显示文件最末尾的位置，但是它并没有回到命令行，如果这时你这个文件的内容进行了变化，在这个命令操作状态下它也会实时变化的。一般来说用的也不会太多，一般用来监控一些日志。 小结：touch 创建一个文件；cat 查看文件的内容（浏览一些短文件），-n 用来显示行号；tac 反向显示文件内容（反向显示并不支持 -n 这个选项）；more 分页显示文件内容（主要指一些长的文件，不可以向上翻）；less 分页显示文件内容（可以向上/下翻，使用 「/ + 要搜索的关键词」在浏览的过程中遍历整个的文件进行搜索，可以用 n 键查找下一个匹配的位置）；head 查看一个文件的前几行，-n 指定要查看前几行，默认为 10 行；tail 查看一个文件的最后几行，-n 指定要查看后几行，-f 动态显示文件最后的内容，默认为 10 行。 8、文件处理命令 ln123456789101112131415简介： 英文原意 link；命令所在路径：/bin/ln；作用：生成链接文件格式： ln [选项] [原文件] [目标文件]选项： -s 创建软链接，s 代表 symbolic，make symbolic links instead of hard links，即创建符号链接而不是硬链接举例： # 创建 /etc/issue 的软链接 /root/issue.soft ln -s /etc/issue /root/issue.soft # 创建文件 /etc/issue 的硬链接 /root/issue.hard ln /etc/issue /root/issue.hard 9、软链接特征类似 windows 快捷方式。作用：方便快捷的让你找到你最常使用的一些东西，便于规划，方便管理。 在 Linux 系统里面，它前面的 10 个文件权限的标识全部都是 lrwxrwxrwx，意味着所有的人都有全部的操作权限，每个用户在对这个软链接进行操作的时候，到底他能具有什么样的权限，是由这个文件对应的源文件的权限最终决定的。 软链接文件大小很小，因为它只是一个符号链接。 有一个箭头指向到它所对应的源文件（硬链接是没有箭头指向的）。 10、硬链接特征 拷贝「cp -p」+ 同步更新。cp -p 是拷贝文件并且保留文件的属性不变；同步更新即不管是修改原文件还是硬链接文件，两者的内容始终会自动保持一致，即同步更新。 通过 i 结点识别，硬链接的 i 节点与源文件的 i 节点一样。 不能跨分区。 不能针对目录使用。 软链接与硬链接的区别：硬链接就类似于拷贝，但是可以同步更新，源文件即使不在了，硬链接照样可以访问，因为是类似拷贝的。如果软链接源文件不在了，则它会报错找不到源文件。一个文件一定有一个 i 节点，但是一个 i 节点不一定只对应一个文件，硬链接就是一个特殊案例，一个 i 节点映射到了多个文件。注意硬链接在 Linux 中用的非常少！ 权限管理命令1、权限管理命令 chmod12345678910111213简介： 英文原意 change the permissions mode of a file；命令所在路径：/bin/chmod；作用：改变文件或目录权限格式： chmod [选项] [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [文件或目录] chmod [选项] [mode] [文件或目录]选项： -R 递归修改举例： # 可以同时做多个授权，中间用「,」逗号分隔 chmod u+rwx,g+rw,o=r test.txt 一个文件或目录的权限只有两个人可以更改：一个是该文件或目录的所有者，另一个就是管理员 root。 权限数字表示：r=4，w=2，x=1。 2、文件目录权限总结 注意：读写执行权限对目录的含义！！！要想删除一个文件，你必须有这个文件所在的目录的写权限。对于目录，r（查看目录内容）、x（进入目录）权限一般都是一起出现的。 3、权限管理命令 chown123456789简介： 英文原意 change file ownership；命令所在路径：/bin/chown；作用：改变文件或目录的所有者格式： chown [用户] [文件或目录]举例： # 改变文件 test.txt 的所有者为 root chown root test.txt 在 Linux 系统中，改变一个文件或者目录的所有者，只有管理员 root 可以做这样的操作。可以使用 useradd 命令来添加一个用户，使用 passwd 为该用户设置一个密码。 4、权限管理命令 chgrp123456789简介： 英文原意 change file group ownership；命令所在路径：/bin/chgrp；作用：改变文件或目录的所属组格式： chgrp [用户组] [文件或目录]举例： # 改变文件 test.txt 的所属组为 family chgrp family test.txt 在 Linux 系统中，改变一个文件或者目录的所属组，只有管理员 root 可以做这样的操作。 添加用户组命令：groupadd。 所有者：谁创建的文件谁就是文件的所有者；所属组：一个用户可以属于多个组，但是他总有个缺省组（缺省，即系统默认状态，意思与「默认」相同），每个用户创建文件的时候，它（该文件）的所属组就是该用户的缺省组，每个用户只能有一个缺省组。所以在创建一个文件的时候，它的所有者就是他自己即文件的创建者，它的所属组就是这个文件创建者的缺省组（了解即可）。 5、权限管理命令 umask12345678简介： 英文原意 the user file-creation mask（mask 掩码的意思）；命令所在路径：Shell 内置命令；作用：显示、设置文件的缺省权限格式： umask [-S]选项： -S 以 rwx 形式显示新建文件缺省权限（注意 S 大写） 在 Linux 权限管理有一个最基本的定义：缺省创建的文件是不能具有可执行权限的。所以在 Linux 系统中任何新建的文件都会把可执行权限去掉。这样做的目的是为了安全。注意只针对文件，对目录没有这样的限制。 直接执行 umask 命令会得到一个 4 位的数字：0022。第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认的权限 rwxr-xr-x。而 Linux 系统中任何新建的文件都会把可执行权限去掉，所以你新建的任何一个文件的权限就是：rw-r–r–。 要想更改缺省权限，则需要先写出你要更改权限的数字，eg：rwxr-xr– 即 754，然后用 777-754=023，最后 umask 023 将缺省创建的权限改为 rwxr-xr–。虽然缺省创建的权限是可以更改的，但是并不建议这样去做。 文件搜索命令注意：尽量减少搜索这个操作，因为搜索它会占用大量的系统资源。在服务器高峰期里面，是不建议用搜索这个命令的。原则：不要在服务器使用高峰期的时候使用 find 命令来进行查找；在查找的过程中搜索的范围越小越好；搜索的条件越精准越好。 1、文件搜索命令 find123456789101112131415161718192021222324252627282930313233343536373839404142简介： 命令所在路径：/bin/find；作用：文件搜索格式： find [搜索范围] [匹配条件]举例： # 在目录 /etc 中查找文件 init find /etc -name init # -iname 不区分大小写 find /etc -iname init # （注意数据块概念）在根目录下查找大于 100MB 的文件；+n 大于 # -n 小于，n 等于 find / -size +204800 # 在 /etc 下查找大于 80MB 且小于 100MB 的文件 # -a 两个条件同时满足，and # -o 两个条件满足任意一个即可，or find /etc -size +163840 -a -size -204800 # 在根目录下查找所有者为 root 的文件 find / -user root # 在根目录下查找所属组为 root 的文件 find / -group root # 在 /etc 下查找 5 分钟内被修改过属性的文件和目录 # -amin 访问时间 access；-cmin 文件属性 change；-mmin 文件内容 modify # +n 大于多长时间，-n 多长时间以内，n 等于 find /etc -cmin -5 # -type 根据文件类型查找 # f 文件；d 目录；l 软链接文件 find /etc -type f # -inum 根据 i 节点查找 find /etc -inum 12345 # 在当前目录中查找 iNode 为 666 的文件或目录并删除 find . -inum 666 -ok rm &#123;&#125; \; 注意利用 -name 搜索的话，它只会搜索文件名是 init的文件，而不像 windows 里面那样只要文件名包含 init 就都会被搜素到，可以理解为这是一种非常精准的搜索。要想像 windows 一样，可以做一个模糊的搜索即只要是包含 init 这 4 个连续的字母，就可以被搜素到，则：find /etc -name init，「」号表示通配符，意思是只要文件名里有 init 就会被搜索到。init 表示以 init 开头的；init??? 表示 init 以后有 3 个字符，问号匹配单个字符。Linux 中常用的两种通配符：* 号可以匹配任意字符，? 号可以匹配某个单个字符。 注意：在 Linux 系统中，一个数据块默认是 512 字节即 0.5kb；数据块是 Linux 系统中存储文件的最小单位。而 -size 的大小是用数据块换算的，所以 100MB 的文件所对应的就是 204800 个数据块。 123# 在 /etc 下查找 inittab 文件并显示其详细信息# 「-exec/-ok 命令 &#123;&#125; \;」对搜索结果执行操作find /etc -name inittab -exec ls -l &#123;&#125; \; 前面还是正常写 find 要执行的查找的命令，找到这个结果以后，可以使用 -exec/-ok 直接连接一个命令即对 find 查找的结果做一些操作，再加上固定格式「{} \;」。{} 表示的是 find 查找的结果，表示对 find 查找的结果做一个替换，因为 find 查找的结果可能有多个，所有使用 {} 表示。「\」表示转义符，「;」表示结束。注意：「;」分号，不要丢掉，而且「\」和「;」之间没有空格分隔！！！ -exec 和 -ok 的区别：-exec 直接执行，-ok 会一个个询问你是否执行（即会有询问确认环节）。 find -inum 使用场景，确定一个文件是否有硬链接。查看一个文件是否有硬链接：首先查看该文件的 i 节点，然后在整个它所在的分区里面（硬链接不能跨分区）做一个搜索，找 i 节点是你这个指定数字的文件，它就会把它的硬链接文件找到。 小结：find 命令 -name 根据文件名来查找；-iname 查找的时候不区分大小写；使用的通配符：* 匹配任意字符，? 匹配单个字符；-size 根据文件大小来查找，+ 大于多少，- 小于多少；-user 根据所有者来查找；-group 根据所属组来查找；-amin 根据访问时间来查找；-cmin 根据文件属性的更改查找；-mmin 根据文件内容更改来查找；-type 根据文件类型来查找，f 文件，d 目录，l 软链接；-inum 根据 i 节点来查找；-a 连接两个条件，表示两个条件都满足；-o 表示两个条件只有满足一个就可以；-exec 或者-ok 对搜索的结果直接进行操作，二者的区别只有一个就是 -ok 会询问确认，固定格式「{} \;」。 其他搜索命令1、文件搜索命令 locatecentos locate 命令安装12345678简介： 命令所在路径：/usr/bin/locate；作用：在文件资料库中查找文件格式： locate 文件名举例： locate inittab 该命令在查找的时候不像 find 来遍历你所搜索的范围，而是建立了一个文件资料库（该资料库会定期更新），它在找的时候不是在硬盘上找，而是在资料库里面找你有搜索的文件，所以速度很快。虽然使用 locate 命令查找的速度非常快，但是新建的文件使用该命令是找不到的，因为 locate 的文件资料库并没有更新。手动更新文件资料库命令：updatedb。 注意：/tmp 临时文件目录，并不在文件资料库所收录的文件范围之中，如果你要找的文件在 /tmp 目录下面，使用该命令是找不到的。如果希望 locate 命令在查找的时候不区分大小写，可以使用选项「-i」。 2、文件搜索命令 which12345简介： 命令所在路径：/usr/bin/which；作用：搜索命令所在目录及别名信息格式： which 命令 which 提供了一种快速查找一个命令所在的绝对路径的方法。除了可以找到命令所在的目录还可以找到该命令的别名，查看该命令本身是否有别名相关的信息。 实际上在 Linux 系统中，本身是没有询问确认的机制，之所以现在在 Linux 系统中有询问确认的选项，是因为它加了一个 -i 的选项，eg：在使用 rm 命令的时候，系统在找的时候找到的是一个别名而不是一个命令，它的别名等于「rm -i」，「-i」这个选项实际上就是一个询问确认的选项，所以这是别名的作用。 3、文件搜索命令 whereis12345简介： 命令所在路径：/usr/bin/whereis；作用：搜索命令所在目录及帮助文档路径格式： whereis [命令名称] whereis 除了可以找到命令所在的绝对路径，还可以找到这个命令它相关的帮助文档所在的位置，这个帮助文档就是 man 命令所展示的文件。 4、文件搜索命令 grep12345678910111213141516简介： 命令所在路径：/bin/grep；作用：在文件中搜寻字符匹配的行并输出，属于精确匹配格式： grep [选项] [指定字串] [文件]选项： -i 不分区大小写 -v 显示排除指定字串的行举例： # 列出在 /etc/issue 文件中包含 hello 字串的行，且忽略大小写 grep -i hello /etc/issue # 列出 /etc/issue 文件中所有不包含 Hello 字串的行 grep -v Hello /etc/issue 「-v #」表示把 # 号所在的行都去掉，不管 # 号在什么位置，只要该行有 # 号，就都去掉。这样做是不太合理的，可能 # 位于中间，前面是有有效代码的。所以要想把行首以 # 开始的注释行去掉，要在 # 前面加一个表示行首的「^」即「^#」。使用 grep 命令查找文件中除注释以外的内容：grep -v ^# 文件名，需要注意的是针对 Shell 脚本的首行 # 号，应该做特殊处理。 小结：locate 快速定位到一个文件所在的路径（文件资料库），updatedb 更新文件资料库（有个别目录下的文件并不被收录到文件资料库中 /tmp），-i 不区分大小写；which 或者 whereis 查找命令所在的绝对路径；grep 在文件内容中查找，-i 不区分大小写，-v 排除查找。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础(一)]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1、注释 HTML 的注释方法 CSS 的注释方法 /注释内容/ JavaScript 的注释方法 / 多行注释方式 / //单行注释方式 2、BFC块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(七)]]></title>
    <url>%2F2018%2F09%2F28%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%83)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(七) —— Shell 编程 基础正则表达式1、正则表达式与通配符正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、sed 等命令可以支持正则表达式。 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp 这些命令不支持正则表达式，所以只能使用 Shell 自己的通配符来进行匹配了。 注意：通配符和正则表达式这种区分，仅限于 Linux 的 Shell 当中。 注意：这里是基础正则表达式，还存在扩展正则表达式。 注意：「^」位于中括号里面表示取反，位于外面表示行首。 test.txt 内容如下，将适用于以下所有用到 test.txt 的地方： ID Name Gender Score 1 zhangsan male 86 2 lisi female 90 3 wangwu male 83 「*」示例： 12345678# 匹配所有内容，包括空白行（即 a 出现了 0 次）grep &quot;a*&quot; test.txt# 匹配至少包含一个 a 的行grep &quot;aa*&quot; test.txt# 匹配至少包含两个 a 的行grep &quot;aaa*&quot; test.txt 「.」示例： 12345678# s..d 匹配在 s 和 d 之间一定有两个字符的所在行grep &quot;s..d&quot; test.txt# 匹配在 s 和 d 之间有任意字符，把 .* 当做一个整体看，表示除换行符外任意一个字符出现任意次grep &quot;s.*d&quot; test.txt# 匹配所有内容grep &quot;.*&quot; test.txt 「^」行首、「$」行尾示例： 12345678# 以 M 开头的行grep &quot;^M&quot; test.txt# 以 n 结尾的行grep &quot;n$&quot; test.txt# 匹配空白行grep -n &quot;^$&quot; test.txt 「[]」示例： 1234567891011121314# 匹配 s 和 i 之间，要么是 a、要么是 o。注意：一个中括号只匹配一个字符grep &quot;s[ao]id&quot; test.txt# 匹配任意一个数字grep &quot;[0-9]&quot; test.txt# 匹配以小写字母开头的行grep &quot;^[a-z]&quot; test.txt# 匹配不用小写字母开头的行grep &quot;^[^a-z]&quot; test.txt# 匹配不用字母开头的行grep &quot;^[^a-zA-Z]&quot; test.txt 注意：中括号里面是不能匹配换行符的。 「\」示例12# 匹配使用「.」结尾的行grep &quot;\.$&quot; test.txt 注意：「.」在正则里面表示任意一个字符，所以这里要加转义符。 其他示例1234567891011# a 连续出现 3 次grep &quot;a\&#123;3\&#125;&quot; test.txt# 包含连续的 3 个数字的字符串所在行grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt# 匹配最少用连续三个数字开头的行grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt# 匹配在 s 和 i 之间，最少有一个 a，最多有三个 agrep &quot;sa\&#123;1,3\&#125;i&quot; test.txt 字符截取命令1、cut 字段提取命令「默认列之间的分隔符为 tab 键」1234567891011121314格式：cut [选项] 文件名选项： -f列号 提取第几列 -d分隔符 按照指定分隔符分割列举例： # 提取第二列 cut -f 2 test.txt # 提取第二、第三列，注意不是范围，是指定的列，中间以逗号分隔 cut -f 2,3 test.txt # 指定列之间的分隔符为「:」，默认为 tab 键 cut -d &quot;:&quot; -f 1,3 注意：grep 命令表示在指定的文件中提取匹配的行，cut、awk 命令用来提取匹配的列。cut 命令中列之间的默认分割符为制表符即 tab 键。命令 grep -v [内容]，表示列出不包含指定的内容的行。grep 确认行，cut 确认列，利用这两个命令可以做一些操作，比如，获取所有普通用户的用户名：cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1。 cut 命令有一个局限就是「无法」识别空格（指识别起来超级麻烦扩展性还差）。对于空格的判断我们使用 awk 命令，但是因为 awk 比较复杂，所以能用 cut 的尽量不要用 awk，因为 cut 简单，但是存在局限性。 2、printf 命令1234567891011121314151617181920212223格式：printf &apos;输出类型输出格式&apos; 输出内容输出类型： %ns 输出字符串。n 是数字，指代输出几个字符 %ni 输出整数。n 是数字，指代输出几个数字 %m.nf 输出浮点数。m 和 n 是数字，指代输出的整数位数和小数位数。 eg：%8.2f 代表共输出 8 位数，其中 2 位是小数，6 位是整数输出格式： \a 输出警告音 \b 输出退格键，即 Backspace 键 \f 清除屏幕 \n 换行 \r 回车，即 Enter 键 \t 水平输出 Tab 键 \v 垂直输出 Tab 键举例： # 注意以下命令中是否加了单引号或双引号 printf %s 1 2 3 4 5 6 printf %s %s %s 1 2 3 4 5 6 printf &apos;%s %s %s&apos; 1 2 3 4 5 6 printf &apos;%s %s %s\n&apos; 1 2 3 4 5 6 printf 是格式化输出命令，类似于 echo 命令。注意：printf 后面不能直接加文件名，也不能接受管道符的内容。但是可以使用 printf &#39;%s&#39; $(cat 文件名) 的形式输出命令执行结果，需要注意的是 printf 没有对格式进行任何调整。 printf 命令没有 cat 和 echo 的自动格式化功能，为什么还要学习 printf 命令，是因为在 awk 命令中不能调用系统命令 cat 或者 echo，只能使用 printf。 在 awk 命令的输出中支持 print 和 printf 命令： print：print 会在每个输出之后自动加入一个换行符（Linux 默认没有 print 命令）。printf：printf 是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符。 注意：print 只能在 awk 中使用。printf 命令在 Linux 系统中直接使用的几率不大，主要是在 awk 命令中使用。 3、awk 命令，注意单引号1234567891011121314151617181920格式: awk &apos;条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ...&apos; 文件名条件： 一般使用关系表达式作为条件 x &gt; 10 x &lt;= 10动作： 格式化语句 流程控制语句举例： # $2 表示第 2 列，$4 表示第 4 列 awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt df -h | awk &apos;&#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&apos;典例：获取系统中根分区硬盘的使用率，可以用来报警，如果超过80则给管理员提示。 df -h | grep 只有根分区才存在的字符串 | awk &apos;&#123;printf $5&#125;&apos; | cut -d &quot;%&quot; -f 1 注意：awk 命令虽然是列提取命令，但是它处理数据的时候，是先读入一行数据，然后把这行数据所有的内容都复制给对应的变量，$1 代表第一列，依次类推，然后再判断条件是否符合，对满足条件的执行相应的动作。 注意：awk 默认是以空格或者制表符作为分割符的。 注意：BEGIN 必须大写。它位于大括号前，表示它是一个条件，只有满足了这个条件，其后的动作才会被执行。BEGIN 的作用是：在所有的数据读取之前，执行其后面相对应的动作。注意所有的动作都要用单引号括起来。 BEGIN 表示最先执行 BEGIN 条件后面的动作 12# 在进行整正的数据读取之前，即 awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt，打印「This is a transcript.」这句话awk &apos;BEGIN&#123;printf &quot;This is a transcript. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt FS 内置变量FS 的作用是指定分隔符的。注意：awk 命令在处理的时候是先读入第一行数据，然后再执行相应的动作。 12345# 输出结果中，第一行数据没有按照预期输出awk &apos;&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd# 改进：读取第一条数据之前，先把分隔符变成「:」awk &apos;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd END 表示最后执行 END 条件后面的动作 12# 表示在输出 &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125; 动作中的内容之后，输出 &#123;printf &quot;The end. \n&quot;&#125; 动作中的内容awk &apos;END&#123;printf &quot;The end. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt 关系运算符 12获取成绩大于 87 的用户名，grep -v Name 的作用是去掉标题行cat test.txt | grep -v Name | awk &apos;$4 &gt;= 87 &#123;printf $2 &quot;\n&quot;&#125;&apos; 4、sed 命令sed 是一种几乎包括在所有 Unix 平台（包括 Linux）的轻量级流编辑器。sed 主要是用来将数据进行选取、替换、删除、新增的命令。 sed 其实不是截取命令，其实是一个流的编辑器。相当于一个编辑器。既然已经学了 vim，为什么还有学习 sed 呢？因为 vim 命令只能修改文件，不能直接修改命令结果里的内容。要想使用 vim 修改命令的输出，则需要先把输出保存到文件当中，然后再用 vim 修改文件。sed 不光可以修改文件，因为其是一个流编辑器，所以可以从管道符接受数据来进行修改，即 sed 支持管道符操作。实际操作中主要用在对命令的结果进行操作，但是在 shell 编程中，sed 是一个重要的流数据处理编辑器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647格式： sed [选项] &apos;[动作]&apos; 文件名选项： -n 一般 sed 命令会把所有数据都输出到屏幕，如果加入此选项，则只会把经过 sed 命令处理的行输出到屏幕 -e 允许对输入数据应用多条 sed 命令编辑 -i 用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出，不光输出的数据会更改，源数据文件也会被更改。动作： a \: 追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用「\」代表数据未完结 c \: 行替换，用 c 后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用「\」代表数据未完结 i \: 插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用「\」代表数据未完结 d: 删除，删除指定的行 p: 打印，输出指定的行 s: 字符串替换，用一个字符串替换另外一个字符串。格式为「行范围/s/就字符串/新字符串/g」举例： # 查看文件的第二行，会输出全部内容 sed &apos;2p&apos; test.txt # 只显示经过 sed 命令处理的行 sed -n &apos;2p&apos; test.txt # 针对管道符结果操作 df -h | sed -n &apos;2p&apos; # 删除第二到第四行的数据，但不修改文件本身 sed &apos;2,4d&apos; test.txt # 在第二行后追加 hello sed &apos;2a hello&apos; test.txt # 在第二行前插入两行数据 sed &apos;2i hello \ world&apos; test.txt # 数据替换 sed &apos;2c No such person&apos; test.txt # 在第三行中，把 90 替换成 99 sed &apos;3s/90/99/g&apos; test.txt # sed 操作的数据直接写入文件 sed -i &apos;3s/90/99/g&apos; test.txt # 同时把 zhangsan 和 lisi 替换为空 sed -e &apos;s/zhangsan//g;s/lisi//g&apos; test.txt 字符处理命令1、排序命令 sort12345678910111213141516171819202122格式： sort [选项] 文件名选项： -f 忽略大小写 -n 以数值型进行排序，默认使用字符串型排序 -r 反向排序 -t 指定分割符，默认分隔符是制表符 -k n[,m] 按照指定的字段范围排序。从第 n 字段开始，m 字段结束（默认到行尾）举例： # 排序用户信息文件 sort /etc/passwd # 反向排序 sort -t /etc/passwd # 指定分隔符「:」。用第三字段开头，第三字段结尾排序，就是只用第三字段排序（类比数据库 order by 后面可以跟多个字段） sort -t &quot;:&quot; -k 3,3 /etc/passwd # -n 表示将提取的字段当成数字来对待 sort -n -t &quot;:&quot; -k 3,3 /etc/passwd 条件判断（即测试一个条件是否成立）1、按照文件类型进行判断（记住蓝色的就行，其它的了解） 2、两种判断格式123456789101112格式一: # 注意该命令执行后没有任何输出，要想知道该命令的输出结果，可以使用 $? 来获取结果，「echo $?」打印结果 # $? 的作用是判断上一条命令是否正确执行，正确执行返回 0，否则返回其他数字 test -e /root/install.log格式二: # 注意两端必须有空格 [ -e /root/install.log ]举例: # 第一个判断命令如果正确执行，则打印 yes，否则打印 no [ -d /root ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 这种判断主要用在 Shell 脚本当中，而在脚本当中最常用的判断格式是用中括号。 3、按照文件权限进行判断 注意：以上权限部分不区分所有者、所属组、其他人，只要该文件有这个权限，就为真。 4、两个文件之间进行比较 5、两个整数之间比较-ne ： (not equal) 不相等-gt ： (greater than) 大于-lt ： (less than) 小于-ge ： (greater than or equal) 大于或等于-le ： (less than or equal)小于或等于 6、字符串的判断注意：== 会把参数当成字符串 7、多重条件判断]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(六)]]></title>
    <url>%2F2018%2F09%2F25%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(六) —— Shell 基础 Shell 概述1、Shell 是什么？Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统程序，用户可以用 Shell 来启动、挂起、停止甚至编写一些程序。 Shell 还是一个功能相当强大的编程语言。Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。 2、Shell 的分类Bourne Shell：从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh。 C Shell：C Shell 主要在 BSD (Berkeley Software Distribution，是一个操作系统的名称，衍生自 Unix，被称为伯克利 Unix) 版的 Unix 系统中使用，其语法和 C 语言相类似而得名。 Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh、ksh、Bash、psh、zhs；C 家族主要包括：csh、tcsh。 Bash (Bourne Again Shell): Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。 3、Linux 支持的 Shell在 「/etc/shells」文件中保存着当前系统支持的 Shell。注意：只要是系统支持的 Shell，我们就可以通过输入对应的 Shell 名字来进行切换。 4、echo 输出命令echo 是反射、回声的意思。是用来输出的命令。格式：echo [选项][输出内容]；选项：-e，支持反斜杠控制的字符转换。eg：echo &#39;Hello World!&#39; 注意：感叹号在 Shell 中有特殊的作用，所以这里使用单引号。 5、Linux 中常见的转义符 eg：echo -e &quot;ab\bc&quot; 删除左侧字符；输出结果：ac；分析：\b 代表的是退格键。eg：echo -e &quot;a\tb\tc\nd\te\tf&quot; 制表符与换行符。eg: echo -e &quot;\e[1;31m abcd \e[0m&quot; 带颜色输出内容；输出结果：红色的 abcd；分析：31m=红色；「\e[1;」表示开启颜色输出，「\e[0m」 表示结束颜色输出。 6、第一个 Shell 脚本 1234#!/bin/Bash#The first program#Author: YanChongsheng E-mail: yanchongsheng@gmail.comecho -e "YanChongsheng is the most handsome man in China." 注意：「#!/bin/Bash」这句话不是注释，而是标称，标称以下内容是 Shell 脚本。在 Linux 中以 # 号开头的是注释。 7、脚本执行 方式一：赋予执行权限，直接运行 赋予权限：chmod 755 hello.sh 运行脚本：./hello.sh 方式二：通过 Bash 调用执行脚本：bash hello.sh 注意：使用 base 执行脚本的时候，脚本甚至可以没有执行权限。它的意思是通过这个 Shell 来解释这个 shell 脚本文件，所以只要里面的内容是正确的，连执行权限都可以不用给就可以执行，但是最习惯的执行方法还是第一种。 cat 命令给其加上选项 -A ：表示查看所有的文件内容，包括隐藏字符，例如回车符就属于文件中的隐藏字符。在 Linux 中，回车符识别为「$」号。但是 Windows 中的回车符是「^M$」，表示这个 shell 是在 windows 中编辑完成的，要想在 Linux 中执行，就需要进行转换，利用命令: dos2unix [文件名]。注意：如果 dos2unix 命令没有则需要安装：yum -y install dos2unix。 Bash 的基本功能1、历史命令1234格式：histor [选项][历史命令保存文件]选项： -c 清空历史命令 -w 把缓存中的历史命令写入历史命令保存文件「~./bash_histor」 注意：每次登陆之后所敲的命令都会放在 history 即内存中，并不会放入 ~/.bash_history 文件，而是等正常退出以后，才会将内存中的历史命令写入到 ~/.bash_history 文件中的。注意：-c 会清除内存中和文件中的所有的历史命令。 历史命令默认会保存 1000 条，可以在环境变量配置文件「/etc/profile」中进行修改 HISTSIZE=1000 注意：重新登录以后才会生效。如果超过 1000，则删除第 1 条命令，保存第 1001 条命令。 历史命令的调用： 使用上、下箭头调用以前的历史命令 使用「!n」调用第 n 条历史命令 使用「!!」执行上一条命令 使用「!字符」执行最后一条以该字符串开头的命令 2、命令别名：设定命令别名：alias 别名=’原命令’。注意：用命令行方式定义的别名它只会临时生效，一旦系统重启，这个别名就会消失。查询命令别名：alias 别名 3、命令执行顺序 第一顺位：执行用绝对路径或相对路径执行的命令。 第二顺位：执行别名。 第三顺位：执行 Bash 的内部命令。 第四顺位：执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令。 输出环境变量：echo $PATH 让别名永久生效：vim /root/.bashrc 注意：修改的是用户对应家目录下的「./bashrc」文件。rc 可以简单的理解为 user config 的简写，取 user 的最后一个字母 r 和 config 的第一个字母 c 组成 rc。 删除别名：unalias 别名 4、Bash 常用快捷键 5、标准输入输出 设备 设备文件名 文件描述符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/stdout 1 标准输出 显示器 /dev/stderr 2 标准错误输出 6、输出重定向 注意：不是所有的命令都可以使用输出重定向的，这个命令必须得有输出才可以。注意：错误输出中，2 和 大于号之间不能有空格。 注意：「/dev/null」是 Linux 中的一个特殊文件，可以把它当成垃圾箱，相当于不保存任何输出。 7、输入重定向「注意：输入重定向了解即可」123456格式：wc [选项][文件名]选项： -c 统计字节数 (byte) print the byte counts -m 统计字符数 (character) print the character counts -w 统计单词数 (word) -l 统计行数 (line) 注意：wc 可以统计键盘输入，输入的行数、单词数、字节数，输入完成之后按 ctrl + d，结束并进行统计。注意回车换行符也会被当成字节进行统计。 把文件作为命令的输入：命令&lt;文件。eg：wc &lt; anaconda-ks.cfg 8、多命令顺序执行 eg：ls; date; cd /user; pwdeg: 命令 &amp;&amp; echo yes || echo no 命令 dd 是磁盘或者说是数据复制的命令，但是它不是 cp，cp 命令只能复制文件，但是 dd 命令能复制特殊文件，也能复制分区甚至整个硬盘，不仅复制分区或硬盘的数据，还复制分区或硬盘的文件系统。dd 主要是用来进行磁盘复制。 9、管道符1格式：命令1 | 命令2 命令1 的正确输出作为命令2 的操作对象。 注意：命令1 必须正确输出，否则命令2 不会正常执行。 10、grep 命令，在文件中搜索符合条件的字符串123456格式：grep [选项] &quot;搜索内容&quot;选项： -i 忽略大小写 -n 输出行号 -v 反向查找 (注意：-v 查找的是不匹配的行，即反向查找) --color=auto 搜索出的关键字用颜色显示 通配符 Bash 中的特殊符号 注意：通配符是用来匹配文件名的，起码在 Linux 系统当中是用来匹配文件名的。 $ 和 $() 的区别是：$ 是用于调用变量的值；而 $() 是用来引用系统命令。 Bash 的变量1、变量设置规则 变量名称可以由字母、数字、下划线组成，但是不能以数字开头。 在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。 变量用等号连接值，等号左右两侧不能有空格。 变量的值如果有空格，需要使用单引号或双引号包括。 在变量的值中，可以使用「\」转义符。 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名” 或用 ${变量名} 包含。 如果是把命令的结果作为变量值赋值给变量，则需要使用反引号或 $() 包含命令。 环境变量名建议大写，便于区分。 环境变量名大写，目的是为了区分。因为环境变量会让 Linux 当中所有的 Shell 都能使用，Linux 的系统命令也是在所有的 Shell 中都能使用，但是系统命令都是小写，为了让系统命令和环境变量区分开，建议把环境变量都写成大写。 2、变量分类 用户自定义变量 环境变量：这种变量中主要保存的是和系统操作环境相关的数据。 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。 预定义变量：是 Bash 中已经定义好的变量，变量名不能自定义，变量作用也是固定的。 其实位置参数变量是预定义变量的一种，由于位置参数变量相对来说较多，所以我们习惯上将位置参数变量单独作为一个分类。所以这两种变量的限制是一样的，只能更改值。 3、本地变量用户自定义变量又称为本地变量。「$变量名」的作用是调用变量。123456789101112131415# 定义变量aa=123# 变量叠加aa=&quot;$aa&quot;456 # 结果：123456aa=$&#123;aa&#125;789 # 结果：123456789# 变量调用echo $name# 变量查看set# 变量删除unset name set 命令：表示查看系统的所有变量，包括系统的环境变量，以及系统变量，自定义的变量。总结：变量的定义、叠加、调用、查看、删除；变量的概念、变量的规则、变量的分类。 4、环境变量是什么？用户自定义变量只在当前 Shell 中生效。（使用命令行定义的）环境变量会在当前 Shell 和这个 Shell 的所有子 Shell 当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的 Shell 中生效。 5、设置环境变量1234567891011# 声明变量export 变量名=变量值# 查询变量env# 删除变量unset 变量名# 将已经定义好的本地变量变为环境变量export 变量名 注意：系统当前本身就是在一个 Shell 里面，我们可以直接输入 csh、或 bash 表示进入对应的 Shell，而系统本身的 shell 就是 csh 或者 bash 的父 Shell，这样就创建了一个子 Shell，当然子 Shell 里面还可以有子子 Shell。 如何查询和确定 Shell 呢？使用命令 pstree，它的作用是确定进程数。 6、系统常见环境变量PATH：系统查找命令的路径。12345# 输出 PATHecho $PATH# PATH 变量叠加PATH=&quot;$PATH&quot;:/root/sh PS1：定义系统提示符的变量 eg：PS1=[\u@\h \W]\$。注意习惯在 $ 最后加一个空格，要不然你的命令会紧挨着提示符 # 或者 $。这种写法只是临时生效。 注意：env 是专门用来查看当前系统的环境变量的。严格来说 PS1 并不是环境变量，因为 env 命令查看不到，必须使用 set 命令查看。虽然它不是环境变量，但是它是系统预留专门用作定义系统操作环境的一个变量。它是环境变量的一个子分支。 注意：Linux 以冒号为分割符号。 7、位置参数 位置参数变量最大的作用就是向程序中传递需要的值。它的好处是可以在命令执行的同时接受参数。 注意：位置参数变量的名称和作用都是固定的。我们能做的只是在里面传入不同的值。 注意：要想进行数值运算，必须加 $(()) 双小括号括起来，它才能进行数值计算，这是 Linux Shell 的标准格式。 注意：$# 不会计算命令本身，它计算的仅仅只是参数。 $* 和 $@ 的区别：$* 中的所有参数看成是一个整体。$@ 中的每个参数看成是独立的。 8、预定义变量 其实位置参数变量就是预定义变量当中的一个分类，其特点是不能改变变量名，变量的作用也是固定的。 $? 用来接收和判断上一条命令是否正确执行。注意：&amp;&amp; || 利用的就是 $? 来判断上一条命令是否正确执行的。 9、接受键盘输入，read 会把键盘输入的数据赋值给后面的变量中123456格式：read [选项] [变量名]选项： -p &quot;提示信息&quot;：在等待 read 输入时，输出提示信息 -t 秒数：read 命令会一直等待用户输入，使用此选项可以指定等待时间 -n 字符数：read 命令只接受指定的字符数，就会执行 -s：隐藏输入的数据，适用于机密信息的输入 注意：如果不加 -n 选项，read 命令在回车以后才会结束，如果加了 -n 选项，则字符数达到 -n 执行的数字，则自动结束 read 并执行。 Bash 的运算符注意：Linux 的 Shell 中变量的类型默认都是字符串型。 1、declare 声明变量类型12345678格式：declare [+/-][选项] 变量名选项： -：给变量设定类型属性 +：取消变量的类型属性 -i：将变量声明为整型（integer） -x：将变量声明为环境变量 -p：显示指定变量的被声明的类型 2、数值运算1234567891011121314aa=11bb=22# 方法1declare -i cc=$aa+$bb# 方法2# 利用 expr 或 let 数值运算工具。注意：「+」号左右两侧必须有空格。cc=$(expr $aa + $bb)# 方法3# $((运算式)) 或 $[运算式]cc=$(($aa+$bb))cc=$[$aa+$bb] 3、运算符 注意：此处数字越大，优先级越高。 4、变量测试与内容替换 主要作用：通过 x 的值来确定 y 的情况。这块内容了解即可，完全可以 if 语句来替代，只是系统提供的更简洁、高效一点，用到的时候查一下能看懂就行，不要可以去记忆。 环境变量配置文件1、source 命令123格式：source 配置文件或格式：. 配置文件 注意：source 命令的作用是让你的配置文件生效，即让系统重新读取一遍配置文件。（正常情况下配置文件生效需要重新登录一次，但是利用 source 命令可以直让配置文件生效）。注意：点「.」和配置文件之间有空格，点「.」其实就是 source 的缩写。 2、环境变量配置文件简介环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如 PATH、HISTSIZE、PS1、HOSTNAME 等默认环境变量。 系统中主要的 5 类环境变量配置文件： /etc/profile 的作用：USER 变量、LOGNAME 变量、MAIL 变量、PATH 变量、HOSTNAME 变量、HISTSIZE 变量、umask、调用 /etc/profile.d/*.sh 文件。 ~/.bash_profile 的作用：调用了 ~/.bashrc 文件、在 PATH 变量后面加入了 「:$HOME/bin」这个目录。 ~/.bashrc 的作用：定义默认别名、调用 /etc/bashrc。 /etc/bashrc 的作用：PS1 变量、umask、PATH 变量、调用 /etc/profile.d/*.sh 文件。 /etc/profile.d/*.sh 注意：只要是保存在 /etc 目录中的，表示对所有登录到该 Linux 系统的用户都生效。~/ 表示当前用户的家目录，「.」表示该文件是隐藏文件，这些配置文件针对的是当前用户。「~」表示家目录的意思。 3、环境变量配置文件作用 注意：环境变量默认赋值的时候分两种情况1.一种是用户通过输入用户名和密码的正常登陆。2.一种是用户通过命令切换到子 Shell 的登陆，这种情况是没有输入用户名密码过程的。这两种不同的登陆方法，它读取的配置文件是不一样的。 注意：环境变量配置文件它们之间是有优先级的。越后面读取的配置文件，其优先级越高，因为后面定义的变量会覆盖前面的变量。 需要输入用户名密码的正常登录情况配置文件的读取顺序：/etc/profile「 ——&gt; …… ——&gt; /etc/sysconfig/i18n (新版的 Linux 为 /etc/locale.conf) 这些都是 /etc/profile 文件中调用的子文件或子子文件」当完成 /etc/profile 的所有调用以后 /etc/profile 就会将它的调用传递给下一个环境变量配置文件即 ~./bash_profile，然后照着上图依次往下传递。 发现 /etc/profile 和 /etc/bashrc 中有很多内容是重复的，如 PATH、umask、PS1，注意这个不是单单只是重复。你会发现 /etc/bashrc 中重复定义变量的地方有这样的注释「We’re not a login shell」即该文件定义的是没有登录情况的 Shell 的环境变量。 4、注销时生效的环境变量配置文件~/.bash_logout 默认为空，可以在里面写一些退出登录时候的操作，比如清空历史命令等操作。 5、其他配置文件~/.bash_history 历史命令保存的地方。一般不要清空，但是有一种情况例外，比如你给某个服务设置密码，如 mysql，mysql 设置密码的时候使用的是明文（注意：是明文）系统命令，它会把密码记录在历史文件中，所以要清空明文密码记录。 6、Shell 登录信息1.本地终端欢迎信息：/etc/issue 注意：欢迎信息不要写 welcome 之类的，应该写的是警告信息。注意：针对的是本地登录。 2.远程 终端欢迎信息：/etc/issue.net注意：转义符在 /etc/issue.net 文件中不能使用，即本地终端的转义符在这里都不能使用，这里只能写纯文本信息。是否显示此欢迎信息由 ssh 的配置文件 /etc/ssh/sshd_config 决定，加入「Banner /etc/issue.net」行才能显示。（记得重启 ssh 服务）。重启 ssh 服务：service sshd restart 3.本地和远程登录后欢迎信息：/etc/motd不管是本地登录，还是远程登录，都可以显示此欢迎信息。但是，它是登录后的欢迎信息。刚才那两个文件是登录前的提示信息。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2018%2F09%2F21%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式 &lt;! – more –&gt; 1、工厂模式（Factory Pattern），属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。即告诉对象工厂我需要一个什么样的对象，然后就可以坐等对象工厂返回你需要的对象了。 2、简单工厂模式到底要实例化哪个类，将来会不会增加实例化对象的种类，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂。 参考博客[大话设计模式][菜鸟教程]]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐阅读]]></title>
    <url>%2F2018%2F09%2F20%2F%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[记录在工作学习个人认为优秀的博客 1、阮一峰的网络日志 2、廖雪峰的官方网站 3、Linux 命令大全 4、左耳朵耗子 5、GitBook]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(七)]]></title>
    <url>%2F2018%2F09%2F19%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%83)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(七) —— 随机 1、Random 类的构造方法可以接受一个 long 类型的种子参数。种子决定了随机产生的序列，种子相同，产生的随机数序列就是相同的。 2、为什么要指定种子？指定种子是为了实现可重复的随机。 3、Random 产生的随机数不是真正的随机数，相反，它产生的随机数一般称之为伪随机数，真正的随机数比较难以产生，计算机程序中的随机数一般都是伪随机数。 4、伪随机数都是基于一个种子数的，然后每需要一个随机数，都是对当前种子进行一些数学运算，得到一个数，基于这个数得到需要的随机数和新的种子。 5、Random 类是线程安全的，也就是说，多个线程可以同时使用一个 Random 实例对象，不过，如果并发性很高，会产生竞争，这时，可以考虑使用多线程库中的 ThreadLocalRandom 类。 参考博客Java编程的逻辑 —— 随机]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(六)]]></title>
    <url>%2F2018%2F09%2F19%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(六) —— 剖析日期和时间 1、关于时区英国格林尼治是 0 时区，北京是东八区，也就是说格林尼治凌晨 1 点，北京是早上 9 点。0 时区的时间也称为 GMT+0 时间，GMT 是格林尼治标准时间，北京的时间就是 GMT+8:00。 2、时刻和 Epoch Time(纪元时)所有计算机系统内部都用一个整数表示时刻，这个整数是距离格林尼治标准时间 1970年1月1日0时0分0秒 的毫秒数。格林尼治标准时间 1970年1月1日0时0分0秒 也被称为 Epoch Time (纪元时)。这个整数表示的是一个时刻，与时区无关，世界上各个地方都是同一个时刻。而对于 1970 年以前的时间则使用负数表示。 3、年历公历和农历都是年历。年历就是对一年有多少月，每月有多少天，甚至一天有多少小时的规则定义。 时刻是一个绝对时间，对时刻的解读，如年月日周时分秒等，则是相对的，与年历和时区相关。 Date：表示时刻，即绝对时间，与年月日无关。 Calendar：表示年历，Calendar 是一个抽象类，其中表示公历的子类是 GregorianCalendar。 DateFormat：表示格式化，能够将日期和时间与字符串进行相互转换，DateFormat 也是一个抽象类，其中最常用的子类是 SimpleDateFormat。 TimeZone: 表示时区。Locale: 表示国家和语言。 4、Date 表示时刻，内部主要是一个 long 类型的值 private transient long fastTime; 几乎所有的未过时的方法都是对该值进行操作的。 5、Calendar 类是日期和时间操作中的主要类，它表示与 TimeZone 和 Locale 相关的日历信息，可以进行各种相关的运算。 Calendar.MONTH：表示月，一月份是 0。Calendar.DAY_OF_MONTH：表示日，每月的第一天是 1。Calendar.DAY_OF_WEEK：表示星期几，周日是 1，周一是 2，周六是 7。 内部，Calendar 会将表示时刻的毫秒数，按照 TimeZone 和 Locale 对应的年历，计算各个日历字段的值，存放在 fields 数组中，Calendar.get 方法获取的就是 fields 数组中对应字段的值。 内部，根据字段设置或修改时间时，Calendar 会更新 fields 数组对应字段的值，但一般不会立即更新其他相关字段或内部的毫秒数的值，不过在获取时间或字段值的时候，Calendar 会重新计算并更新相关字段。 6、DateFormat 类主要在 Date 和字符串表示之间进行相互转换。 7、DateFormat/SimpleDateFormat 不是线程安全的，因为 DateFormat 内部使用了一个 Calendar 实例对象，多线程同时调用的时候，这个 Calendar 实例的状态可能就会紊乱。 8、总结：Date 表示时刻，与年月日无关，Calendar 表示日历，与时区和 Locale 相关，可进行各种运算，是日期时间操作的主要类，DateFormat/SimpleDateFormat 在 Date 和字符串之间进行相互转换。 9、Joda 的主要工作都是在毫秒和年月日等年历信息之间进行相互转换。 10、Joda-Time 中的主要类都被设计为了不可变类，不可变类有一个很大的优点，那就是简单、线程安全，所有看似的修改操作都是通过创建新对象来实现的。 参考博客Java编程的逻辑 —— 剖析日期和时间Java编程的逻辑 —— Joda-Time]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(五)]]></title>
    <url>%2F2018%2F09%2F19%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[1、在 Linux 中，umask 的默认值为 022，用来定义默认新建文件的缺省权限。直接执行 umask 命令会得到一个 4 位的数字：0022 第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认的权限 rwxr-xr-x。 注意：在 Linux 权限管理有一个最基本的定义：缺省创建的文件是不能具有可执行权限的。在 Linux 系统中任何新建的文件都会把可执行权限去掉。所以新建文件实际的权限为 777-022-111 = 644，即rw-r–r–。 2、RHEL 的全称是 Red Hat Enterprise Linux 红帽企业版 Linux。 3、「n1,n2d」删除 n1 到 n2 行。例如：删除 1 到 10 行「:1,10d」。「n，$d」删除从某行开始至文本末尾。例如：删除第 8 行至末尾「:8,$d」。在 vim 中，0 表示行首，$ 表示行尾。 4、在内存小于 2G 的情况下，交换分区应为内存的 2 倍，超过 2G 的话，交换分区为物理内存加上 2G。 Red Hat 官方文库中有一段话：目前 Red Hat（红帽官方）推荐交换分区的大小应当与系统物理内存的大小保持线性比例关系。不过在小于 2GB 物理内存的系统中，交换分区大小应该设置为内存大小的两倍，如果内存大小多于 2GB，交换分区大小应该是物理内存大小加上 2GB。其原因在于，系统中的物理内存越大，对于内存的负荷可能也越大。 5、内核分为：进程管理子系统、内存管理子系统、I/O 管理子系统、文件管理系统 4 部分。 6、UNIX 系统由内核、shell、文件系统和应用程序 4 部分组成。 7、系统调用有 5 个分别为：open、write、read、close、ioctl。 所谓系统调用，就是内核提供的、功能十分强大的一系列的函数。这些系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。 整个系统调用的过程总结如下： 执行用户程序(如: fork) 根据 glibc 中的函数实现，取系统调用号并执行 int $0x80 产生中断。 进行址空间的转换和堆栈的切换，执行 SAVE_ALL（进行内核模式）。 进行中断处理根据系统调用表调用内核函数。 执行内核函数。 执行RESTORE_ALL并返回用户模式。 8、cat 有三个功能： 一次显示整个文件。「cat filename」 从键盘创建新文件，但是不能编辑已有文件。「cat &gt; filename」 将几个文件合并为一个文件。「cat file1 file2 &gt; file」 9、Linux下进程通信的八种方法：管道(pipe)，命名管道(FIFO)，内存映射(mapped memeory)，消息队列(message queue)，共享内存(shared memory)，信号量(semaphore)，信号(signal)，套接字(Socket)。 10、ssh 用于远程登录；scp 是 secure copy 的缩写，用于远程数据传输。 11、MMU(Memory Management Unit) 内存管理单元，是中央处理器用来管理虚拟内存和物理内存寄存器的控制线路，同时也负责虚拟内存映射为物理内存等。即在 CPU 和物理内存之间进行地址转换，将地址从逻辑空间映映射到物理地址空间。 12、压缩解压命令 tar1234567格式：tar [选项] [压缩后文件名] [目录]选项： -c(create) 打包 -x(extract) 解包 -v(verbose) 显示详细信息 -f(file) 指定文件名 -z(gzip) 打包同时压缩/解压缩 13、内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file 对象，file 对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的 file 对象。需要注意的是，file 对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的 file 对象，从而共享这个打开的文件。file 对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为 0 时，内核才销毁 file 对象，因此某个进程关闭文件，不影响与之共享同一个 file 对象的进程。 14、查找当前目录不包括子目录命令：find . -name &quot;*.c&quot; -maxdepth 1。最大深度为 1，表示当前目录。如果为 0，则表示只对命令行参数有效。 注意：符号「&gt;」是定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空； 可以把一块网卡设置多个IP地址，eg：eth0:1表示加了一个虚拟网卡，意思是给网卡绑定多一个IP地址。 7、wc -l # 统计行数wc -w # 统计单词数量]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(五)]]></title>
    <url>%2F2018%2F09%2F18%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(五) —— Arrays 类 1、Java 中的 Arrays 类中包含一些对数组操作的静态方法。 2、Arrays 的 toString 方法可以方便的输出一个数组的字符串形式。 3、数组排序之基本类型，对指定类型的数组按升序进行排序。sort 方法还可以指定排序范围 [fromIndex, toIndex)。 4、数组排序之对象类型，sort 还可以直接接受对象类型，但对象需要实现 Comparable 接口。 5、数组排序之自定义比较器，sort 还可以接受一个比较器作为参数。Comparator 就是比较器，它是一个接口，最主要的是 compare 这个方法，它比较两个对象，返回一个表示比较结果的值，-1 表示 o1 小于 o2，0 表示相等，1表示 o1 大于 o2。排序是通过比较来实现的，sort 方法在排序的过程中，需要对对象进行比较的时候，就调用比较器的 compare 方法。 6、需要注意的是 binarySearch 针对的必须是已排序数组，如果指定了 Comparator，需要和排序时指定的 Comparator 保持一致，另外，如果数组中有多个匹配的元素，则返回哪一个是不确定的。 7、在创建多维数组时，除了第一维的长度需要指定外，其他维的长度不需要指定，甚至，第一维中，每个元素的第二维的长度可以不一样。 8、多维数组到底是什么呢？其实，可以认为，多维数组只是一个假象，只有一维数组，只是数组中的每个元素还可以是一个数组，这样就形成二维数组，如果其中每个元素还都是一个数组，那就是三维数组。 9、Arrays 类的 sort 实现原理： 基本数据类型数据：双枢轴快速排序(Dual-Pivot Quicksort)；是一种对快速排序（不稳定）进行优化后的算法； 引用数据类型数据：TimSort；是一种对归并排序（稳定）进行优化后的算法； 它们之所以没有采用相同的排序算法，跟排序算法的稳定性有关。快速排序更快，但不稳定，而归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没有关系。但对于对象类型，相同只是比较结果一样，它们还是不同的对象，其他实例变量也不见得一样，稳定不稳定可能就很有关系了，所以采用归并排序。 10、Comparator 接口和 Comparable 接口？Comparable 接口和 Comparator 接口的比较 参考博客Java编程的逻辑 —— 剖析 Arrays]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(四)]]></title>
    <url>%2F2018%2F09%2F17%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(四) —— Vim 编辑器 Vim 简介 Vim 有三种命令模式。可以使用 vim 加上任何一个已经存在或者你想创建的文件名就可以进入 Vim 默认的命令模式。vi 和 vim 都是命令，两个的效果一模一样，一个是早期的一个是 Vi 的增强版（全名 Vi imporove 简称 Vim） 。Vim 命令默认进入的是命令模式，在该模式下，你敲的任何一个字符系统都会当成命令来处理。要想进入文本的插入模式，你需要输入插入命令，比较常用的有 i、a、o 就会进入到插入模式，要想退出插入模式，则可以使用 Esc 键，表示退出插入模式，但是此时进入到的是命令模式，此时你输入的任何内容都会被当成命令。在命令模式里面按「：」冒号就会进入到编辑模式，此时输入的就是编辑模式的命令了，即你输入的内容都会被当成是编辑模式的命令。比如设置行号命令：set number（简写：set nu）。编辑模式的命令执行完成以后它会自动的回到命令模式，所以冒号后面输入的内容才是编辑模式的命令。保存退出命令模式：「:wq」。 命令模式和编辑模式常用命令 注意：在使用小 a 的时候光标会自动往后跳一格，例如：we 光标现在在 w 上，按 a以后光标自动跳到 e 上，然后在 e 的前面插入，实际上就是在 w 的后面插入。 注意：上图中前面有冒号的表示编辑模式命令，没有冒号的表示命令模式命令。 Linux 中的查找是严格区分大小写的，但是我们可以设置忽略大小写。「:%s 表示全局替换」「g 表示替换的时候不询问」「c表示替换的时候要询问」 Vim 使用技巧 「:r 文件名」可以导入一个文件的内容到当前 vim 编辑的文件之中。eg：「:r /etc/issue」导入的位置为刚才你光标所在的位置。 「:!命令」可以在不退出 vim 的情况下，执行系统响应的操作命令。eg：「:!which ls」 「:r!命令」将一个命令的执行结果导入到当前的 vim 文件里面。eg：「:r!date」 自定义快捷键「:map 快捷键 触发命令」。eg：「:map ^p I#」^p 表示 ctrl + p 的快捷键，该快捷键代表的命令是：跳到行首并进入插入模式，插入 # 号，然后退出。eg：「:map ^b 0x」表示用快捷键 ctrl + b 表示删除行首字母。 注意：设置快捷键的方式是，使用 ctrl + v + 所需字母；或者先按 ctrl + v，再按 ctrl + 所需字母，效果是一样的。这种是构造 ctrl + 字母的快捷键的方法。 连续行注释：「n1,n2s/^/#/g」表示从 n1 行开始到 n2 行，每行的行首都增加 # 号，并且替换的时候不询问。去掉连续行注释：「n1,n2s/^#//g」表示从 n1 行开始到 n2 行，每行的行首的 # 号都替换为空，并且替换的时候不询问。如果注释符是「//」则需要转义：「:n1,n2s/^/\/\//g」表示从 n1 行开始到 n2 行，每行的行首都增加 // 号，并且替换的时候不询问。注意：「^」表示行首的意思。注意：在 Linux 中「\/」中「\」表示转义符的意思「/」它才是真正的符号。 替换命令：「:ab 旧内容 新内容」即「:ab a b」这个命令可以简单的理解为：当你输入 a，它会自动的帮你转换成 b。eg: 「:ab sb hello」 当前输入 sb 的时候，会自动的替换成 hello。 注意：以上定义的快捷键重启以后都不存在，要想永久生效，你需要将其定义在每个用户的宿主（家）目录中的配置文件里面。以 root 为例：vi /root/.vimrc (注意这个配置文件叫 .vimrc)这里面只能放一些编辑模式的命令：比如设置行号、设置快捷键、ab 命令（前面可以没有冒号「:」）。 参考博客]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(三)]]></title>
    <url>%2F2018%2F09%2F12%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(三) —— Linux 网络 mkdir(make directories) cd(change direcotry) pwd(print working directory) rmdir(remove empty directories) cp(copy) -r(directory) -p(property) mv(move) rm(remove) -r(directory) -f(force)mkdir 创建一个新的目录 -p 创建一个新的目录的同时用 -p 再递归创建一个子目录；cd 切换目录；pwd查看当前的工作目录；rmdir 删除一个空目录；cp 复制文件 -r 复制目录 -p复制的时候保持文件的属性；mv 剪切或者给一个文件改名；rm 删除文件 -r 删除目录 -f删除目录或者文件的同时不希望询问确认；]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(三)]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[求实英语(三) —— 过去时 1、你去年经常拜访他们吗？Did you ofter visit them last year? 2、三年前你对这种工作有多少经验？我的：How much experience did you have for this job three years ago?答案：How much experience in this kind of work did you have three years age? 3、我没及时告诉她，因为我病了。我的：I don’t tell her in time, because i was ill.答案：I din’t tell her in time, because i was ill. 4、我上周就认知他了，可他却一点儿也不了解我。我的：I knew him last week, but he don’t know me little.答案：I knwe him last wekk, but he didn’t know me at all. 5、昨天你和王先生在哪儿？where were you with Mr. Wang yesterday? 6、你见过那个新来的老板了吗？我的：Do you have seen the new boss?答案：Have you seen that new boss? 7、去年她像妈妈，可今年谁也不像。(此处 like 当介词)我的：She was like her mother last year, but she isn’t like anyone this year.答案：She was like her mother last year, but she is like no noe this year. 8、 谁问有关我学习的事儿来着？我的：Who was asked me about my study？答案：Who has asked something about my study? 9、爸爸昨晚没有责怪我。Our father did’t scold me last night. 10、昨天你在哪儿听到的那个消息？我是从报纸上看到的。where did you hear that news yesterday？I read it from the paper. 11、我的电脑又出毛病了。我的：My computer has broken again.答案：Something was wrong again with my computer. 12、昨天我很紧张，你呢？I was very nervous yesterday, and how were you? 13、你们的值日生昨天擦黑板了吗？Did your students on duty clean the blackboard yesterday? 14、今天上午李先生出什么事了？我的：What did happend with Mr.Li this forenoon？答案：What happended to Mr. Li this morning? 15、由于贫穷他去年就辍学了，我们去看看他吧。我的：Because of poverty he droped out school last year, we are looking at him tomorrow.答案：He quit school last year because of being poor, Let’s go to see him tomorrow.]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(二)]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[求实英语(二) —— 主谓宾 1、他整天没地方去也没事儿干。He goes nowhere and has nothing to do every day. 2、她天天在哪儿吃午饭？Where does she have lunch every day? 3、你怎么不常和他们一块儿来？Why don’t you often come with them? 4、王芳有姐姐吗？Does WangFang have any sisters? 5、为什么他总听你的而不听我的？我不知道。Why does he always listen to you but doesn’t listen to me? I don’t know. 6、他了解你多少？你非常了解他吗？How much does he know you? Do you know him very well? 7、你们每周怎么去那儿?How do you get there every week? 8、李梅不知道那事儿，但我知道。LiMei doesn’t know that but me. 9、每天下班后，Tod 都载我回家。Tod picks me up home after work every day. 10、这些小狗都叫什么？它的名字是 TianTian,那只叫 LeLe。What are these dogs’ names? Its name is TianTian, that is called LeLe. 11、他准时上学并及时做作业。He goes to school on time and does his homework in time. 12、没人相信他，因为他经常撒谎。他太丢人了。Nobody believes him because he often tell lies. He is very shameful. 13、你妈把我的手表放什么里边了？what does your mother put my watch in? 14、我像他，但却不喜欢他。I am like hime, but I don’t like him. 15、你这么辛苦工作是为了什么？what do you work hard for? 注意事项on time 准时in time 及时]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门总结(四)]]></title>
    <url>%2F2018%2F09%2F11%2FDocker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Docker 入门总结(四) 1、Docker 包括三个基本概念：镜像（Image）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器（Container）：容器的实质是进程。镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 仓库（Repository）：一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 2、$ docker run -it --rm ubuntu:16.04 bash-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。 3、$ docker system df通过以上命令来便捷的查看镜像、容器、数据卷所占用的空间。 4、docker image ls 选项：默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。-q 只列出镜像的 ID。 5、Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 Dockerfile 指令1、FROM 指定基础镜像，一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 2、RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。 3、COPY 复制文件 COPY &lt;源路径&gt;… &lt;目标路径&gt;COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”] 4、ADD 更高级的复制文件ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。这个功能其实并不实用，而且不推荐使用。 5、CMD 容器启动命令 shell 格式：CMD &lt;命令&gt;exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 6、ENTRYPOINT 入口点ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。 7、ENV 设置环境变量 ENV ENV = =… 8、VOLUME 定义匿名卷 VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]VOLUME &lt;路径&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[求实英语(一)]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[求实英语(一) —— 主系表 1、我姐姐在那儿吗？她和谁在一起呢？ 我的：Is my sister at there? whom is my sister with?答案：Is my sister there? whom is she with? 解析：there 在这里是名词，表示哪个地方的意思，所以不用 at。问句中用她来指代我姐姐。 2、我妈妈没在家，她和街坊出去了。 我的：My mother is not at home, she is with neighborhood out.答案：My mother is not at home, she is out with some neighbors. 解析：out 在 这里是形容词，表示外面的。 3、那本书怎么样？它在你的手里吗？ 我的：How is that book? Is it in your hand?答案： 4、这是给我的，那些是给谁的？ 我的：This is for me, whom are those for?答案： 5、Sam Sterm 根本就没在这儿，他每天在二楼办公。 我的：Sam Sterm is not here at all, he is at second floor everday.答案：Sam Sterm is not here at all, he is at work on the 2nd floor ever day. 解析：在工作用 at work 表示，在二楼用 at 2nd floor 表示，everday 是形容词每天的，而不是每天，这个是副词。 6、他是干什么的？他不是经理吗？ 我的：What is he? Is not he a manager?答案： 7、你的小狗在哪儿？它在什么里边？ 我的：Where is your dog? What is it in?答案： 8、这是谁的办公室？里边有人吗？哪间办公室是你的？ 我的：Whom is this office? Who is in the office? Which is your office?答案：Whose office is this? Is anyone in? Which office is yours? 9、我的电话出了毛病，手机在哪儿？ 我的：My phone is wrong, where is cell phone?答案：Something is wrong with my telephone,where is the cellphone? 10、电视开着呢，把它关上吧！ 我的：The TV is on, turn it off!答案： 11、我的备份没在你的电脑里吗？ 我的：Is not my copy in your computer?答案： 12、这是干什么用的？ 我的：What is this for?答案： 13、我的手机昨天就在这儿放着呢! 我的：My cellphone was right here yesterday!答案： 14、这个书包是谁的？那是谁的书包？我的在这儿！她的呢？ 我的：Whose bag is this? Whose bag is that? My bag is here! Where is her bag?答案：Whose is this bag? Whose bag is that? Mine is here! where is hers? 15、这本字典不像我的，但那本像。 我的：This dictionary is not like mine,bug that is like.答案：This dictionary is not like mine,bug that one is. 注意事项1、注意区分以下两种形式：Whose is this bag？这个包是谁的？ This bag is whose.Whose bag is this？这是谁的包？ This is whose bag. 2、区分 我、你、他 这些代词的各种形式： 主格 宾格 属格 属格(名词性) I me my mine you your your yours he him his his she her her hers it its its its they them their theirs 参考博客英语代词有哪些？]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java入门总结(四)]]></title>
    <url>%2F2018%2F09%2F10%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(三)]]></title>
    <url>%2F2018%2F09%2F10%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(三) —— NIO Buffer1、在 Java 中，已有的 IO 操作大部分都属于阻塞的操作。为了提升服务器操作的性能，在 JDK1.4 之后增加了 NIO，在整个 NIO 的操作中，基本上都是使用缓冲区完成的。 2、public abstract class Bufferextends Object 抽象类 Buffer 是一个用于特定基本类型数据的容器。 3、缓冲区是特定基本类型元素的线性有限序列。除内容外，缓冲区的基本属性还包括容量、限制和位置： 缓冲区的 容量(capacity) 是它所包含的元素的数量。缓冲区的容量不能为负并且不能更改。缓冲区的 限制(limit) 是第一个不应该读取或写入的元素的索引。缓冲区的限制不能为负，并且不能大于其容量。缓冲区的 位置(position) 是下一个要读取或写入的元素的索引。缓冲区的位置不能为负，并且不能大于其限制。 对于每个非 boolean 基本类型，此类都有一个子类与之对应。 4、标记、位置、限制和容量值遵守以下不变式： 0 &lt;= 标记 &lt;= 位置 &lt;= 限制 &lt;= 容量 。 5、清除、反转和重绕 clear() 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为容量大小，将位置设置为 0。flip() 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为当前位置，然后将位置设置为 0。rewind() 使缓冲区为重新读取已包含的数据做好准备：它使限制保持不变，将位置设置为 0。 6、直接 与 非直接缓冲区字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。 直接字节缓冲区可以通过调用此类的 allocateDirect 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 直接字节缓冲区还可以通过 mapping 将文件区域直接映射到内存中来创建。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。 Channel1、在 NIO 中，通道是一个可以用来读取和写入数据的一种形式。Channel 接口，用于 I/O 操作的连接。通道表示到实体的开放连接。 通道表示到实体，如硬件设备、文件、网络套接字或可以执行一个或多个不同 I/O 操作（如读取或写入）的程序组件的开放的连接。通道都是通过操作缓冲区来完成全部功能的。所有的内容都是先读或写到缓冲区之中，再通过缓冲区读或写入到通道中的，即程序不会直接操作通道。 2、Java NIO Channel 通道和流非常相似，主要有以下几点区别： 通道可以读也可以写，流一般来说是单向的（只能读或者写）。通道可以异步读写。通道总是基于缓冲区Buffer来读写。 3、什么是内存映射？将文件中的某个区域直接映射到内存中；对于较大的文件，这通常比调用普通的 read 或 write 方法更为高效。 在通道中还有一种方式成为内存映射。内存映射是速度最快的，MapperedByteBuffer，使用此种方式读取的内容是最快的，需要将一个输入的操作流绑定在内存映射上。 内存映射在读取的时候是最快的，但是如果执行的是写入操作则有可能是非常危险的，因为仅仅只是改变数组中的单个元素这样简单的操作就可能直接修改磁盘上的文件，因为修改数据与将数据保存在磁盘上是一样的。 文件锁在 Java NIO 中提供了文件锁的功能，这样当一个线程将文件锁定之后，其他线程是无法操作此文件的，要想进行文件的锁定操作，则要使用 FileLock 类完成，此类的对象需要依靠 FileChannel 进行实例化操作。 锁定方式： 共享锁：允许多个线程进行文件的读取操作。独占锁：只允许一个线程进行文件的读/写操作。 Selector推荐阅读Java NIO 浅析Java NIO Channel 通道]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(二)]]></title>
    <url>%2F2018%2F09%2F06%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(二) —— Linux 系统安装 磁盘分区磁盘分区又叫系统分区，是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。从字面意思来讲，磁盘分区指的就是把大的硬盘按照我的需求划分成几个分区，不同类目录与文件可以存储进不同的分区。 分区类型 主分区：最多只能有 4 个。 扩展分区「是从主分区的 4 个分区之中拿出 1 个分区作为扩展分区」： 扩展分区最多只能有 1 个（注意：针对一块硬盘来讲，一个硬盘最多只能有一个扩展分区）。 主分区加扩展分区最多只能有 4 个。 扩展分区本身不能写入数据也不能格式化，唯一的作用就是用来包含逻辑分区。 逻辑分区「即扩展分区中的逻辑分区」：可以正确的写入数据和格式化。按照硬盘的限制，一块硬盘最多只能分 4 个分区，即 4 个主分区。这种限制不是 Linux 系统的限制而是硬盘本身的限制，只要硬盘结构不发生变化，这种限制会一直存在。 格式化硬盘正确分区以后还不能写入数据，硬盘还必须经过格式化以后才可以写入数据。 格式化 (高级格式化) 又称逻辑格式化，它是指根据用户选定的文件系统（如 fat16、fat32、NTFS、ext2、ext3、ext4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。 在 windows 中可以识别的文件系统有 fat16、fat32、NTFS，在 linux 中可以识别的文件系统有 ext2、ext3、ext4，centOS 默认使用的是 ext4。 硬盘的格式化最主要的目的就是为了在硬盘当中写入文件系统，写入文件系统最主要的工作就是按照文件系统的规则把硬盘分成等大小的数据块，然后建立 iNode 表，我们把表里的编号称为 i 节点号又名 iNode 号。 当在查找文件的时候，是通过 iNode 表找到 i 节点号来找到这个文件的条款，从而知道这个文件保存在哪几个数据块之中，从而找到这几个数据块拿出文件，拼凑成我们的文件。这个格子就叫做数据块，又名 block。 在 centos 当中，默认的文件系统是 ext4，它在进入格式化的时候，它需要把硬盘划分为一个又一个等大小的数据块，这个数据块默认的标准大小为 4kb。假如有一个数据是 10kb，需要占用 3 个格子，最后一个格子只放了 2kb 数据，剩余的 2kb 空闲空间是不能再被其它文件所占用的，这 3 个格子不一定在一块。windows 中有一个磁盘碎皮整理，它的原理就是将保存的同一个文件的格子尽量放到一起，这样更有利于数据的读取。 硬件设备文件名如果是 windows，在进行了分区、格式化之后，给分区分配盘符然后就可以直接使用了。但是 Linux 不行，Linux 在进行了分区、格式化，格式化完成之后，要想给分区分配盘符之前，还必须给每一个分区起一个设备文件名，或者说给每一个分区起一个硬件设备文件名。 在 Linux 中所有的硬件设备都是文件。 「/」表示 Linux 中的最高一级目录，也就是根目录。在根目录下有一个 dev 的一级子目录，在 dev 目录中放入的所有的文件都是硬件文件。我们将硬件文件名，称为硬件的设备文件名。 为什么 Linux 需要「硬件设备文件名」而 windows 不需要？在 windows 中，硬盘分区、格式化之后，然后可以直接分配盘符是因为我们可以在 windows 的图形界面中直接看到这个硬盘在哪（注意：一台机器可能有多个硬盘），所以可以直接分配盘符（windows 有完善的图形界面）。但是 Linux 最早出现的时候，是没有图形界面的，为了让系统知道我要给哪一个硬盘分配盘符，所以被迫需要给每一个硬盘或者硬件设备指定设备文件名。 硬件设备文件名是固定的，系统自动检测的，我们能看懂就行。 关于硬盘，我们现在主要使用的是 SATA 硬盘接口，IDE、SCSI 硬盘接口基本被淘汰了。 分区设备文件名硬盘有了「硬件设备文件名」，还要给分区也要分配文件名，这就是「分区设备文件名」。「分区设备文件名」是在硬盘「硬件设备文件名」之后，直接加分区号就可以了。即硬盘有设备文件名，分区也应该有设备文件名，区别是一个是硬件设备文件名，一个是分区设备文件名。 分区设备文件名：分区文件名是在硬盘文件名之后直接加分区号，1 表示这个硬盘当中的第一个分区，依次类推。注意分区号有主分区号和逻辑分区号。 逻辑分区是从 5 开始的，1234 只能给主分区或者扩展分区使用，即使一个硬盘中没有分够 4 个主分区，逻辑分区也不能占用 1234 这 4 个分区号，即不管如何分区 5 都表示逻辑分区的第一个分区。 挂载windows 中分配盘符的操作在 Linux 中叫做挂载，我们把给分区分配盘符的过程称为挂载，我们把盘符叫做挂载点。在 Linux 中是使用空的目录名称作为盘符，而不是使用 CDEF 作为盘符，理论上任何一个目录都可以作为盘符，实际上有些目录是不可以的。 对于 Linux 来讲有两个必须分区：根分区、swap 分区（交换分区，大小一般为内存的 2 倍，一般不超过 2GB）。这两个是必须分区，如果不分区，则 Linux 不能安装，只要有这两个分区，Linux 就可以正常使用。还有一个推荐分区，/boot（启动分区，大小一般为 200M)。 根分区用于存放剩余数据，swap 分区可以理解为虚拟内存，即当我真正的内存不够用的时候可以拿交换分区的硬盘空间来当内存来用，理论上讲 swap分 区应该是内存的两倍，但是最大不超过 2GB，因为虚拟内存到底不是真正的内存，如果给它给的再大，它也不能取代内存，当它达到 2GB 的时候，如果再给大，只会占用我们更多的硬盘空间，但是对我们的系统不会产生更多的影响，所以最大不超过 2GB。 Boot 分区是专门用来保存启动时候的数据，任何操作系统启动的时候都需要一些硬盘空间，如果不给 boot 分区，万一根分区写满了，系统可能就启动不了了，为了解决这个问题，一般都会给 boot 单独分区。Boot 分区 200MB 足够，不用太大，写完之后不再往 boot 分区写入任何数据，它永远都会有一定的空余空间，就算把根分区写满了，也不会影响 Linux 启动。 Linux 文件系统结构 从 Linux 系统上看，boot、home 都是根分区的子目录。但是从硬盘上来看，它们每一个目录都可以有自己独立的硬盘空间，即每一个目录都可以有自己独立的分区，而每个分区又对应某块硬盘空间，所以每个目录都可以有自己独立的硬盘空间。 挂载点就是分区的盘符，swap 分区即交换分区没有盘符，swap 分区不是给用户用的，是由 Linux 操作系统或者内核直接调用的，所以它根本不需要盘符，有了盘符反而不正确了。swap 对系统性能的影响极小，所以分的空间不用太大。 总结 分区：把大硬盘分为小的逻辑分区；格式化：格式化的目的是为了写入文件系统，当然在写入文件系统的时候会附带的把硬盘当中的数据清空；分区设备文件名：给每个分区定义设备文件名；挂载：给每个分区分配挂载点，这个挂载点必须是目录，而且必须是空的目录才可以进行挂载点分配。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(一)]]></title>
    <url>%2F2018%2F09%2F06%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(一) —— Linux 系统简介 Unix 发展史Unix 与 Linux 的关系就像是父子关系，Unix 是父亲，Linux 是儿子。肯.汤普森在 1969 年开发出了 Unix 系统。1971 年，肯.汤普森的同事丹尼斯.里奇发明了 C 语言，随后 Unix 系统绝大部分源代码用 C 语言重写，为提高 Unix 系统的可移植性打下基础。 Unix 主要发行版本 Linux 发展史Linux 系统诞生于 1991 年，由芬兰大学生李纳斯(Linux Torvalds) 和后来陆续加入的爱好者共同完成。Unix 和 Linux 的内核都是用 c 语言写的。Linux 是开源软件。 Linux 发行版和 Linux 内核的区别？内核版是 Linux 官方发布的，仅仅是单纯的内核。在拿到内核以后，每个产商可以加入自己的桌面、应用程序等再进行开发，称为发行版。Linux 内核官网：www.kernel.org。 Linux 主要发行版本Linux 主要分为两个系列：redhat 系列和 debian 系列。其本质是一样的，因为两者采用系统的内核。最主要的区别就是软件安装的方式不一样。Redhat 系列主要分为 HEL 和 federo 两个系列，其中 federo 是个人版，HEL 是企业版。对于 Linux 的企业版和个人版跟 windows 是不一样的，对于 windows 而言 windows7 是个人版，windows2008 是企业版，它们的区别是 windows7 可以看成是 windows2008 的一个阉割版，windows2008 才是完整的。但是 Linux 不同，个人版和企业版的区别在于，个人版是开发版，可能有的功能没有进行过测试，更像是一个实验体，而企业版是稳定版。 开源软件的特点 使用的自由：绝大多数开源软件免费（注意的是开源和免费并不是等同的，开源软件也可以出售，但是卖给你的是源代码，并不是编译之后的代码给你）。 研究自由：可以获得软件源代码（开放源代码带来的好处——安全，足够多的眼睛可以发现更多的问题，可以容易的看到大神级人物的代码风格和注释）。 散步及改良自由：可以自由传播、改良甚至销售。 Linux 的应用领域 基于 Linux 的企业服务器：企业服务器。 嵌入式应用：Android 平台就是一个典型的 Linux 嵌入式应用、智能家电如机顶盒、游戏机、数码相机等。 电影娱乐业：用于电影、图片的后期处理。 Linux 为什么选择命令行？Linux 选用命令行界面主要是考虑到系统的稳定性和安全性，如果装了图形界面，对系统资源的占用是比较庞大的，所以比较不好用。而 windows 考虑的是易用性，windows 系统主要考虑的是系统的易用性。 拓展1、www.netcraft.com 是一个典型的扫描和踩点网站。只要输入你要查询的网站，就可以获取网站后台服务器所采用的操作系统。该网站是一个全球著名的信息统计网站。从攻击的角度叫踩点，从防御的角度叫扫描。 2、www.top500.org 会统计全球范围内运算能力排在前 500 的服务器或者叫群组。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门总结(三)]]></title>
    <url>%2F2018%2F09%2F04%2FDocker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Docker 入门总结(三) —— Nginx 容器教程 1、CentOS7 修改 Nginx 默认 web 目录后 403 ？我这边的原因是：SElinux 没关导致的，直接使用命令 setenforce 0 关闭 SELinux 以后就正常了。具体原因查看：Docker nginx SELinux。 2、CentOS7 修改 Nginx 默认 web 目录后 403 ？docker container run -d -p 8000:80 --rm --name mynginx -v &quot;$PWD/html&quot;:/usr/share/nginx/html nginxdocker container run -d -p 8000:80 --rm --name mynginx -v &quot;$pwd/html&quot;:/usr/share/nginx/html nginx注意：对 PWD 大小写敏感，深坑啊！！！否则会报 403 的错误。 参考博客Nginx 容器教程Nginx 报 403 forbidden 错误]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门总结(二)]]></title>
    <url>%2F2018%2F09%2F04%2FDocker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Docker 入门总结(二) —— Docker 微服务教程 1、站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器……Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。 2、如何在一台计算机上实现多个服务，让它们互相配合，组合出一个应用程序？ 3、Docker 容器中是否可以再包含 Docker 容器，这样层层嵌套？ 推荐阅读Docker 教程 参考博客Docker 微服务教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 入门总结]]></title>
    <url>%2F2018%2F08%2F30%2FRabbitMQ%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[RabbitMQ 入门总结 安装关于 RabbitMQ 的安装参考：windows7 RabbitMQ 的安装。 RabbitMQ 角色1.超级管理员 (administrator)可登陆管理控制台(启用 management plugin 的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 2.监控者 (monitoring)可登陆管理控制台(启用 management plugin 的情况下)，同时可以查看 rabbitmq 节点的相关信息(进程数，内存使用情况，磁盘使用情况等) 3.策略制定者 (policymaker)可登陆管理控制台(启用 management plugin 的情况下), 同时可以对 policy 进行管理。 4.普通管理者 (management)仅可登陆管理控制台(启用 management plugin 的情况下)，无法看到节点信息，也无法对策略进行管理。 5.其他的无法登陆管理控制台，通常就是普通的生产者和消费者。 RabbitMQ 常用命令插件管理：1234567开启某个插件： rabbitmq-plugins enable &#123;插件名&#125;关闭某个插件： rabbitmq-plugins disable &#123;插件名&#125;插件名可以在 rabbitmq 的安装目录下的 plugins 目录中查看举例：开启后台管理插件：rabbitmq-plugins enable rabbitmq_management列出可用插件：rabbitmq-plugins list 用户管理：12345678910添加用户：rabbitmqctl add_user &#123;username&#125; &#123;password&#125;删除用户：rabbitmqctl delete_user &#123;username&#125;修改密码：rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;设置用户角色：rabbitmqctl set_user_tags &#123;username&#125; &#123;tag&#125;tag 可以为 administrator、monitoring、management举例：添加用户：rabbitmqctl add_user root root设置用户角色：rabbitmqctl set_user_tags root administrator列出所有用户：rabbitmqctl list_users RabbitMQ 概述RabbitMQ 是消息代理。它接受来自生产者的信息，并将它们传递给消费者。在两者之间，它可以根据你给它的路由，缓冲规则进行传递消息。 RabbitMQ 术语1.生产者(Producer) 2.消费者(Consumer) 3.队列(Queue) 工作队列（即任务队列）的主要思想是不用一直等待资源密集型的任务处理完成，这就像一个生产线，将半成品放到生产线中，然后在生产线后面安排多个工人同时对半成品进行处理，这样比一个生产线对应一个工人的吞吐量大几个数量级。 为了确保消息或者任务不会丢失，RabbitMQ 支持消息确认 ACK。ACK 机制是消费者端从 RabbitMQ 收到消息并处理完成后，反馈给 RabbitMQ，RabbitMQ 收到反馈后才将此消息从队列中删除。如果一个消费者在处理消息时挂掉（网络不稳定、服务器异常、网站故障等原因导致频道、连接关闭或者 TCP 连接丢失等），那么他就不会有 ACK 反馈，RabbitMQ 会认为这个消息没有正常消费，会将此消息重新放入队列中。如果有其他消费者同时在线，RabbitMQ 会立即将这个消息推送给这个在线的消费者。这种机制保证了在消费者服务器故障的时候，能不丢失任何消息和任务。 如果 RabbitMQ 向消费者发送消息时，消费者服务器挂了，消息也不会有超时；即使一个消息需要非常长的时间处理，也不会导致消息超时。这样消息永远不会从 RabbitMQ 服务器中删除。只有当消费者正确的发送 ACK 确认反馈，RabbitMQ 确认收到后，消息才会从 RabbitMQ 服务器的数据中删除。 消息的 ACK 确认机制默认是打开的。 忘记通过 basicAck 返回确认信息是常见的错误。这个错误非常严重，将导致消费者客户端退出或者关闭后，消息会被退回 RabbitMQ 服务器，这会使 RabbitMQ 服务器内存爆满，而且 RabbitMQ 也不会主动删除这些被退回的消息。 如果要监控这种错误，可以使用 rabbitmqctl messages_unacknowledged 命令打印出出相关的信息。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十四)]]></title>
    <url>%2F2018%2F08%2F28%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十四) —— CompletionService 1、在异步任务程序中，一种常见的场景是，主线程提交多个异步任务，然后希望有任务完成就处理结果，并且按任务完成顺序逐个处理，对于这种场景，Java 并发包提供了一个方便的方法，使用 CompletionService，这是一个接口，它的实现类是 ExecutorCompletionService。 2、与 ExecutorService 一样，CompletionService 也可以提交异步任务，它的不同是，它可以按任务完成顺序获取结果，其具体定义为：1234567public interface CompletionService&lt;V&gt; &#123; Future&lt;V&gt; submit(Callable&lt;V&gt; task); Future&lt;V&gt; submit(Runnable task, V result); Future&lt;V&gt; take() throws InterruptedException; Future&lt;V&gt; poll(); Future&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException;&#125; submit 方法与 ExecutorService 是一样的，多了 take 和 poll 方法，它们都是获取下一个完成任务的结果，take() 会阻塞等待，poll() 会立即返回，如果没有已完成的任务，返回 null，带时间参数的 poll 方法会最多等待限定的时间。 2、CompletionService 的主要实现类是 ExecutorCompletionService，它依赖于一个 Executor 完成实际的任务提交，而自己主要负责结果的排队和处理。它的构造方法有两个：12public ExecutorCompletionService(Executor executor)public ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) 至少需要一个 Executor 参数，可以提供一个 BlockingQueue 参数，用作完成任务的队列，没有提供的话，ExecutorCompletionService 内部会创建一个 LinkedBlockingQueue。 3、ExecutorCompletionService 是怎么让结果有序处理的呢？因为它有一个额外的队列，每个任务完成之后，都会将代表结果的 Future 入队。在 FutureTask 中，任务完成后，不管是正常完成、异常结束、还是被取消，都会调用 finishCompletion 方法，而该方法会调用一个 done 方法 protected void done() { } 该方法的实现为空，但它是一个 protected 方法，子类可以重写该方法。ExecutorCompletionService 的内部类 QueueingFuture 中重写了该方法。 在 ExecutorCompletionService 中，提交的任务类型不是一般的 FutureTask，而是一个子类 QueueingFuture123456789101112131415161718192021public Future&lt;V&gt; submit(Callable&lt;V&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;V&gt; f = newTaskFor(task); // 注意 QueueingFuture executor.execute(new QueueingFuture(f)); return f;&#125;----------------------------// ExecutorCompletionService 类中的私有实例变量private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;private class QueueingFuture extends FutureTask&lt;Void&gt; &#123; QueueingFuture(RunnableFuture&lt;V&gt; task) &#123; super(task, null); this.task = task; &#125; // 子类重写了 done 方法，在任务完成时将结果加入到完成队列中 protected void done() &#123; completionQueue.add(task); &#125; private final Future&lt;V&gt; task;&#125;--------------------------- 而 ExecutorCompletionService 的 take/poll 方法就是从该队列获取结果：123public Future&lt;V&gt; take() throws InterruptedException &#123; return completionQueue.take();&#125; 4、AbstractExecutorService 的 invokeAny 的实现，就利用了 ExecutorCompletionService，它的基本思路是，提交任务后，通过 take 方法获取结果，获取到第一个有效结果后，取消所有其他任务。 5、CompletionService 它通过一个额外的结果队列，方便了对于多个异步任务结果的处理。 参考博客Java编程的逻辑 - 方便的 CompletionService]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程总结(十三)]]></title>
    <url>%2F2018%2F08%2F27%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十三) —— 线程池 1、Java 并发包中的任务执行服务的主要实现机制是线程池。线程池，顾名思义，就是一个线程的池子，里面有若干线程，它们的目的就是执行提交给线程池的任务，执行完一个任务后不会退出，而是继续等待或执行新任务。线程池主要由两个概念组成，一个是任务队列，另一个是工作者线程，工作者线程主体就是一个循环，循环从队列中接受任务并执行，任务队列保存待执行的任务。 线程池的优点： 它可以重用线程，避免线程创建的开销。 在任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争，确保任务有序完成。 Java 并发包中线程池的实现类是 ThreadPoolExecutor，它继承自 AbstractExecutorService，实现了 ExecutorService。 2、ThreadPoolExecutor 构造方法中的参数解析12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 线程池的大小主要与四个参数有关： corePoolSize：线程池中核心线程个数。不过，这并不是说，一开始就创建这么多线程，刚创建一个线程池后，实际上并不会创建任何线程。一般情况下，有新任务到来的时候，如果当前线程个数小于 corePoolSiz，就会创建一个新线程来执行该任务，需要说明的是，即使其他线程现在也是空闲的，也会创建新线程。不过，如果线程个数大于等于 corePoolSiz，那就不会立即创建新线程了，它会先尝试排队，需要强调的是，它是「尝试」排队，而不是「阻塞等待」入队，如果队列满了或其他原因不能立即入队，它就不会排队，而是检查线程个数是否达到了 maximumPoolSize，如果没有，就会继续创建线程，直到线程数达到 maximumPoolSize。 maximumPoolSize：线程池中允许的最大线程数。 keepAliveTime：当实际线程数大于核心线程数时，此为终止前，多余的空闲线程，等待新任务的最长时间。keepAliveTime 的目的是为了释放多余的线程资源，它表示，当线程池中的线程个数大于 corePoolSize 时，额外空闲线程的存活时间，也就是说，一个非核心线程，在空闲等待新任务时，会有一个最长等待时间，即 keepAliveTime，如果到了时间还是没有新任务，就会被终止。如果该值为 0，表示所有线程都不会超时终止。 unit：keepAliveTime 参数的时间单位。 3、队列之线程参数「BlockingQueue workQueue」ThreadPoolExecutor 要求的队列类型是阻塞队列 BlockingQueue： LinkedBlockingQueue：基于链表的阻塞队列，可以指定最大长度，但默认是无界的。 ArrayBlockingQueue：基于数组的有界阻塞队列。 PriorityBlockingQueue：基于堆的无界阻塞优先级队列。 SynchronousQueue：没有实际存储空间的同步阻塞队列。 如果用的是无界队列，需要强调的是，线程个数最多只能达到 corePoolSize，到达 corePoolSize 后，新的任务总会排队，参数 maximumPoolSize 也就没有意义了。 对于 SynchronousQueue，它没有实际存储元素的空间，当尝试排队时，只有正好有空闲线程在等待接受任务时，才会入队成功，否则，总是会创建新线程，直到达到 maximumPoolSize。 4、任务拒绝策略之线程参数「RejectedExecutionHandler handler」如果队列有界，且 maximumPoolSize 有限，则当队列排满，线程个数也达到了 maximumPoolSize，这时，新任务来了，就会触发线程池的任务拒绝策略。默认情况下，提交任务的方法如 execute/submit/invokeAll 等会抛出异常，类型为 RejectedExecutionException。拒绝策略是可以自定义的，ThreadPoolExecutor 实现了四种处理方式： ThreadPoolExecutor.AbortPolicy：这就是默认的方式，抛出异常。 ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛异常，也不执行。 ThreadPoolExecutor.DiscardOldestPolicy：将等待时间最长的任务扔掉，然后自己排队。 ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，而不是交给线程池中的线程执行。 它们都是 ThreadPoolExecutor 的 public 静态内部类，都实现了 RejectedExecutionHandler 接口，RejectedExecutionHandler 接口定义为：123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 当线程池不能接受任务时，调用其拒绝策略的 rejectedExecution 方法。 ThreadPoolExecutor 中的拒绝策略可以在构造方法中进行指定，也可以通过如下方法进行指定：public void setRejectedExecutionHandler(RejectedExecutionHandler handler)。 默认的 RejectedExecutionHandler 是一个 AbortPolicy 实例 private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 而 AbortPolicy 的 rejectedExecution 实现就是抛出异常。 拒绝策略只有在队列有界，且 maximumPoolSize 有限的情况下才会触发。 如果队列无界，服务不了的任务总是会排队，请求处理队列可能会消耗非常大的内存，甚至引发内存不够的异常。如果队列有界但 maximumPoolSize 无限，可能会创建过多的线程，占满 CPU 和内存，使得任何任务都难以完成。 在任务量非常大的场景中，让拒绝策略有机会执行是保证系统稳定运行很重要的方面。 5、线程工厂之线程参数「ThreadFactory threadFactory」线程池还可以接受一个参数 ThreadFactory，它是一个接口，定义为：123public interface ThreadFactory &#123; Thread newThread(Runnable r);&#125; ThreadFactory 接口根据 Runnable 创建一个 Thread，ThreadPoolExecutor 的默认实现是 Executors 类中的静态内部类 DefaultThreadFactory，主要就是创建一个线程，给线程设置一个名称，设置 daemon 属性为 false，设置线程优先级为标准默认优先级，线程名称的格式为： pool-&lt;线程池编号&gt;-thread-&lt;线程编号&gt;。 6、关于核心线程的特殊配置线程个数小于等于 corePoolSize 时，我们称这些线程为核心线程，默认情况下： 核心线程不会预先创建，只有当有任务时才会创建。 核心线程不会因为空闲而被终止，keepAliveTime参数不适用于它。 ThreadPoolExecutor 有如下方法，可以改变这个默认行为：123456// 预先创建所有的核心线程public int prestartAllCoreThreads()// 创建一个核心线程，如果所有核心线程都已创建，返回 falsepublic boolean prestartCoreThread()// 如果参数为 true，则 keepAliveTime 参数也适用于核心线程public void allowCoreThreadTimeOut(boolean value) 7、工厂类 Executors类 Executors 提供了一些静态工厂方法，可以方便的创建一些预配置的线程池，主要方法有：12345678910111213141516171819202122// newSingleThreadExecutor 只使用一个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止，该线程顺序执行所有任务。该线程池适用于需要确保所有任务被顺序执行的场合public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;----------------------------------------------------------------------// newFixedThreadPool 使用固定数目的 n 个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止。和 newSingleThreadExecutor 一样，由于是无界队列，如果排队任务过多，可能会消耗非常大的内存public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;---------------------------------------------------------------------// newCachedThreadPool 的 corePoolSize 为 0，maximumPoolSize 为 Integer.MAX_VALUE，keepAliveTime 是 60 秒，队列为 SynchronousQueue// 当新任务到来时，如果正好有空闲线程在等待任务，则其中一个空闲线程接受该任务，否则就总是创建一个新线程，创建的总线程个数不受限制，对任一空闲线程，如果60秒内没有新任务，就终止public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 实际中，应该使用 newFixedThreadPool 还是 newCachedThreadPool 呢？在系统负载很高的情况下，newFixedThreadPool 可以通过队列使新任务排队，保证有足够的资源处理实际的任务，而 newCachedThreadPool 会为每个任务创建一个线程，导致创建过多的线程竞争 CPU 和内存资源，使得任何实际任务都难以完成，这时，newFixedThreadPool 更为适用。 如果系统负载不太高，单个任务的执行时间也比较短，newCachedThreadPool 的效率可能更高，因为任务可以不经排队，直接交给某一个空闲线程。 在系统负载可能极高的情况下，两者都不是好的选择，newFixedThreadPool 的问题是队列过长，而 newCachedThreadPool 的问题是线程过多，这时，应根据具体情况自定义 ThreadPoolExecutor，传递合适的参数。 8、线程的死锁关于提交给线程池的任务，需要特别注意一种情况，就是任务之间有依赖，这种情况可能会出现死锁。对于相互依赖的任务，需要特别注意，避免出现死锁。 避免死锁的策略： 替换 newFixedThreadPool 为 newCachedThreadPool，让创建线程不再受限。 使用 SynchronousQueue，它可以避免死锁。因为对于普通队列，入队只是把任务放到了队列中，而对于 SynchronousQueue 来说，入队成功就意味着已有线程接受处理，如果入队失败，可以创建更多线程直到 maximumPoolSize，如果达到了 maximumPoolSize，会触发拒绝机制，不管怎么样，都不会死锁。 9、ThreadPoolExecutor 实现了生产者/消费者模式，工作者线程就是消费者，任务提交者就是生产者，线程池自己维护任务队列。当我们碰到类似生产者/消费者问题时，应该优先考虑直接使用线程池，而非重新发明轮子，自己管理和维护消费者线程及任务队列。 10、小结：ThreadPoolExecutor 参数 corePoolSize, maximumPoolSize, keepAliveTime, unit 用于控制线程池中线程的个数，workQueue 表示任务队列，threadFactory 用于对创建的线程进行一些配置，handler 表示任务拒绝策略。 参考博客Java编程的逻辑 - 线程池]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十二)]]></title>
    <url>%2F2018%2F08%2F26%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十二) —— 异步任务执行服务 1、Java 并发包提供了一套框架，大大简化了执行异步任务所需的开发。在之前的学习中，线程 Thread 既表示要执行的任务，又表示执行的机制，而这套框架引入了一个「执行服务」的概念，它将「任务的提交」和「任务的执行」相分离，「执行服务」封装了任务执行的细节，对于任务提交者而言，它可以关注于任务本身，如提交任务、获取结果、取消任务，而不需要关注任务执行的细节，如线程创建、任务调度、线程关闭等。 2、任务执行服务涉及的基本接口： Runnable 和 Callable：表示要执行的异步任务。 Executor 和 ExecutorService：表示执行服务。 Future：表示异步任务的结果。 Runnable 和 Callable 都表示任务，Runnable 没有返回结果，而 Callable 有，Runnable 不会抛出异常，而 Callable 会。 Executor 表示最简单的执行服务，其定义为：123public interface Executor &#123; void execute(Runnable command);&#125; 在未来某个时间执行给定的任务 Runnable，没有返回结果。该任务可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。 ExecutorService 扩展了 Executor，定义了更多服务，基本方法有：12345678910111213141516171819202122232425262728293031323334353637public interface ExecutorService extends Executor &#123; // 这三个 submit 都表示提交一个任务，返回值类型都是 Future，返回后，只是表示任务已提交，不代表已执行，通过 Future 可以查询异步任务的状态、获取最终结果、取消任务等 // 对于 Callable，任务最终有个返回值，而对于 Runnable 是没有返回值的 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); // 提交 Runnable 的方法可以同时提供一个结果，在异步任务结束时返回 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); // 异步任务的最终返回值为 null Future&lt;?&gt; submit(Runnable task); // shutdown 和 shutdownNow 表示关闭任务执行服务 // shutdown 表示不再接受新任务，但已提交的任务会继续执行，即使任务还未开始执行 void shutdown(); // shutdownNow 不仅不接受新任务，已提交但尚未执行的任务会被终止，对于正在执行的任务，一般会调用线程的 interrupt 方法尝试中断，不过，线程可能不响应中断，shutdownNow 会返回已提交但尚未执行的任务列表 List&lt;Runnable&gt; shutdownNow(); // shutdown 和 shutdownNow 不会阻塞等待，它们返回后不代表所有任务都已结束，不过 isShutdown 方法会返回 true boolean isShutdown(); boolean isTerminated(); // 调用者可以通过 awaitTermination 等待所有任务结束，它可以限定等待的时间，如果超时前所有任务都结束了，即 isTerminated 方法返回 true，则返回 true，否则返回 false boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; // ExecutorService 有两组批量提交任务的方法，invokeAll 和 invokeAny，它们都有两个版本，其中一个限定等待时间 // invokeAll 等待所有任务完成，返回的 Future 列表中，每个 Future 的 isDone 方法都返回 true，不过 isDone 为 true 不代表任务就执行成功了，可能是被取消了，invokeAll 可以指定等待时间，如果超时后有的任务没完成，就会被取消 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; // invokeAny 只要有一个任务在限时内成功返回了，它就会返回该任务的结果，其他任务会被取消，如果没有任务能在限时内成功返回，抛出 TimeoutException，如果限时内所有任务都结束了，但都发生了异常，抛出 ExecutionException &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 使用 ExecutorService 编写并发异步任务的代码就像写顺序程序一样，不用关心线程的创建和协调，只需要提交任务、处理结果就可以了，大大简化了开发工作。 3、Future 接口1234567891011121314151617181920// Future 表示异步计算的结果public interface Future&lt;V&gt; &#123; // cancel 用于取消异步任务，如果任务已完成、或已经取消、或由于某种原因不能取消，cancel 返回 false，否则返回 true // 如果任务还未开始或已经结束，则不再运行 // 如果任务已经在运行，则不一定能取消，参数 mayInterruptIfRunning 表示，如果任务正在执行，是否调用 interrupt 方法中断线程，如果为 false 就不会，如果为 true，就会尝试中断线程，interrupt() 不一定能取消线程 boolean cancel(boolean mayInterruptIfRunning); // isDone 和 isCancelled 用于查询任务状态 // isCancelled 表示任务是否被取消，只要 cancel 方法返回了 true，随后的 isCancelled 方法都会返回 true，即使执行任务的线程还未真正结束 boolean isCancelled(); // isDone 表示任务是否结束，不管什么原因都算，可能是任务正常结束、可能是任务抛出了异常、也可能是任务被取消 boolean isDone(); // get 用于返回异步任务最终的结果，如果任务还未执行完成，会阻塞等待 V get() throws InterruptedException, ExecutionException; // 可以限定阻塞等待的时间，如果超时任务还未结束，会抛出 TimeoutException V get(long timeout, TimeUnit unit) throws InterruptedException,ExecutionException, TimeoutException;&#125; get() 方法，任务最终大概有三个结果： 正常完成，get 方法会返回其执行结果，如果任务是 Runnable 且没有提供结果，返回 null。 任务执行抛出了异常，get 方法会将异常包装为 ExecutionException 重新抛出，通过异常的 getCause 方法可以获取原异常。 任务被取消了，get 方法会抛出异常 CancellationException。 如果调用 get 方法的线程被中断了，get 方法会抛出 InterruptedException。 Future 是一个重要的概念，是实现「任务的提交」与「任务的执行」相分离的关键，是其中的纽带，任务提交者和任务执行服务通过它隔离各自的关注点，同时进行协作。 4、ExecutorService 的主要实现类是 ThreadPoolExecutor，它是基于线程池实现的。ExecutorService 有一个抽象实现类 AbstractExecutorService，接下来简要分析下 AbstractExecutorService 的原理。12345678910111213141516// AbstractExecutorService 提供了 submit、invokeAll、invokeAny 的默认实现，子类只需要实现如下方法即可public abstract class AbstractExecutorService implements ExecutorService &#123; // 除了 execute 方法，其他方法都与执行服务的生命周期管理有关 public void shutdown() public List&lt;Runnable&gt; shutdownNow() public boolean isShutdown() public boolean isTerminated() public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException // submit/invokeAll/invokeAny 最终都会调用 execute，execute 决定了到底如何执行任务 public void execute(Runnable command)&#125; 5、AbstractExecutorService 抽象类中 submit() 方法源码解析12345678910111213141516171819202122232425public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); // 调用 newTaskFor 生成了一个 RunnableFuture，RunnableFuture 是一个接口，既扩展了 Runnable，又扩展了 Future，没有定义新方法 // 作为 Runnable，它表示要执行的任务，传递给 execute 方法进行执行 // 作为 Future，它又表示任务执行的异步结果 RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;----------------------protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; // 就是创建了一个 FutureTask 对象，FutureTask 实现了 RunnableFuture 接口 return new FutureTask&lt;T&gt;(runnable, value);&#125;----------------------public FutureTask(Runnable runnable, V result) &#123; // 如果 FutureTask 接受的是一个 Runnable 对象，它会调用 Executors.callable 转换为 Callable 对象 this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;---------------------// RunnableFuture 接口定义public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; 6、FutureTask 源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Future 的主要实现类是 FutureTaskpublic class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; // 表示状态，可取值如下 private volatile int state; private static final int NEW = 0;// 刚开始的状态，或任务在运行 private static final int COMPLETING = 1;// 临时状态，任务即将结束，在设置结果 private static final int NORMAL = 2;// 任务正常执行完成 private static final int EXCEPTIONAL = 3;// 任务执行抛出异常结束 private static final int CANCELLED = 4;// 任务被取消 private static final int INTERRUPTING = 5;// 任务在被中断 private static final int INTERRUPTED = 6;// 任务被中断 // 表示待执行的任务 private Callable&lt;V&gt; callable; // 表示最终的执行结果或异常 private Object outcome; // non-volatile, protected by state reads/writes // 表示运行任务的线程 private volatile Thread runner; // 单向链表表示等待任务执行结果的线程 private volatile WaitNode waiters; // FutureTask 的构造方法会初始化 callable 和状态，如果 FutureTask 接受的是一个 Runnable 对象，它会调用 Executors.callable 转换为 Callable 对象 public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable &#125; // 任务执行服务会使用一个线程执行 FutureTask 的 run 方法 public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125;&#125; FutureTask 的 run() 方法的基本逻辑为： 调用 callable 的 call 方法，捕获任何异常。 如果正常执行完成，调用 set 设置结果，保存到 outcome。 如果执行过程发生异常，调用 setException 设置异常，异常也是保存到 outcome，但状态不一样。 set 和 setException 除了设置结果，修改状态外，还会调用 finishCompletion ，它会唤醒所有等待结果的线程。 7、FutureTask 中 get() 方法源码解析123456789101112131415161718192021public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; if (unit == null) throw new NullPointerException(); int s = state; // 如果任务还未执行完毕，就等待 if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); // 最后调用 report 报告结果, report 根据状态返回结果或抛出异常 return report(s);&#125;-----------------------------------private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x);&#125; 8、FutureTask 中 cancel() 方法源码解析123456789101112131415161718192021222324public boolean cancel(boolean mayInterruptIfRunning) &#123; // 如果任务已结束或取消，返回 false // 如果 mayInterruptIfRunning 为 false，设置状态为 CANCELLED if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; // in case call to interrupt throws exception // 如果 mayInterruptIfRunning 为 true，调用 interrupt 中断线程，设置状态为 INTERRUPTED if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) t.interrupt(); &#125; finally &#123; // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); &#125; &#125; &#125; finally &#123; // 调用 finishCompletion 唤醒所有等待结果的线程 finishCompletion(); &#125; return true;&#125; 9、Java 并发包中任务执行服务的基本概念和原理，该服务体现了并发异步开发中「关注点分离」的思想，使用者只需要通过 ExecutorService 提交任务，通过 Future 操作任务和结果即可，不需要关注线程创建和协调的细节。 参考博客Java编程的逻辑 - 异步任务执行服务]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十一)]]></title>
    <url>%2F2018%2F08%2F26%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十一) —— 各种队列]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器总结(四)]]></title>
    <url>%2F2018%2F08%2F25%2FJava%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Java 容器总结(四) —— HashSet 1、HashSet 由两个单词组成，Hash 和 Set，Set 表示接口，实现 Set 接口有多种方式，HashSet 实现的方式利用了 Hash。Set 表示的是没有重复元素、且不保证顺序的容器接口，它扩展了 Collection，但没有定义任何新的方法，不过，对于其中的一些方法，它有自己的规范。 2、Set 接口定义123456789101112131415161718192021public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); // 迭代遍历时，不要求元素之间有特别的顺序 // HashSet 的实现就是没有顺序，但有的 Set 实现可能会有特定的顺序，比如 TreeSet Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); // 如果集合中已经存在相同元素了，则不会改变集合，直接返回 false，只有不存在时，才会添加，并返回 true boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); // 重复的元素不添加，不重复的添加，如果集合有变化，返回 true，没变化返回 false boolean addAll(Collection&lt;? extends E&gt; c); boolean retainAll(Collection&lt;?&gt; c); boolean removeAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode();&#125; 3、注意：HashSet 要求元素重写 hashCode 和 equals 方法，且对两个对象，equals 相同，则 hashCode 也必须相同，如果元素是自定义的类，需要注意这一点。因为 HashSet 就是依靠 hashCode 和 equals 方法来判断对象是否相等的，所以使用 HashSet 的时候一定要注意重写这两个方法。 4、HashSet 内部组成1234567public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; // HashSet 内部是用 HashMap 实现的，它内部有一个 HashMap 实例变量 private transient HashMap&lt;E,Object&gt; map; // HashSet 相当于只有键，值都是相同的固定值 PRESENT private static final Object PRESENT = new Object();&#125; 5、HashSet 的构造方法，主要就是调用了对应的 HashMap 的构造方法。 6、add() 方法源码解析1234public boolean add(E e) &#123; // 返回值为 boolean 类型 return map.put(e, PRESENT)==null;&#125; 就是调用 map 的 put 方法，元素 e 用于键，值就是那个固定值 PRESENT，put 返回 null 表示原来没有对应的键，添加成功了。HashMap 中一个键只会保存一份，所以重复添加 HashMap 不会变化。 7、remove() 方法源码解析1234// 调用 map 的 remove 方法，返回值为 PRESENT 表示原来有对应的键且删除成功了public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 8、迭代器1234// 返回 map 的 keySet 的迭代器public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; 9、HashSet 特点分析HashSet 实现了 Set 接口，内部是通过 HashMap 实现的，这决定了它有如下特点： 没有重复元素。 可以高效的添加、删除元素、判断元素是否存在，效率都为 O(1)。 没有顺序。 10、HashSet 实现了 Set 接口，不含重复元素，内部实现利用了 HashMap，可以方便高效地实现如去重、集合运算等功能。HashSet 没有顺序，如果要保持添加的顺序，可以使用 HashSet 的一个子类 LinkedHashSet。 参考博客Java编程的逻辑 - 剖析 HashSet]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十)]]></title>
    <url>%2F2018%2F08%2F24%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十) —— 基于 SkipList 的 Map 和 Set]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(九)]]></title>
    <url>%2F2018%2F08%2F24%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(九) —— ConcurrentHashMap 1、ConcurrentHashMap，它是 HashMap 的并发版本，与 HashMap 相比，它有如下特点： 并发安全。 直接支持一些原子复合操作。 支持高并发、读操作完全并行、写操作支持一定程度的并行。 与同步容器 Collections.synchronizedMap 相比，迭代不用加锁，不会抛出 ConcurrentModificationException。 弱一致性。 2、HashMap 不是并发安全的，在并发更新的情况下，HashMap 的链表结构可能形成环，出现死循环，占满 CPU。死循环出现在多个线程同时扩容哈希表的时候，不是同时更新一个链表的时候，那种情况可能会出现更新丢失，但不会死循环。具体参考 Java HashMap 的死循环。 使用 Collections.synchronizedMap 方法可以生成一个同步容器，可以避免该问题。在 Java 中，HashMap 还有一个同步版本 Hashtable，它与使用 synchronizedMap 生成的 Map 基本是一样的，也是在每个方法调用上加了 synchronized。然而同步容器存在以下问题： 每个方法都需要同步，支持的并发度比较低。 对于迭代和复合操作，需要调用方加锁，使用比较麻烦，且容易忘记。 3、ConcurrentHashMap 没有以上那些问题，它同样实现了 Map 接口，也是基于哈希表实现的。除了 Map 接口，ConcurrentHashMap 还实现了一个接口 ConcurrentMap，接口定义了一些条件更新操作。12345678910public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; // 条件更新，如果 Map 中没有 key，设置 key 的值为 value，返回原来 key 对应的值，如果没有，返回 null V putIfAbsent(K key, V value); // 条件删除，如果 Map 中有 key，且对应的值为 value，则删除，如果删除了，返回 true，否则 false boolean remove(Object key, Object value); // 条件替换，如果 Map 中有 key，且对应的值为 oldValue，则替换为 newValue，如果替换了，返回 ture，否则 false boolean replace(K key, V oldValue, V newValue); // 条件替换，如果 Map 中有 key，则替换值为 value，返回原来 key 对应的值，如果原来没有，返回 null V replace(K key, V value);&#125; 如果使用同步容器，调用方必须加锁，而 ConcurrentMap 将它们实现为了原子操作。实际上，使用 ConcurrentMap，调用方也没有办法进行加锁，它没有暴露锁接口，也不使用 synchronized。 4、ConcurrentHashMap 是为高并发设计的，其主要思路有两点： 分段锁 读不需要锁 同步容器使用 synchronized，所有方法，竞争同一个锁，而 ConcurrentHashMap 采用分段锁技术，将数据分为多个段，而每个段有一个独立的锁，每一个段相当于一个独立的哈希表，分段的依据也是哈希值，无论是保存键值对还是根据键查找，都先根据键的哈希值映射到段，再在段对应的哈希表上进行操作。 采用分段锁，可以大大提高并发度，多个段之间可以并行读写。默认情况下，段是 16个，不过，这个数字可以通过构造方法进行设置:public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)concurrencyLevel 表示估计的并行更新的线程个数，ConcurrentHashMap 会将该数转换为2的整数次幂，比如 14 转换为 16，25 转换为 32。 在对每个段的数据进行读写时，ConcurrentHashMap 也不是简单的使用锁进行同步，内部使用了 CAS、对一些写采用原子方式，实现比较复杂，实现的效果是，对于写操作，需要获取锁，不能并行，但是读操作可以，多个读可以并行，写的同时也可以读，这使得 ConcurrentHashMap 的并行度远远大于同步容器。 5、使用同步容器，在迭代中需要加锁，否则可能会抛出 ConcurrentModificationException。ConcurrentHashMap 没有这个问题，在迭代器创建后，在迭代过程中，如果另一个线程对容器进行了修改，迭代会继续，不会抛出异常。 但是迭代器是否会反映别的线程的修改，就需要视情况而定了。这是因为 ConcurrentHashMap 的弱一致性。类似的情况还会出现在 ConcurrentHashMap 的另一个方法：public void putAll(Map&lt;? extends K, ? extends V&gt; m) 该方法并非原子操作，而是调用 put 方法逐个元素进行添加的，在该方法没有结束的时候，部分修改效果就会体现出来。 6、ConcurrentHashMap 的弱一致性ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。 7、ConcurrentHashMap 通过分段锁、CAS 等技术实现了高并发；实现了 ConcurrentMap 接口，支持原子条件更新操作；不会抛出 ConcurrentModificationException，实现了弱一致性。 8、Java 中没有并发版的 HashSet，但可以通过 Collections.newSetFromMap 方法基于 ConcurrentHashMap 构建一个。HashMap/HashSet 基于哈希，不能对元素排序，对应的可排序的容器类是 TreeMap/TreeSet，并发包中可排序的对应版本不是基于树，而是基于 Skip List（跳跃表）的，类分别是 ConcurrentSkipListMap 和 ConcurrentSkipListSet。 参考博客Java编程的逻辑 - ConcurrentHashMap]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(八)]]></title>
    <url>%2F2018%2F08%2F24%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%85%AB)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(八) —— 写时拷贝的 List 和 Set 1、Java 并发包中的容器类。注意这个是并发容器，要跟 Collections 返回的同步容器区分开。这里主要学习 CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个类，Copy-On-Write，即写时拷贝或写时复制，这是解决并发问题的一种重要思路。 2、CopyOnWriteArrayList 基本用法CopyOnWriteArrayList 实现了 List 接口，它的用法与其他 List 如 ArrayList 基本是一样的，它的区别是： 它是线程安全的，可以被多个线程并发访问。 它的迭代器不支持修改操作，但也不会抛出 ConcurrentModificationException。 它直接以原子方式支持一些复合操作。 3、基于 synchronized 的同步容器迭代时，需要对整个列表对象加锁，否则会抛出 ConcurrentModificationException。但 CopyOnWriteArrayList 没有这个问题，迭代时不需要加锁。因为 CopyOnWriteArrayList 的迭代器根本不支持修改，这也是 CopyOnWriteArrayList 思想的本质，写时拷贝，CopyOnWriteArrayList 有点像 String，一旦创建，内容不可变，变的只是引用。 在 JDK 1.8 之前的实现中，CopyOnWriteArrayList 的迭代器不支持修改操作，也不支持一些依赖迭代器修改方法的操作，比如 Collections 的 sort 方法，因为 Collections.sort 方法依赖迭代器的 set 方法。但是在 JDK 1.8 中，List 接口增加了 sort 方法，并提供了默认实现，而 CopyOnWriteArrayList 重写了该实现，从以下其源码可以看出，加锁了。12345678910111213public void sort(Comparator&lt;? super E&gt; c) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); Object[] newElements = Arrays.copyOf(elements, elements.length); @SuppressWarnings("unchecked") E[] es = (E[])newElements; Arrays.sort(es, c); setArray(newElements); &#125; finally &#123; lock.unlock(); &#125;&#125; 基于 synchronized 的同步容器的一个问题是复合操作，比如先检查再更新，也需要调用方加锁，而 CopyOnWriteArrayList 直接支持两个原子方法，其本质都是加锁了。1234// 不存在才添加，如果添加了，返回 true，否则返回 falsepublic boolean addIfAbsent(E e)// 批量添加 c 中的非重复元素，不存在才添加，返回实际添加的个数public int addAllAbsent(Collection&lt;? extends E&gt; c) 4、CopyOnWriteArrayList 的基本原理CopyOnWriteArrayList 的内部也是一个数组，但这个数组是以原子方式被整体更新的。每次修改操作，都会新建一个数组，复制原数组的内容到新数组，在新数组上进行需要的修改，然后以原子方式设置内部的数组引用，这就是写时拷贝。 所有的读操作，都是先拿到当前引用的数组，然后直接访问该数组，在读的过程中，可能内部的数组引用已经被修改了，但不会影响读操作，它依旧访问原数组内容。即数组内容是只读的，写操作都是通过新建数组，然后原子性的修改数组引用来实现的。 123456789101112131415161718public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; // 内部数组，注意，它声明为了 volatile，这是必需的，保证内存可见性，写操作更改了之后，读操作能看到。 private transient volatile Object[] array; final transient ReentrantLock lock = new ReentrantLock(); final Object[] getArray() &#123; return array; &#125; final void setArray(Object[] a) &#123; array = a; &#125; // 默认构造方法 public CopyOnWriteArrayList() &#123; setArray(new Object[0]); &#125; &#125; 在 CopyOnWriteArrayList 中，读不需要锁，可以并行，读和写也可以并行，但多个线程不能同时写，每个写操作都需要先获取锁，CopyOnWriteArrayList 内部使用 ReentrantLock。 5、add() 方法源码解析1234567891011121314151617public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获取原数组 Object[] elements = getArray(); int len = elements.length; // 拷贝到一个新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; // 调用 setArray 原子性的修改内部数组引用 setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 解析为什么 add() 方法需要加锁？内部数组 array 是被 volatile 关键字修饰的，其内存可见性是不存在问题的，但是却存在另一个问题 —— 竞态条件，所以通过加锁来解决并发写时的竞态条件问题。此处加锁的目的就是为了解决竞态条件问题。 6、indexOf() 方法源码解析12345678910111213141516171819public int indexOf(Object o) &#123; Object[] elements = getArray(); return indexOf(o, elements, 0, elements.length);&#125;-----------------------------// 这个 indexOf 方法访问的所有数据都是通过参数传递进来的，数组内容也不会被修改，不存在并发问题private static int indexOf(Object o, Object[] elements, int index, int fence) &#123; if (o == null) &#123; for (int i = index; i &lt; fence; i++) if (elements[i] == null) return i; &#125; else &#123; for (int i = index; i &lt; fence; i++) if (o.equals(elements[i])) return i; &#125; return -1;&#125; 7、iterator() 迭代器方法源码解析1234567891011121314151617public Iterator&lt;E&gt; iterator() &#123; // COWIterator 是内部类，传递给它的是不变的数组，它也只是读该数组，不支持修改 return new COWIterator&lt;E&gt;(getArray(), 0);&#125;-------------------static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; /** Snapshot of the array */ // final 修饰，表明数组的引用不可变，而写时拷贝的特性，表明数组一旦被创建其内容不会再变，所以该数组是不可变的 private final Object[] snapshot; /** Index of element to be returned by subsequent call to next. */ private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125;&#125; 8、CopyOnWriteArrayList 小结每次修改都创建一个新数组，然后复制所有内容，如果数组比较大，修改操作又比较频繁，CopyOnWriteArrayList 的性能是很低的。CopyOnWriteArrayList 不适用于数组很大，且修改频繁的场景。它是以优化读操作为目标的，读不需要同步，性能很高，但在优化读的同时就牺牲了写的性能。 保证线程安全的两种思路，一种是锁，使用 synchronized 或 ReentrantLock，另外一种是循环 CAS，写时拷贝体现了保证线程安全的另一种思路。对于绝大部分访问都是读，且有大量并发线程要求读，只有个别线程进行写，且只是偶尔写的场合，这种写时拷贝就是一种很好的解决方案。 写时拷贝是一种重要的思维，用于各种计算机程序中，比如经常用于操作系统内部的进程管理和内存管理。 9、CopyOnWriteArraySet 实现了 Set 接口，不包含重复元素，内部，它是通过 CopyOnWriteArrayList 实现的。1234567891011121314public class CopyOnWriteArraySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements java.io.Serializable &#123; // 内部实现依赖 CopyOnWriteArrayList private final CopyOnWriteArrayList&lt;E&gt; al; public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;(); &#125; // 调用了 CopyOnWriteArrayList 的 addIfAbsent 方法 public boolean add(E e) &#123; return al.addIfAbsent(e); &#125; &#125; 由于 CopyOnWriteArraySet 是基于 CopyOnWriteArrayList 实现的，所以与 Set 的实现类如 HashSet/TreeSet 相比，它的性能比较低，不适用于元素个数特别多的集合。如果元素个数比较多，可以考虑 ConcurrentHashMap 或 ConcurrentSkipListSet。 ConcurrentHashMap 与 HashMap 类似，适用于不要求排序的场景，ConcurrentSkipListSet 与 TreeSet 类似，适用于要求排序的场景。Java 并发包中没有与 HashSet 对应的并发容器，但可以很容易的基于 ConcurrentHashMap 构建一个，利用 Collections.newSetFromMap 方法即可。 参考博客Java 编程的逻辑 - 写时拷贝的 List 和 Set]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(七)]]></title>
    <url>%2F2018%2F08%2F23%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%83)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(七) —— 显式条件 1、显式条件也可以被称做条件变量、条件队列、或条件。锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与 synchronzied 相对应，而显式条件与 wait/notify 相对应。wait/notify 与 synchronized 配合使用，显式条件与显式锁配合使用。条件与锁相关联，创建条件变量需要通过显式锁，Lock 接口定义了创建方法：Condition newCondition();。 2、Condition 接口表示条件变量123456789101112public interface Condition &#123; void await() throws InterruptedException; void awaitUninterruptibly(); // 等待时间也是相对时间，但参数单位是纳秒，返回值是 nanosTimeout 减去实际等待的时间，即剩余未用的等待时间 long awaitNanos(long nanosTimeout) throws InterruptedException; // 等待时间是相对时间，如果由于等待超时返回，返回值为 false，否则为 true boolean await(long time, TimeUnit unit) throws InterruptedException; // 等待时间是绝对时间，如果由于等待超时返回，返回值为 false，否则为 true boolean awaitUntil(Date deadline) throws InterruptedException; void signal(); void signalAll();&#125; 除 awaitUninterruptibly() 之外，await 方法都是响应中断的，如果发生了中断，会抛出 InterruptedException，但中断标志位会被清空。awaitUninterruptibly() 方法不会由于中断结束，但当它返回时，如果等待过程中发生了中断，中断标志位会被设置。 3、一般而言，与 Object 的 wait 方法一样，调用 await 方法前需要先获取锁，如果没有锁，会抛出异常 IllegalMonitorStateException。await 在进入等待队列后，会释放锁，释放 CPU，当其他线程将它唤醒后，或等待超时后，或发生中断异常后，它都需要重新获取锁，获取锁后，才会从 await 方法中退出。 另外，与 Object 的 wait 方法一样，await 返回后，不代表其等待的条件就一定满足了，通常要将 await 的调用放到一个循环内，只有条件满足后才退出。 一般而言，signal/signalAll 与 notify/notifyAll 一样，调用它们需要先获取锁，如果没有锁，会抛出异常 IllegalMonitorStateException。signal 与 notify 一样，挑选一个线程进行唤醒，signalAll 与 notifyAll 一样，唤醒所有等待的线程，但这些线程被唤醒后都需要重新竞争锁，获取锁后才会从 await 调用中返回。 4、显式条件与显式锁配合，wait/notify 与 synchronized 配合。 5、显示条件的实现原理1234567891011121314151617// ReentrantLock 类中的 newCondition 方法public Condition newCondition() &#123; return sync.newCondition();&#125;-------------------------// ReentrantLock 内部类 Sync 中的 newCondition 方法final ConditionObject newCondition() &#123; // ConditionObject 是 AQS 中定义的一个内部类 return new ConditionObject();&#125;-------------------------public class ConditionObject implements Condition, java.io.Serializable &#123; // 条件队列的头节点 private transient Node firstWaiter; // 条件队列的尾节点 private transient Node lastWaiter;&#125; ConditionObject 内部也有一个队列，表示条件等待队列。ConditionObject 是 AQS 的成员内部类，它可以直接访问 AQS 中的数据，比如 AQS 中定义的锁等待队列。 6、await 方法源码解析1234567891011121314151617181920212223242526public final void await() throws InterruptedException &#123; // 如果等待前中断标志位已被设置，直接抛异常 if (Thread.interrupted()) throw new InterruptedException(); // 1.为当前线程创建节点，加入条件等待队列 Node node = addConditionWaiter(); // 2.释放持有的锁 int savedState = fullyRelease(node); int interruptMode = 0; // 3.放弃CPU，进行等待，直到被中断或 isOnSyncQueue 变为 true // isOnSyncQueue 为 true 表示节点被其他线程从条件等待队列 // 移到了外部的锁等待队列,等待的条件已满足 while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; // 4.重新获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); // 5.处理中断，抛出异常或设置中断标志位 if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 7、signal 方法源码解析1234567public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125; doSignal 的代码就不列举了，其基本逻辑是：将节点从条件等待队列移到锁等待队列；调用 LockSupport.unpark 将线程唤醒。 8、总结：显示条件的本质就是一个队列，该队列提供了两个系列的方法，await 系列的方法用于条件不满足时将线程对象加入队列，signal 系列方法用于条件满足时从队列中释放线程对象。实际业务可以根据具体的条件是否满足来决定当前线程对象是加入队列等待，还是从队列中释放执行。 参考博客Java编程的逻辑 - 显式条件]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(三)]]></title>
    <url>%2F2018%2F08%2F23%2FJava%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Java 容器总结(三) —— HashMap 1、ArrayList 和 LinkedList，它们的一个共同特点是，查找元素的效率都比较低，都需要逐个进行比较，而 HashMap 它的查找效率则要高的多。Map 表示映射关系，实现 Map 接口有多种方式，HashMap 实现的方式利用了 Hash。 2、Map 接口Map 按照键存储和访问值，键不能重复，即一个键只会存储一份，给同一个键重复设值会覆盖原来的值。使用 Map 可以方便地处理需要根据键访问对象的场景。数组、ArrayList、LinkedList 可以视为一种特殊的 Map，键为索引，值为对象。1234567891011121314151617181920212223public interface Map&lt;K,V&gt; &#123; V put(K key, V value); V get(Object key); V remove(Object key); int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); interface Entry&lt;K,V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); &#125; boolean equals(Object o); int hashCode();&#125; Map 接口有两个类型参数，K 和 V，分别表示键 (Key) 和值 (Value) 的类型。在 HashMap 中，key 相同的依据是，要么都为 null，要么 equals 方法返回 true。Map.Entry 是一个嵌套接口，定义在 Map 接口内部，表示一条键值对。 注意：keySet()/values()/entrySet() 有一个共同的特点，它们返回的都是视图，不是拷贝的值，基于返回值的修改会直接修改 Map 自身。 Set 是一个接口，表示的是数学中的集合概念，即没有重复的元素集合。它扩展了 Collection，但没有定义任何新的方法，不过，它要求所有实现者都必须确保 Set 的语义约束，即不能有重复元素。Map 中的键是没有重复的，所以 ketSet() 返回了一个 Set。 3、HashMap 主要围绕以下几个变量来实现的，几乎所有的操作都是在操作以下几个变量：12345678// table 是一个 Node (单向链表) 类型的数组，数组中的每个元素都是一个单向链表，链表中的每个节点表示一个键值对，Node 是一个内部类transient Node&lt;K,V&gt;[] table;// size 表示实际键值对的个数transient int size;// 扩容的阈值int threshold;// loadFactor 是负载因子，表示整体上 table 被占用的程度，是一个浮点数，默认为 0.75，可以通过构造方法进行修改final float loadFactor; 4、HashMap 内部组成12345678910111213141516171819202122232425262728293031public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // table 是一个 Node 类型的数组，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对，Node 是一个内部类 transient Node&lt;K,V&gt;[] table; // size 表示实际键值对的个数 transient int size; int threshold; final float loadFactor; // 静态内部类，实现了 Map.Entry 接口 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // hash 是 key 的哈希值，直接存储 hash 值是为了在比较的时候加快计算 final int hash; final K key; V value; // next 指向下一个 Node 节点，即链表元素的下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; // 直接存储 hash 值是为了在比较的时候加快计算 this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; &#125;&#125; table 默认为 null，当添加键值对后，table 就不是空表了，它会随着键值对的添加进行扩展，扩展的策略类似于 ArrayList，添加第一个元素时，默认分配的大小为 16，不过，并不是 size 大于 16 时再进行扩展，下次什么时候扩展与 threshold 有关。threshold 表示阈值，当键值对个数 size 大于等于 threshold 时考虑进行扩展。一般而言，threshold 等于 table.length 乘以 loadFactor。loadFactor 是负载因子，表示整体上 table 被占用的程度，是一个浮点数，默认为 0.75，可以通过构造方法进行修改。 5、put(K key, V value) 方法源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 调用 HashMap 的 put() 方法public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;-------------------------// 获取 key 的 hash 值static final int hash(Object key) &#123; int h; // 做异或 和 无符号右移的位运算得到最后的 hash 值 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;------------------------// onlyIfAbsent：if true, don't change existing value// evict：if false, the table is in creation mode.final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table 为 null，表示第一次保存时，调用 resize() 方法进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 注意：(n - 1) &amp; hash 用来计算应该将这个键值对放到 table 的哪个位置 // HashMap 中，length 为 2 的幂次方，(n - 1) &amp; hash 等同于求模运算：h % length // 找到了保存位置 i，table[i] 指向一个单向链表，接下来，就是在这个链表中逐个查找是否已经有这个键了 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 无哈希冲突,创建新的 Node tab[i] = newNode(hash, key, value, null); else &#123; // 进到这里表明有哈希冲突了 Node&lt;K,V&gt; e; K k; // 节点 key 存在,直接覆盖 value，保证 key 的唯一性 // 而比较的时候，是先比较 hash 值，hash 相同的时候，再使用 equals 方法进行比较。注意：比较的时候先比较 hash，再比较地址值，最后才使用 equals() // 因为 hash 是整数，比较的性能一般要比 equals 比较高很多，hash 不同，就没有必要调用 equals 方法了，这样整体上可以提高比较性能 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断是否为为红黑树 else if (p instanceof TreeNode) // 是红黑树，赋值 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 是链表，并且 table 的 [i] 值相同的情况 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 如果 p 后的 Node 为空，表明当前链表只有一个结点 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 链表长度达到 8，改变链表结构为红黑树 treeifyBin(tab, hash); break; &#125; // key 相同则跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 就是移动指针方便继续取 p.next，因为前面有 e = p.next 这样的赋值 p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 根据规则选择是否覆盖value if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 扩容检测，并且此处完成对 size 加 1 if (++size &gt; threshold) // size 大于阈值则扩容 resize(); afterNodeInsertion(evict); return null;&#125;------------------------final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 扩容为原先的两倍大小 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 初始容量设为阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 零初始阈值表示使用默认值 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 扩容后的对旧数组中值的拷贝操作 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 6、get() 方法源码解析123456789101112131415161718192021222324public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;--------------------final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 7、remove() 方法源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;------------------------------final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // 要删除的结点是头结点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 不是要删除的结点头结点的情况 else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) // 红黑树节点 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; // 链表节点 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // node 表示要删除的结点，获取到 node 后，分情形删除节点 // node 不为 null 的情况下，再判断 value 是否一致，相当于双重保障吧 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) // 红黑树结点删除，牵扯到由红黑树变链表的逻辑 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 头结点 else if (node == p) tab[index] = node.next; // 非头结点，注意：node 为要删除的结点，p 为要删除结点的前一个结点 else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 8、HashMap 的主结构类似于一个数组，添加值时通过 key 确定储存位置。当发生冲突时,相同 hash 值的键值对会组成链表。在 JDK 1.8 以前，数组 + 链表的组合形式大部分情况下都能有不错的性能效果。但是在极端情况下，一组「比如经过精心设计的」键值对都发生了冲突，这时的哈希结构就会退化成一个链表，使 HashMap 性能急剧下降。所以在 JDK 1.8 之后，采用数组+链表+红黑树「链表长度大于 8 时转为红黑树」的方式对元素进行存储。 9、HashMap 实现原理小结HashMap 的基本实现原理，内部有一个数组 table，每个元素 table[i] 指向一个单向链表，根据键存取值，用键算出 hash，取模得到数组中的索引位置 buketIndex，然后操作 table[buketIndex] 指向的单向链表。 存取的时候依据键的 hash 值，只在对应的链表中操作，不会访问别的链表，在对应链表操作时也是先比较 hash 值，相同的话才用 equals 方法比较，这就要求，相同的对象其 hashCode() 返回值必须相同，如果键是自定义的类，就特别需要注意这一点。这也是hashCode和equals方法的一个关键约束。 HashMap 它实现了 Map 接口，可以方便的按照键存取值，它的实现利用了哈希，可以根据键自身直接定位，存取效率很高。 10、HashMap 特点分析HashMap 实现了 Map 接口，内部使用数组+链表+红黑树和哈希的方式进行实现，这决定了它有如下特点： 根据键保存、获取、删除操作的效率都很高，为 O(1)，每个单向链表往往只有一个或少数几个节点，根据 hash 值就可以直接快速定位。 HashMap 中的键值对没有顺序，因为 hash 值是随机的。 综上所述，HashMap 适用于不要求顺序，经常需要根据键存取值的场景。 11、根据哈希值存取对象、比较对象是计算机程序中一种重要的思维方式，它使得存取对象主要依赖于自身哈希值，而不是与其他对象进行比较，存取效率也就与集合大小无关，高达 O(1)，即使进行比较，也利用哈希值提高比较性能。 参考博客Java 编程的逻辑 - 剖析 HashMapJava8 HashMap 源码分析]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(二)]]></title>
    <url>%2F2018%2F08%2F22%2FJava%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Java 容器总结(二) —— LinkedList 1、LinkedList 与 ArrayList 一样，同样实现了 List 接口，而 List 接口扩展了 Collection 接口，Collection 又扩展了 Iterable 接口，所有这些接口的方法都是可以使用的。123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125; 2、队列 (Queue) LinkedList 还实现了队列接口 Queue，队列的特点就是先进先出，在尾部添加元素，从头部删除元素。 12345678 public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek();&#125; Queue 扩展了 Collection，它的主要操作有三个： 在尾部添加元素 (add, offer)。 查看头部元素 (element, peek)，返回头部元素，但不改变队列。 删除头部元素 (remove, poll)，返回头部元素，并且从队列中删除。 每种操作都有两种形式，区别在于，对于特殊情况的处理不同。特殊情况是指，队列为空或者队列为满。为满是指队列有长度大小限制，而且已经占满了。LinkedList 的实现中，队列长度没有限制，但别的 Queue 的实现可能有。 在队列为空时，element 和 remove 会抛出异常 NoSuchElementException，而 peek 和 poll 返回特殊值 null，在队列为满时，add 会抛出异常 IllegalStateException，而 offer 只是返回 false。 3、栈栈也是一种常用的数据结构，与队列相反，它的特点是先进后出、后进先出。Java 中用 Stack 类来表示栈，但这个类已经过时了，就 Stack 而言，在新的设计中，Queue 可以直接取代它。Java 中没有单独的栈接口，栈相关方法包括在了表示双端队列的接口 Deque 中。123456// push 表示入栈，在头部添加元素，栈的空间可能是有限的，如果栈满了，push 会抛出异常 IllegalStateExceptionvoid push(E e);// pop 表示出栈，返回头部元素，并且从栈中删除，如果栈为空，会抛出异常 NoSuchElementExceptionE pop();// peek 查看栈头部元素，不修改栈，如果栈为空，返回 nullE peek(); 4、双端队列 (Deque)栈和队列都是在两端进行操作，栈只操作头部，队列两端都操作，但尾部只添加、头部只查看和删除，有一个更为通用的操作两端的接口 Deque，Deque 扩展了 Queue，包括了栈的操作方法，此外，它还有更为明确的操作两端的方法。 xxxFirst 操作头部，xxxLast 操作尾部。与队列类似，每种操作有两种形式，区别也是在队列为空或满时，处理不同。为空时，getXXX/removeXXX 会抛出异常，而 peekXXX/pollXXX 会返回 null。队列满时，addXXX 会抛出异常，offerXXX 只是返回 false。 栈和队列只是双端队列的特殊情况，它们的方法都可以使用双端队列的方法替代，不过，使用不同的名称和方法，概念上更为清晰。 5、LinkedList 内部组成LinkedList 直译就是链表，确切的说，它的内部实现是双向链表，每个元素在内存都是单独存放的，元素之间通过链接连在一起。 为了表示链接关系，需要一个节点的概念，节点包括实际的元素，但同时有两个链接，分别指向前一个节点(前驱)和后一个节点(后继)，节点是一个内部类。123456789101112// Node 类表示节点private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList 内部组成中有三个实例变量：1234// size 表示链表长度，默认为 0transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; LinkedList 的所有 public 方法内部操作的都是这三个实例变量。 6、 add() 方法源码解析12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true;&#125;---------------------void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 7、根据索引访问元素 get()1234567891011121314151617181920212223242526272829public E get(int index) &#123; // 检查索引位置的有效性，如果无效，抛出异常 checkElementIndex(index); return node(index).item;&#125;------------------------private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;-------------------------private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;-------------------------Node&lt;E&gt; node(int index) &#123; // 根据 index 位置，来决定从前还是从后查找 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 8、indexOf 源码分析1234567891011121314151617public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 9、指定位置插入元素 add(int index, E element)12345678910111213141516171819202122232425262728293031323334353637383940414243public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;----------------------------private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;----------------------------private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;-----------------------------void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;----------------------------// 参数 succ 表示后继节点。变量 pred 就表示前驱节点。目标就是在 pred 和 succ 中间插入一个节点。void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 10、删除元素123456789101112131415161718192021222324252627282930public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;--------------------------E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 11、需要注意的是：对于队列、栈和双端队列接口，长度可能有限制，LinkedList 实现了这些接口，不过 LinkedList 对长度并没有限制。使用的时候需要特别留意那些限制。 12、对于 LinkedList 内部是用双向链表实现的，维护了长度、头节点和尾节点，这决定了它有如下特点： 按需分配空间，不需要预先分配很多空间。 不可以随机访问，按照索引位置访问效率比较低，必须从头或尾顺着链接找，效率为 O(N/2)。 不管列表是否已排序，只要是按照内容查找元素，效率都比较低，必须逐个比较，效率为 O(N)。 在两端添加、删除元素的效率很高，为 O(1)。 在中间插入、删除元素，要先定位，效率比较低，为 O(N)，但修改本身的效率很高，效率为 O(1)。 参考博客Java编程的逻辑 - 剖析 LinkedList]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(一)]]></title>
    <url>%2F2018%2F08%2F22%2FJava%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 容器总结(一) —— ArrayList 1、ArrayList 的基本原理是：内部有一个数组 elementData，一般会有一些预留的空间，有一个整数 size 记录实际的元素个数。elementData 会随着实际元素个数的增多而重新分配，而 size 则始终记录实际的元素个数。 2、add(E e) 方法源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean add(E e) &#123; // 首先调用 ensureCapacityInternal 确保数组容量是够的 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;------------------private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;-----------------private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;-----------------private void ensureExplicitCapacity(int minCapacity) &#123; // modCount 表示内部的修改次数，modCount++ 当然就是增加修改次数 modCount++; // overflow-conscious code 这里指整数运算超出其取值范围的情况 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;----------------private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 右移一位相当于除 2，所以，newCapacity 相当于 oldCapacity 的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 新建一个数组，将原先的数据拷贝到新的数组中 elementData = Arrays.copyOf(elementData, newCapacity);&#125;---------------private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 3、remove(int index) 方法源码解析12345678910111213141516171819public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;---------------private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 4、迭代foreach 适用于各种容器，比较通用。其背后的实现原理是，编译器会将 foreach 转换为类似如下代码：12345678910111213141516171819202122232425// 原先代码public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String s : list) &#123; System.out.println(s); &#125; &#125;&#125;// 编译后的 class 代码public class Test &#123; public Test() &#123; &#125; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList(); Iterator var2 = list.iterator(); while(var2.hasNext()) &#123; String s = (String)var2.next(); System.out.println(s); &#125; &#125;&#125; 迭代相关的源码：1234567891011121314// ArrayList 实现了 Iterable 接口，Iterable 表示可迭代的public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125;--------------// Iterable 中的 iterator 方法返回一个实现了 Iterator 接口的对象public interface Iterator&lt;E&gt; &#123; // hasNext() 判断是否还有元素未访问 boolean hasNext(); // next() 返回下一个元素 E next(); // remove() 删除最后返回的元素 void remove();&#125; 所以，只要对象实现了 Iterable 接口，就可以使用 foreach 语法，编译器会转换为调用 Iterable 和 Iterator 接口的方法。 5、Iterable &amp; Iterator Iterable 表示对象可以被迭代，它有一个方法 iterator()，返回 Iterator 对象，实际通过 Iterator 接口的方法进行遍历。 如果对象实现了 Iterable，就可以使用 foreach 语法。 类可以不实现 Iterable，也可以创建 Iterator 对象。 6、除了 iterator()，ArrayList 还提供了两个返回 Iterator 接口的方法：public ListIterator listIterator()public ListIterator listIterator(int index) ListIterator 扩展了 Iterator 接口，增加了一些方法，向前遍历、添加元素、修改元素、返回索引位置等。12345678public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void set(E e); void add(E e);&#125; listIterator() 方法返回的迭代器从 0 开始，而 listIterator(int index) 方法返回的迭代器从指定位置 index 开始。 7、迭代器的陷阱关于迭代器，有一种常见的误用，就是在迭代的中间调用容器的删除方法。这时候一般都会抛出 java.util.ConcurrentModificationException 异常。12345678// 调用容器的 remove 方法，会产生 ConcurrentModificationExceptionpublic void remove(ArrayList&lt;Integer&gt; list)&#123; for(Integer a : list)&#123; if(a&lt;=100)&#123; list.remove(a); &#125; &#125;&#125; 因为迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。 123456789// 而使用迭代器的 remove 方法，则不会产生异常public static void remove(ArrayList&lt;Integer&gt; list)&#123; Iterator&lt;Integer&gt; it = list.iterator(); while(it.hasNext())&#123; if(it.next()&lt;=100)&#123; it.remove(); &#125; &#125;&#125; 8、迭代器的实现原理 —— ArrayList 中 iterator 方法的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;--------------// Itr 是 ArrayList 的一个成员内部类，实现了 Iterator 接口private class Itr implements Iterator&lt;E&gt; &#123; // 表示下一个要返回的元素位置 int cursor; // index of next element to return // 表示最后一个被返回元素的索引位置，-1 表示没有返回过任何元素或者被删除了 int lastRet = -1; // index of last element returned; -1 if no such // expectedModCount 期望的修改次数，初始化为外部类当前的修改次数 modCount int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; // 每次迭代都去检查预期的 ModCount 和 现在的 ModCount 是否一致 checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 刚才判断 i &lt; size 这会 i &gt; 数组 length，中间数组结构发生改变 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; // 调用了 ArrayList 的 remove 方法，注意这里删除的是最后一个返回的元素的索引位置！！！ ArrayList.this.remove(lastRet); // 删除元素以后，后面的元素就会顶上来，所以指示下一个元素为被删除位置上的元素 cursor = lastRet; // 最后一个返回的元素删了，不存在了，所以 -1 表示 lastRet = -1; // 修改 expectedModCount，只有这样迭代的时候才不会抛异常 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;-------------- 每次发生结构性变化的时候 modCount 都会增加，而每次迭代器操作的时候都会检查 expectedModCount 是否与 modCount 相同，这样就能检测出结构性变化。 注意：使用 iterator 的 remove 方法前，必须先调用 next，从而为 lastRet 赋上正确的值，要不然是默认值 0，输出的结果很可能就是错的。而且循环删除的时候，第一次删除成功以后 lastRet 的值为 -1，再删的时候会抛异常 java.lang.IllegalStateException。 9、迭代器的好处迭代器语法更为通用，它适用于各种容器类。迭代器表示的是一种关注点分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个 Iterator 接口的引用，不需要关注数据的实际组织方式，可以使用一致和统一的方式进行访问。而提供 Iterator 接口的代码了解数据的组织方式，可以提供高效的实现。从封装的思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口。 10、Java 的各种容器类有一些共性的操作，这些共性以接口的方式体现，Iterable 接口就是如此。此外，ArrayList 还实现了三个主要的接口 Collection, List 和 RandomAccess。 11、Collection 接口Collection 表示一个数据集合，数据间没有位置或顺序的概念。boolean retainAll(Collection&lt;?&gt; c); retainAll 只保留参数容器中的元素，其他元素会进行删除。 有一个抽象类 AbstractCollection 对 Collection 接口中的很多方法都提供了默认实现，实现的方式就是利用迭代器方法逐个操作。ArrayList 继承了 AbstractList，而 AbstractList 又继承了 AbstractCollection，ArrayList 对其中一些方法进行了重写，以提供更为高效的实现。 12、List 表示有顺序或位置的数据集合，它扩展了 Collection。 13、RandomAccess 接口RandomAccess 是一个标记接口，是一个没有任何代码的接口，用于声明类的一种属性。 实现了 RandomAccess 接口的类表示可以随机访问，可随机访问就是具备类似数组那样的特性，数据在内存是连续存放的，根据索引值就可以直接定位到具体的元素，访问效率很高。 有没有声明 RandomAccess 有什么关系呢？主要用于一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现。 14、ArrayList 与 数组的相互转换1234567891011121314151617// 第一个方法返回是 Object 数组public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;-----------// 第二个方法返回对应类型的数组，如果参数数组长度足以容纳所有元素，就使用该数组，否则就新建一个数组@SuppressWarnings("unchecked")public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); // 如果指定的数组能容纳队列，并有剩余的空间（即数组的元素比队列多），那么会将数组中紧接 collection 尾部的元素设置为 null。（仅在调用者知道列表中不包含任何 null 元素时才能用此方法确定列表长度）。 if (a.length &gt; size) a[size] = null; return a;&#125; 15、Arrays 中有一个静态方法 asList 可以返回对应数组的 List。12345678public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125;--------// Arrays 类中的 ArrayList 静态内部类private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123;......&#125; 需要注意的是，这个方法返回的 List，它的实现类并不是真正的 ArrayList，而是 Arrays 类的一个内部类，在这个内部类的实现中，内部用的的数组就是传入的数组，没有拷贝，也不会动态改变大小，所以对数组的修改也会反映到 List 中。对 List 调用 add/remove 方法会抛出 java.lang.UnsupportedOperationException 异常，因为内部类中根本就不存在这些方法。 要使用 ArrayList 完整的方法，应该新建一个 ArrayList：List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(i)); 16、对于 ArrayList，它的特点是：内部采用动态数组实现，这决定了： 可以随机访问，按照索引位置进行访问效率很高，效率是 O(1)。 除非数组已排序，否则按照内容查找元素效率比较低，具体是 O(N)。 添加元素的效率还可以，重新分配和拷贝数组的开销被平摊了，具体来说，添加 N 个元素的效率为 O(N)。 插入和删除元素的效率比较低，因为需要移动元素，具体为 O(N)。 参考博客Java编程的逻辑 - 剖析 ArrayList]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(六)]]></title>
    <url>%2F2018%2F08%2F19%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(六) —— 显式锁 ReentrantLock 锁相关注意：在学习显示锁的时候要跟 synchronized 锁对比的学，synchronized 锁是由 JVM 去实现的，而显示锁是由我们来实现的，但是它们的功能都很类似，都可以对比着来学的。线程也会去争夺显示锁，争夺不到的时候也可能会阻塞，当前线程也会被放到等待队列中。 1、Java 并发包中的显式锁接口和类位于包 java.util.concurrent.locks 下，主要接口和类有： 锁接口 Lock，主要实现类是 ReentrantLock。读写锁接口 ReadWriteLock，主要实现类是 ReentrantReadWriteLock。 相比 synchronized，显式锁支持以非阻塞方式获取锁、可以响应中断、可以限时，这使得它灵活的多。 2、可重入锁 ReentrantLockLock 接口的主要实现类是 ReentrantLock，它的基本用法 lock/unlock 实现了与 synchronized 一样的语义，包括： 可重入，一个线程在持有一个锁的前提下，可以继续获得该锁。可以解决竞态条件问题。可以保证内存可见性。 public ReentrantLock(boolean fair)参数 fair 表示是否保证公平，不指定的情况下，默认为 false，表示不保证公平。所谓公平是指，等待时间最长的线程优先获得锁。保证公平会影响性能，一般也不需要，所以默认不保证，synchronized 锁也是不保证公平的。 使用显式锁，一定要记得调用 unlock。 一般而言，应该将 lock 之后的代码包装到 try 语句内，在 finally 语句内释放锁。 3、ReentrantLock 的实现原理在最底层，它依赖于 CAS 方法，另外，它依赖于类 LockSupport 中的一些方法。 LockSupport 锁相关4、类 LockSupport 也位于包 java.util.concurrent.locks 下。public static void park() park 方法使得当前线程放弃 CPU，进入等待状态(WAITING)，操作系统不再对它进行调度，只有其他线程对它调用了 unpark，unpark 需要指定一个线程，unpark 会使之恢复可运行状态。 LockSupport.park() 不同于 Thread.yield()，yield 只是告诉操作系统可以先让其他线程运行，但自己依然是可运行状态，而 park 会放弃调度资格，使线程进入 WAITING 状态。park 是响应中断的，当有中断发生时，park 会返回，线程的中断状态会被设置。另外，需要说明一下，park 可能会无缘无故的返回，程序应该重新检查 park 等待的条件是否满足。 park/unpark 方法的底层实现调用了 Unsafe 类中的对应方法，Unsafe 类最终调用了操作系统的 API，从程序员的角度，我们可以认为 LockSupport 中的这些方法就是基本操作。 AQS 相关AQS：AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等），JUC 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。AQS 解决了实现同步器时涉及到的大量细节问题，例如获取同步状态、FIFO 同步队列。在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。AQS 的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。AQS 的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。AbstractQueuedSynchronizer 为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件，等等）提供一个框架。 5、AQS (AbstractQueuedSynchronizer)利用 CAS 和 LockSupport 提供的基本方法，就可以用来实现 ReentrantLock 了。但 Java 中还有很多其他并发工具，如 ReentrantReadWriteLock、Semaphore、CountDownLatch，它们的实现有很多类似的地方，为了复用代码，Java 提供了一个抽象类 AbstractQueuedSynchronizer，我们简称为 AQS。 用于实现锁时，AQS 可以保存锁的当前持有线程，提供了方法进行查询和设置： private transient Thread exclusiveOwnerThread;protected final void setExclusiveOwnerThread(Thread t);protected final Thread getExclusiveOwnerThread(); AQS 内部维护了一个等待队列，借助 CAS 方法实现了无阻塞算法进行更新。等待队列是 FIFO 先进先出，只有前一个节点的状态为 SIGNAL 时，当前节点的线程才能被挂起。子类重写 tryAcquire 和 tryRelease 方法通过 CAS 指令修改状态变量 state。 6、保证公平整体性能比较低，低的原因不是这个检查慢，而是会让活跃线程得不到锁，进入等待状态，引起上下文切换，降低了整体的效率，通常情况下，谁先运行关系不大，而且长时间运行，从统计角度而言，虽然不保证公平，也基本是公平的。 需要说明是，即使 fair 参数为 true，ReentrantLock 中不带参数的 tryLock 方法也是不保证公平的，它不会检查是否有其他等待时间更长的线程。 7、ReentrantLock 对比 synchronized相比 synchronized，ReentrantLock 可以实现与 synchronized 相同的语义，但还支持以非阻塞方式获取锁、可以响应中断、可以限时等，更为灵活。不过，synchronized 的使用更为简单，写的代码更少，也更不容易出错。 synchronized 代表一种声明式编程，程序员更多的是表达一种同步声明，由 Java 系统负责具体实现，程序员不知道其实现细节，显式锁代表一种命令式编程，程序员实现所有细节。 声明式编程的好处除了简单，还在于性能，在较新版本的 JVM 上，ReentrantLock 和 synchronized 的性能是接近的，但 Java 编译器和虚拟机可以不断优化 synchronized 的实现，比如，自动分析 synchronized 的使用，对于没有锁竞争的场景，自动省略对锁获取/释放的调用。 8、显式锁 ReentrantLock 使用 CAS、LockSupport 和 AQS 实现的。 9、总结：能用 synchronized 就用 synchronized，不满足要求，再考虑 ReentrantLock。 参考博客Java编程的逻辑 - 显式锁深入浅出 Java 同步器 AQS深入学习 Java 同步器 AQS]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(五)]]></title>
    <url>%2F2018%2F08%2F17%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(五) —— 原子变量和 CAS 原子变量相关1、Java 并发包中的基本原子变量类型有： AtomicBoolean：原子 Boolean 类型AtomicInteger：原子 Integer 类型AtomicLong：原子 Long 类型AtomicReference：原子引用类型 针对 Integer, Long 和 Reference 类型，还有对应的数组类型： AtomicIntegerArrayAtomicLongArrayAtomicReferenceArray 为了便于以原子方式更新对象中的字段，还有如下的类： AtomicIntegerFieldUpdaterAtomicLongFieldUpdaterAtomicReferenceFieldUpdater AtomicReference 还有两个类似的类，在某些情况下更为易用： AtomicMarkableReferenceAtomicStampedReference 2、对于 char, short, float, double 类型的原子变量，可以转为 int/long，然后使用 AtomicInteger 或 AtomicLong。eg：float 类型和 int 类型互相转换：12public static int floatToIntBits(float value)public static float intBitsToFloat(int bits); 3、之所以称为原子变量，是因为其包含一些以原子方式实现组合操作的方法。这些方法的实现都依赖另一个 public 方法：public final boolean compareAndSet(int expect, int update)比较并设置。该方法以原子方式实现了如下功能：如果当前值等于 expect，则更新为 update，否则不更新，如果更新成功，返回 true，否则返回 false。 AtomicInteger 源码解析：12345678910111213141516171819public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; // 用 volatile 关键字保证获取到的当前值是内存中的最新值 private volatile int value; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; // unsafe 中的 compareAndSwapInt 方法，用 native 声明，该方法封装了底层操作系统的硬件级别的原子操作 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);&#125; 什么是 unsafe 呢？Java 语言不像 C，C++ 那样可以直接访问底层操作系统，但是 JVM 为我们提供了一个后门，这个后门就是 unsafe。unsafe 为我们提供了硬件级别的原子操作。 至于 valueOffset 对象，是通过 unsafe.objectFieldOffset 方法得到，它是一个 native 声明的方法，所代表的是 AtomicInteger 对象的成员变量 value 在内存中的偏移量。我们可以简单地把 valueOffset 理解为 value 变量的内存地址。 CAS 的底层实现？1、用 volatile 关键字保证获取到的 value 当前值是内存中的最新值。2、使用静态代码块在类初始化的时候就获取到某个对象的成员变量 value 在内存中的偏移量 valueOffset，可以简单的理解为 value 变量的内存地址。3、compareAndSwapInt 是 native 声明的方法，封装了底层操作系统的硬件级别的原子操作。4、所谓的自旋操作实际上就是在一个死循环中不断的调用操作系统硬件级别的原子操作，直到成功为止。说到底，正是因为 unsafe 该方法封装了底层操作系统的硬件级别的原子操作，例如：compareAndSwapInt，才能有 Java 的 CAS。 什么是 ABA 问题？如何解决？所谓 ABA 问题，就是一个变量的值从 A 改成了 B，又从 B 改成了 A。虽然表面上看，某块内存里的值没有改变，但是实际上此 A 非彼 A。但是在使用 CAS 进行更新的时候，会认为两个 A 是同一个 A，从而产生问题。「当一个值从 A 更新成 B，又更新会 A，普通 CAS 机制会误判通过检测。利用版本号比较可以有效解决 ABA 问题。」 要想解决 ABA 问题，本质上就是要区分此 A 非彼 A。例如：给 A 加个版本号。真正要做到严谨的 CAS 机制，在 Compare 阶段不仅要比较期望值和地址中的实际值，还要比较变量的版本号是否一致。在 Java 当中，AtomicStampedReference 类 和 AtomicMarkableReference 类就实现了用版本号做比较的 CAS 机制。 4、synchronized VS CASsynchronized 是悲观的，它假定更新很可能冲突，所以先获取锁，得到锁后才更新。原子变量的更新逻辑是乐观的，它假定冲突比较少，但使用 CAS 更新，也就是进行冲突检测，如果确实冲突了，那也没关系，继续尝试就好了。 synchronized 代表一种阻塞式算法，得不到锁的时候，进入锁等待队列，等待其他线程唤醒，有上下文切换开销。原子变量的更新逻辑是非阻塞式的，更新冲突的时候，它就重试，不会阻塞，不会有上下文切换开销。 原子变量是比较简单的，但对于复杂一些的数据结构和算法，非阻塞方式往往难于实现和理解，幸运的是，Java 并发包中已经提供了一些非阻塞容器。 ConcurrentLinkedQueue 和 ConcurrentLinkedDeque：非阻塞并发队列。ConcurrentSkipListMap 和 ConcurrentSkipListSet：非阻塞并发 Map 和 Set。 5、AtomicReference 用来以原子方式更新复杂类型，它有一个类型参数，使用时需要指定引用的类型。 原子数组方便以原子的方式更新数组中的每个元素。public AtomicIntegerArray(int[] array) 注意：该方法接受一个已有的数组，但不会直接操作该数组，而是会创建一个新数组，只是拷贝参数数组中的内容到新数组。 FieldUpdater 方便以原子方式更新对象中的字段，字段不需要声明为原子变量，FieldUpdater 是基于反射机制实现的。 CAS 相关1、什么是 CAS？CAS 是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换。CAS 机制当中使用了 3 个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。 2、CAS 机制的缺点？CAS 虽然没有上下文切换了，但却是在消耗 CPU 不停的自旋，即 CPU 不停的重新计算。CAS 机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。ABA 问题。 3、CAS 的底层实现？什么是 unsafe 呢？Java 语言不像 C，C++ 那样可以直接访问底层操作系统，但是 JVM 为我们提供了一个后门，这个后门就是 unsafe。unsafe 为我们提供了硬件级别的原子操作。unsafe 是 Sun 的私有实现，从名字看，表示的也是”不安全”，一般应用程序不应该直接使用。原理上，一般的计算机系统都在硬件层次上直接支持 CAS 指令，而 Java 的实现都会利用这些特殊指令。从程序的角度看，我们可以将 compareAndSet 视为计算机的基本操作，直接接纳就好。 至于 valueOffset 对象，是通过 unsafe.objectFieldOffset 方法得到，所代表的是 AtomicInteger 对象 value 成员变量在内存中的偏移量。我们可以简单地把 valueOffset 理解为 value 变量的内存地址。 CAS 是 Java 并发包的基础，基于它可以实现高效的、乐观、非阻塞式数据结构和算法，它也是并发包中锁、同步工具和各种容器的基础。 123456789101112131415private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 4、CAS 中的 ABA 问题？所谓 ABA 问题，就是一个变量的值从 A 改成了 B，又从 B 改成了 A。即当一个值从 A 更新成 B，又更新会 A，普通 CAS 机制会误判通过检测。真正要做到严谨的 CAS 机制，我们在 Compare 阶段不仅要比较期望值 A 和地址 V 中的实际值，还要比较变量的版本号是否一致。在 Java 中，AtomicStampedReference 类就实现了用版本号做比较的 CAS 机制。ABA 是不是一个问题与程序的逻辑有关。 volatile 相关首先明确一点，volatile 修饰符并不是 Java 语言的首创，早在 C 和 C++ 当中就已经存在了。 注意：工作内存所做的修改不会立刻同步到主内存，所以可能会产生问题。 1、什么是 volatile 关键字？Java 内存模型简称 JMM（Java Memory Model）。线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。 volatile 关键字保证了用 volatile 修饰的变量对所有线程的可见性。可见性是指：当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。注意的是 volatile 只能保证变量的可见性，并不能保证变量的原子性。 volatile 保证可见性的特性，得益于 Java 语言的 先行发生原则（happens-before）。先行发生原则是指：在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。 2、什么是指令重排？指令重排是指JVM在编译Java代码的时候，或者 CPU 在执行 JVM 字节码的时候，对现有的指令顺序进行重新排序。指令重排是在字节码指令的层面进行重排序的。 指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。 3、什么是内存屏障？内存屏障（Memory Barrier）是一种 CPU 指令。内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使 CPU 或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。 内存屏障共分为四种类型： 1.LoadLoad 屏障抽象场景：Load1; LoadLoad; Load2Load1 和 Load2 代表两条读取指令。在 Load2 要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。 2.StoreStore 屏障抽象场景：Store1; StoreStore; Store2Store1 和 Store2 代表两条写入指令。在 Store2 写入执行前，保证 Store1 的写入操作对其它处理器可见。 3.LoadStore 屏障抽象场景：Load1; LoadStore; Store2在 Store2 被写入前，保证 Load1 要读取的数据被读取完毕。 4.StoreLoad 屏障抽象场景：Store1; StoreLoad; Load2在 Load2 读取操作执行前，保证 Store1 的写入对所有处理器可见。StoreLoad 屏障的开销是四种屏障中最大的。 4、volatile 如何使用内存屏障来保证变量在线程之间的可见性？在一个变量被 volatile 修饰后，JVM 会为我们做两件事：1.在每个 volatile 写操作前插入 StoreStore 屏障，在写操作后插入 StoreLoad 屏障。2.在每个 volatile 读操作前插入 LoadLoad 屏障，在读操作后插入 LoadStore 屏障。 5、volatile 只是保证，写的时候能够立刻从工作内存同步到主内存中，读的时候，一定读的是当前内存中的最新值，仅此而已。它不会保证原子性，如果 10 个线程同时读，它们都会读到内存中的最新值，但是，只会读一次，之后内存中的值改变了，就必须重新读了，重新读的时候，依然是当前时刻内存中的最新值。即 volatile 值负责它读的那一刻，读取到的是内存中的最新值，至于以后内存中的该值怎么变化，跟它已经没关系了。 参考博客什么是 CAS 机制？什么是 CAS 机制？(进阶篇)什么是 volatile 关键字？Java 编程的逻辑 - 原子变量和 CAS用户模式和内核模式]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(四)]]></title>
    <url>%2F2018%2F08%2F17%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(四) —— 线程的中断 1、在 Java 中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。 2、每个线程都有一个标志位，表示该线程是否被中断了。被中断了为 true，没有被中断或默认值为 false。 3、Thread 类定义了以下关于中断的方法： public boolean isInterrupted()：就是返回对应线程的中断标志位是否为 true。 public void interrupt()。 public static boolean interrupted() interrupted() 是静态方法，实际会调用 Thread.currentThread() 操作当前线程。返回当前线程的中断标志位是否为 true，但它还有一个重要的副作用，就是清空中断标志位，也就是说，连续两次调用 interrupted()，第一次返回的结果为 true，第二次一般就是 false「除非同时又发生了一次中断」。 4、线程对中断的反应interrupt() 对线程的影响与线程的状态和正在进行的 IO 操作有关，我们先主要考虑线程的状态： RUNNABLE：线程在运行或具备运行条件只是在等待操作系统调度。如果线程在运行中，且没有执行 IO 操作，interrupt() 只是会设置线程的中断标志位，没有任何其它作用。线程应该在运行过程中合适的位置检查中断标志位 WAITING/TIMED_WAITING：线程在等待某个条件或超时。在这些状态时，对线程对象调用 interrupt() 会使得该线程抛出 InterruptedException，需要注意的是，抛出异常后，中断标志位会被清空，而不是被设置。 BLOCKED：线程在等待锁，试图进入同步块。如果线程在等待锁，对线程对象调用 interrupt() 只是会设置线程的中断标志位，线程依然会处于 BLOCKED 状态，也就是说，interrupt() 并不能使一个在等待锁的线程真正”中断”。在使用 synchronized 关键字获取锁的过程中不响应中断请求，这是 synchronized 的局限性。 如果这对程序是一个问题，应该使用显式锁，它支持以响应中断的方式获取锁。 NEW/TERMINATED：线程还未启动或已结束。如果线程尚未启动 (NEW)，或者已经结束 (TERMINATED)，则调用 interrupt() 对它没有任何效果，中断标志位也不会被设置。 5、捕获到 InterruptedException，通常表示希望结束该线程，线程大概有两种处理方式： 1.向上传递该异常，这使得该方法也变成了一个可中断的方法，需要调用者进行处理。 2.有些情况，不能向上传递异常，比如 Thread 的 run 方法，它的声明是固定的，不能抛出任何受检异常，这时，应该捕获异常，进行合适的清理操作，清理后，一般应该调用 Thread的 interrupt 方法设置中断标志位，使得其他代码有办法知道它发生了中断。 6、IO 操作如果线程在等待 IO 操作，尤其是网络 IO，则会有一些特殊的处理： 如果 IO 通道是可中断的，即实现了 InterruptibleChannel 接口，则线程的中断标志位会被设置，同时，线程会收到异常 ClosedByInterruptException。 如果线程阻塞于 Selector 调用，则线程的中断标志位会被设置，同时，阻塞的调用会立即返回。 7、InputStream 的 read 调用，该操作是不可中断的，如果流中没有数据，read 会阻塞 (但线程状态依然是 RUNNABLE)，且不响应 interrupt()，与 synchronized 类似，调用 interrupt() 只会设置线程的中断标志，而不会真正”中断”它。 8、如何正确地取消/关闭线程？interrupt 方法不一定会真正”中断”线程，它只是一种协作机制，如果不明白线程在做什么，不应该贸然的调用线程的 interrupt 方法，以为这样就能取消线程。 对于以线程提供服务的程序模块而言，它应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用者应该调用这些方法而不是直接调用 interrupt。 在 Java 中如何取消/关闭线程，主要依赖的技术是中断，但它是一种协作机制，不会强迫终止线程。作为线程的实现者，应该提供明确的取消/关闭方法，并用文档描述清楚其行为，作为线程的调用者，应该使用其取消/关闭方法，而不是贸然调用 interrupt。 参考博客Java 编程的逻辑 - 线程的中断]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(三)]]></title>
    <url>%2F2018%2F08%2F16%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(三) —— 线程的基本协作机制 1、Java 中多线程协作的基本机制 wait/notify。 2、常见的线程协作场景： 生产者/消费者协作模式 同时开始 等待结束 异步结果 集合点 3、Java 在 Object 类中，定义了一些线程协作的基本方法，使得每个对象都可以调用这些方法，这些方法有两类，一类是 wait，另一类是 notify。 4、wait() 方法的原理？每个对象都有一把锁和一个锁等待队列，一个线程在进入 synchronized 代码块时，会尝试获取锁，获取不到的话会把当前线程加入到锁等待队列中。除了用于锁的等待队列，每个对象还有另一个等待队列，表示条件队列，该队列用于线程间的协作。调用 wait 就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，这个条件它自己改变不了，需要其他线程改变。当其他线程改变了条件后，应该调用 Object 的 notify 方法。wait 虽然是在 synchronzied 方法内，但调用 wait 时，线程会释放对象锁。 而 notify 做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll 和 notify 的区别是，它会移除条件队列中所有的线程并全部唤醒。wait 的具体过程是： 1.把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为 WAITING 或 TIMED_WAITING。 2.等待时间到或被其他线程调用 notify/notifyAll 从条件队列中移除，这时，要重新竞争对象锁。 如果能够获得锁，线程状态变为 RUNNABLE，并从 wait 调用中返回。 否则，该线程加入对象锁等待队列，线程状态变为 BLOCKED，只有在获得锁后才会从 wait 调用中返回。 3.线程从 wait 调用中返回后，不代表其等待的条件就一定成立了，它需要重新检查其等待的条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class WaitThread extends Thread&#123; // 协作的条件变量是 fire private volatile boolean fire = false; @Override public void run() &#123; try &#123; synchronized (this) &#123; while (!fire) &#123; System.out.println("wait......before"); wait(); System.out.println("wait......after"); &#125; &#125; System.out.println("fired"); &#125; catch (InterruptedException e) &#123; &#125; &#125; // 两个线程都要访问协作的变量 fire，容易出现竞态条件，所以相关代码都需要被 synchronized 保护 public synchronized void fire() &#123; this.fire = true; notify(); &#125; public static void main(String[] args) throws InterruptedException &#123; WaitThread t = new WaitThread(); /** * 线程启动以后，开始了 run 方法的执行，首先获取 WaitThread 的对象锁 * 然后执行 while 循环，由于「fire = false」，所以进入 while 循环体 * 执行 wait 方法，即放弃对象锁，并把单前线程 t 加入到条件等待队列中，然后线程阻塞在了 wait 方法这，不再向下执行 */ t.start(); Thread.sleep(1000); System.out.println("fire"); /** * 主线程执行 fire 方法，干了两件事：把 fire 设置为 true，调用了 WaitThread 对象的 notify 方法 * 一旦调用 notify 方法，等待的 t 线程就被唤醒了，并且把 t 线程从条件等待队列中移除 * 接下来，t 线程要尝试去获取 WaitThread 对象的锁，但是现在这把锁被主线程在 fire 方法中占用了，只有等到主线程释放它才可以获得到 * 由于 t 获取锁没有获取到，所以 t 线程加入到了 WaitThread 对象的锁等待队列中了，挪坑了！ * 当主线程释放锁以后，t 线程终于抢到了锁，然后 t 线程从 wait 调用中返回了，开始执行 wait 调用下面的语句 「System.out.println("wait......after");」 * 然后开始执行下一轮 while 循环，发现条件变了，所以不再进入 while 循环，直接执行「System.out.println("fired");」，然后 t 线程结束使命 */ t.fire(); &#125;&#125; 5、notify() 方法的原理？notify 做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒。调用 notify 会把在条件队列中等待的线程唤醒并从队列中移除，但它「这里指主线程」不会释放对象锁，也就是说，只有在包含 notify 的 synchronzied 代码块执行完后，等待的线程才会从 wait 调用中返回。 6、wait/notify 方法只能在 synchronized 代码块内被调用，如果调用 wait/notify 方法时，当前线程没有持有对象锁，会抛出异常 java.lang.IllegalMonitorStateException。 那么问题来了：为什么wait(),notify(),notifyAll() 必须在同步方法/代码块中调用？因为 wait() 和 notify() 之间的竞态条件导致必须在同步方法/代码块中调用，因为 wait 和 notify 都需要访问和操作对象的等待队列，wait 入队，notify 出队，它们对等待队列的访问顺序是敏感的，所以需要放到同步代码中，以避免竞态条件问题。 在 Java 中，所有对象都能够被作为「监视器即 Monitor」，而监视器是指：一个拥有 一个独占锁，一个入口队列和一个等待队列的 实体。对于对象的同步方法来说，在任意时刻有且仅有一个拥有该对象独占锁的线程能够调用它们。eg：一个同步方法是独占的。如果在线程调用某一对象的同步方法时，对象的独占锁被其他线程拥有，那么当前线程将处于阻塞状态，并添加到对象的入口队列中。 当一个线程正在某一个对象的同步方法中运行时调用了这个对象的 wait() 方法，那么这个线程将释放该对象的独占锁并被放入这个对象的等待队列。注意，wait() 方法强制当前线程释放对象锁。这意味着在调用某对象的 wait() 方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的 wait() 方法。 当某线程调用某对象的 notify() 或 notifyAll() 方法时，任意一个或者所有在该对象的等待队列中的线程，将被转移到该对象的入口队列。 调用 wait() 方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用 notify()或notifyAll() 方法的原因通常是，调用线程希望告诉其他等待中的线程「特殊状态已经被设置」。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。 假设 wait(),notify(),notifyAll() 方法不需要加锁就能够被调用。此时消费者线程调用 wait() 正在进入状态变量的等待队列(可能还未进入)。在同一时刻，生产者线程调用 notify() 方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞「因为该线程还没有进入到等待队列中，但是 notify 开始检查等待队列是否有线程了，检查发现没有，notify 失效，这时该线程进入到了等待队列，可能永远错过被唤醒的机会」。因此，对象的 wait(),notify(),notifyAll() 方法必须在该对象的同步方法或同步代码块中被互斥地调用。 简单总结一下，wait/notify 方法看上去很简单，但往往难以理解 wait 等的到底是什么，而 notify 通知的又是什么，我们需要知道，它们与一个共享的条件变量有关，这个条件变量是程序自己维护的，当条件不成立时，线程调用 wait 进入条件等待队列，另一个线程修改了条件变量后调用 notify，调用 wait 的线程唤醒后需要重新检查条件变量。从多线程的角度看，它们围绕共享变量进行协作，从调用 wait 的线程角度看，它阻塞等待一个条件的成立。 我们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心。 上面的代码的共享变量是 WaitThread 对象的 fire 变量，结束等待的条件是 fire 的值为 true，这是面代码协作的核心。但是，协作的核心虽然是 fire 变量，但是作用的却是 WaitThread 整个对象，是通过这个对象的条件队列进行协作的，而不是这个对象的某个变量。 7、Java 中每个对象只能有一个条件等待队列，这是 Java wait/notify 机制的局限性，这使得对于等待条件的分析变得复杂。 8、Java 提供了专门的阻塞队列实现，包括： 接口 BlockingQueue 和 BlockingDeque 基于数组的实现类 ArrayBlockingQueue 基于链表的实现类 LinkedBlockingQueue 和 LinkedBlockingDeque 基于堆的实现类 PriorityBlockingQueue 9、Java 中线程间协作的基本机制 wait/notify，协作关键要想清楚协作的共享变量和条件是什么。 参考博客Java 编程的逻辑 - 线程的基本协作机制 (上)Java 编程的逻辑 - 线程的基本协作机制 (下)为什么 wait(),notify(),notifyAll() 必须在同步方法/代码块中调用？为什么 wait 和 notify 必须在同步方法或同步块中调用]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(二)]]></title>
    <url>%2F2018%2F08%2F15%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(二) —— synchronized 关键字 1、Java 中的每一个对象都可以作为锁。具体表现为以下三种形式： 对于普通同步方法，锁是当前实例对象。对于静态同步方法，锁是当前类的 Class 对象。对于同步代码块，锁是 synchronized 括号里配置的对象。 synchronized 可以用于修饰「普通方法、静态方法、代码块」。 2、synchronized 用于「实例方法」的时候？synchronized 用于「实例方法」的时候到底做了什么呢？看上去，synchronized 使得同时只能有一个线程执行实例方法，但这个理解是不确切的。多个线程是可以同时执行同一个 synchronized 实例方法的，只要它们「访问的对象」是不同的。 synchronized 实例方法实际保护的是 同一个对象的方法调用，确保同时只能有一个线程执行。 再具体来说，synchronized 实例方法保护的是当前实例对象，即 this，this 对象有 一个锁和一个等待队列，锁只能被一个线程持有，其他试图获得同样锁的线程需要等待，加入到等待队列中。 执行 synchronized 实例方法的过程大概如下： 1.尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒。2.执行实例方法体代码。3.释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的，不保证公平性。 当前线程不能获得锁的时候，它会加入等待队列等待，线程的状态会变为 BLOCKED。 3、synchronized 保护的是对象而非代码，只要访问的是同一个对象的 synchronized 方法，即使是不同的代码，也会被同步顺序访问。 synchronized 方法不能防止非 synchronized 方法被同时执行。一般在保护变量时，需要在所有访问该变量的方法上加上 synchronized。 4、synchronized 用于「静态方法」的时候？前面我们说，synchronized 保护的是对象，对实例方法，保护的是当前实例对象 this，对静态方法，保护的是哪个对象呢？是类对象，即「类名称.class」，实际上，每个对象都有一个锁和一个等待队列，类对象也不例外。 synchronized 静态方法和 synchronized 实例方法保护的是不同的对象，不同的两个线程，可以同时，一个执行 synchronized 静态方法，另一个执行 synchronized 实例方法。 5、synchronized 用于「代码块」的时候？synchronized 括号里面的就是保护的对象，对于实例方法，就是 this，{} 里面是同步执行的代码。synchronized 同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。 6、synchronized 之可重入性synchronized 有一个重要的特征，它是可重入的，也就是说，对同一个执行线程，它在获得了锁之后，在调用其他需要 同样锁 的代码时，可以直接调用。 可重入是通过记录锁的持有线程和持有数量来实现的，当调用被 synchronized 保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。 7、synchronized 之内存可见性synchronized 除了保证原子操作外，它还有一个重要的作用，就是保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据。 不过，如果只是为了保证内存可见性，使用 synchronzied 的成本有点高，有一个更轻量级的方式，那就是给变量加修饰符 volatile。加了 volatile 之后，Java 会在操作对应变量时插入特殊的指令，保证读写到内存最新值，而非缓存的值。 8、synchronized 之解决死锁使用 synchronized 或者其他锁，要注意死锁。关于死锁解决，首先，应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁。使用显式锁接口 Lock，它支持尝试获取锁和带时间限制的获取锁方法，使用这些方法 可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。 一旦出现了死锁，Java 不会主动处理，借助一些工具，我们可以发现运行中的死锁。eg：Java 自带的 jstack 命令会报告发现的死锁。 9、同步容器Collections 的一些方法，它们可以返回线程安全的同步容器，它们是给所有容器方法都加上 synchronized 来实现安全的。这里线程安全针对的是容器对象，指的是当多个线程并发访问同一个容器对象时，不需要额外的同步操作，也不会出现错误的结果。 但是，加了 synchronized，所有方法调用变成了原子操作，客户端在调用时，是不是就绝对安全了呢？不是的，至少有以下情况需要注意： 复合操作，比如先检查再更新。对于 putIfAbsent 方法，虽然 get、put 方法是同步的，但是可能有多个线程都执行了检查者一步，然后都调用 put 方法，破坏了 putIfAbsent 方法期望保持的语义。 伪同步，即同步了不同的对象。如果给 putIfAbsent 方法加上 synchronized 关键字，虽然 putIfAbsent 方法是同步方法了，但是，put 方法没有加呢，其他线程照样可以调用该方法进行 put，同步错对象了。解决办法是要么 EnhancedMap 中的所有方法都需要加上 synchronized，要么使用 map 作为锁。 迭代，对于同步容器对象，虽然单个操作是安全的，但迭代并不是。eg：创建一个同步 List 对象，一个线程修改 List，另一个遍历，会产生 ConcurrentModificationException 异常。如果在遍历的同时容器发生了结构性变化，就会抛出该异常，同步容器并没有解决这个问题，如果要避免这个异常，需要在遍历的时候给整个容器对象加锁。 123456789101112131415161718192021public class EnhancedMap &lt;K, V&gt; &#123; Map&lt;K, V&gt; map; public EnhancedMap(Map&lt;K,V&gt; map)&#123; this.map = Collections.synchronizedMap(map); &#125; public V putIfAbsent(K key, V value)&#123; V old = map.get(key); if(old!=null)&#123; return old; &#125; // 注意这里的 put 方法是下面即本类中定义的 put 方法，不是 map 中的 put 方法 map.put(key, value); return null; &#125; public void put(K key, V value)&#123; map.put(key, value); &#125;&#125; 11、并发容器同步容器的性能是比较低的，当并发访问量比较大的时候性能很差。所幸的是，Java 中还有很多专为并发设计的容器类，比如： CopyOnWriteArrayListConcurrentHashMapConcurrentLinkedQueueConcurrentSkipListSet 这些容器类都是线程安全的，但都没有使用 synchronized、没有迭代问题、直接支持一些复合操作、性能也高得多。 参考博客Java编程的逻辑 - 理解 synchronizedsynchronized 的可重入性]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 未解之谜]]></title>
    <url>%2F2018%2F08%2F15%2FJava%E6%9C%AA%E8%A7%A3%E4%B9%8B%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[记录 Java 学习过程中百思不得其解的问题 问题1：Thread 类的 join() 方法，到底释放对象锁吗？从 join() 的源码来看其调用了 wait() 方法，那么就是要释放对象锁，但是看到的好多博客却说它不会释放对象锁？求解！ 问题2：synchronized 锁住类对象的时候，到底锁住了些什么？为什么实例对象还可以正常使用？这个问题可以转化为，实例对象和类对象的区别？或者说它们都包含了些什么？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(一)]]></title>
    <url>%2F2018%2F08%2F14%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(一) —— 线程的基本概念 1、并发：在程序中创建线程来启动多条执行流，从而达到并发。 2、线程：表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。 3、Java 中有两种创建线程的方式，不管用哪种方式创建线程，都有以下特征： run() 方法是线程执行的主体，run() 方法也是线程执行的入口。线程只会执行 run() 方法里面的语句「包括被 run() 方法调用的语句」。 启动线程必须通过 Thread 对象的 start() 方法进行启动，线程启动以后就会去执行对应的 run() 方法。 4、在多线程中，当所有线程都执行完毕的时候，程序才会退出「这里的线程不包括 daemon 守护线程」。即：当整个程序中剩下的都是 daemo 线程的时候，程序就会退出。 5、Java 中线程有一个优先级的概念，这个优先级会被映射到操作系统中线程的优先级，优先级映射到操作系统中时，到底有没有用，有多大用，都是未知不可控的。优先级对操作系统而言更多的是一种建议和提示，开发中，不要过于依赖优先级。 6、线程的状态 7、什么是守护线程 daemon？它一般是其他线程的辅助线程，在它辅助的主线程退出的时候，它就没有存在的意义了。例如：在我们运行一个即使最简单的 「hello world」的程序时，实际上，Java 也会创建多个线程，除了 main 线程外，至少还有一个负责垃圾回收的线程，这个线程就是 daemo 线程，在 main 线程结束的时候，垃圾回收线程也会退出。 8、Thread 的 sleep 方法：让当前线程睡眠指定的时间。睡眠期间，线程会让出 cpu，但是不会放弃对象锁。 9、Thread 的 yield 方法：让当前线程让出 cup。调用该方法，是告诉操作系统的调度器，我现在不着急占用 CPU，你可以先让其他线程运行。不过这个也仅仅只是建议，调度器如何处理是不一定的。该方法可能会让出 CPU，让出 CPU 后，它自己进入到就绪队列，接着参与下一次的 CPU 竞争，有可能再次拿到 CPU，并且该方法是不释放对象锁的。 10、Thread 的 join 方法：让调用 join 的线程等待该线程结束。123456789101112public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(); t.start(); /** * main 线程调用 t.join() 方法 * 即调用 join 的线程是 main 线程 * 即让 main 线程等到 t 线程结束 */ t.join(); &#125;&#125; join 方法的本质是调用了 wait() 方法，由于使用 wait() 方法，那么必定有一个地方在 wait() 所等待的条件满足时，唤醒该线程。这个地方就是：当线程运行结束的时候，Java 系统调用 notifyAll 来通知。 11、在分析代码执行过程时，理解代码在被哪个线程执行是很重要的。要理清执行流、内存和程序代码之间的关系。 12、当多条执行流执行相同的程序代码时，每条执行流都有自己单独的栈，方法中的参数和局部变量都有自己的一份。 当多条执行流可以操作相同的变量时，可能会出现一些意料之外的结果。 13、什么竞态条件？所谓竞态条件「race condition」是指，当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确。 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。 解决竞态条件的方法有：使用 synchronized 关键字、使用显示锁、使用原子变量。 14、什么是内存可见性问题？多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到，甚至永远也看不到。 在计算机系统中，除了内存，数据还会被缓存在 CPU 的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或 CPU 缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，而稍后才会同步更新到内存中。在单线程的程序中，这一般不是个问题，但在多线程的程序中，尤其是在有多 CPU 的情况下，这就是个严重的问题。一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。 解决内存可见性的方法有：使用 volatile 关键字、使用 synchronized 关键字、使用显示锁。 15、线程的优点：充分利用多 CPU 的计算能力；充分利用硬件资源；在用户界面「GUI」应用程序中，保持程序的响应性；简化建模及 IO 处理。 16、线程的成本：需要消耗操作系统的资源；需要创建时间；线程调度和切换。 参考博客Java编程的逻辑——线程的基本概念Java 线程 Thread.join 方法解析竞态条件与临界区]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的加载]]></title>
    <url>%2F2018%2F08%2F13%2F%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031public class A &#123; private static A a1 = new A(); private static A a2 = new A(); static &#123; System.out.println("A 静态块"); &#125; &#123; System.out.println("A 构造块"); &#125; public A() &#123; System.out.println("A 构造方法"); &#125;&#125;----------------------------public class Test &#123; public static void main(String[] args) &#123; A a = new A(); &#125;&#125;---------------------------输出结果：A 构造块A 构造方法A 构造块A 构造方法A 静态块A 构造块A 构造方法 1234567891011121314151617181920212223242526272829303132public class B extends A&#123; static &#123; System.out.println("B 静态块"); &#125; &#123; System.out.println("B 构造块"); &#125; public B() &#123; System.out.println("B 构造方法"); &#125;&#125;-----------------------public class Test &#123; public static void main(String[] args) &#123; A a = new A(); &#125;&#125;----------------------输出结果：A 构造块A 构造方法A 构造块A 构造方法A 静态块B 静态块A 构造块A 构造方法B 构造块B 构造方法--------------------- 12345678910111213141516171819202122232425262728public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println("构造块"); &#125; static &#123; System.out.println("静态块"); &#125; public static void main(String[] args) &#123; B t = new B(); &#125;&#125;--------------静态块：用static申明，JVM加载类时执行，仅执行一次构造块：类中直接用&#123;&#125;定义，每一次创建对象时执行执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法静态块按照申明顺序执行，所以先执行publicstaticB t1 = newB();该语句创建对象，则又会调用构造块，输出构造块接着执行public static B t1 = new B();输出构造块再执行static&#123;System.out.println("静态块");&#125;输出静态块最后main方法执行，创建对象，输出构造块。 一个类的信息主要包括以下部分： 1.类变量（静态变量）2.类初始化代码3.类方法（静态方法）4.实例变量5.实例初始化代码6.实例方法7.父类信息引用 类初始化代码包括： 定义静态变量时的赋值语句 静态初始化代码块 实例初始化代码包括： 定义实例变量时的赋值语句 实例初始化代码块 构造方法 instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F12%2FJava%E7%B1%BB%E9%9B%86%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 类集总结(一) 什么是类集？类集实际上就是一个动态的对象数组，与一般的对象数组不同，类集中的对象内容可以任意扩充。类集是专门解决对象数组长度限制问题的，使用类集可以方便的向数组中增加任意多个数据。 类集框架主要接口参考博客https://blog.csdn.net/ljcITworld/article/details/52041836]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(二)]]></title>
    <url>%2F2018%2F08%2F10%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(二) 1、一般来说，程序的结构包含以下三种： 1.顺序结构2.选择结构3.循环结构：根据判断条件的成立与否，决定程序段落的执行次数，而这个程序段落就称为循环主体。 2、三目运算符：「变量 = 条件判断 ？ 表达式1 : 表达式2」；日常开发中，要善于利用三目运算符来减少代码量。 3、switch 语句 注意： break 表示退出整个 switch() 语句块，如果不写 break，则表示从第一个满足条件的 case 开始，之后的所有 case 中的语句都要执行，直到遇到 break 为止或 swithc() 语句块结束。所以使用时每个 case 包括 default 中都必须加上 break 语句。 12345678910111213141516171819/*** 表达式类型取值范围：* char、byte、short、int* Character、Byte、Short、Integer* String、enum*/switch (表达式) &#123; case 选择值1: 语句主体1; // break 表示退出整个 switch() 语句块 break; case 选择值2: 语句主体2; break; ...... default: 语句主体; break;&#125; 4、循环结构 while 循环，当事先不知道循环该执行多少次时使用。先判断，后循环。1234while (循环条件判断) &#123; 语句n; 循环条件更改;&#125; do…while 循环，也是用于事先未知循环执行次数的时候。先循环，后判断。 无论循环条件是否成立，至少都会执行一次循环主体。1234do &#123; 语句n; 循环条件更改;&#125; while (循环条件判断); for 循环：采用两个分号「;」，分隔了三条语句的形式。12345678910111213141516171819/*** for 循环执行流程：* 1、执行初始化指令* 2、检查循环条件是否为 true，如果为 false，跳转到第 6 步* 3、循环条件为真，执行循环体* 4、执行循环条件更改* 5、循环条件更改执行完后，跳转到第 2 步，即继续检查循环条件* 6、for循环后面的语句*/for (初始化「必须是一个声明」; 循环条件判断; 循环条件更改) &#123; 语句n;&#125;-------------------------for 循环变体「不推荐」-------------------------int i = 0;for (; i &lt; 10 ;) &#123; i ++;&#125; 4、break 语句循环中遇到 break 语句，则直接退出整个 for 循环，并且 break 之后的语句也不再执行。 5、continue 语句continue 语句可以强迫程序跳到循环的起始处，当程序运行到 continue 语句时，即会停止运行剩余的循环主体，而是回到循环的开始出继续运行。即：使用 continue 就是中断一次循环的执行。 参考博客强大的循环]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常总结]]></title>
    <url>%2F2018%2F08%2F08%2FJava%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java 异常总结 什么是异常？异常是导致程序中断运行的一种指令流。一旦产生异常之后，异常之后的语句并不会执行，而是直接结束程序，并将错误报告给用户。 异常处理格式注意：捕获更粗的异常要放在捕获更细的异常之后，否则程序编译的时候将出错。 Java 异常类的继承结构 Exception：是程序可以自己处理的异常Error：表示 JVM 错误，一般程序无法处理 Java 的异常处理机制每当异常产生之后，会在程序中产生一个异常类的实例化对象，之后使用此对象与 catch 中的异常类型相匹配，如果匹配成功，则执行 catch 中的内容，如果匹配不成功，则向下继续匹配，如果都无法成功，程序中出现中断执行的问题。 throws 与 throw 关键字 throws 只能在定义方法的时候使用，表示该方法不处理异常，而交给调用处进行处理 格式：public 返回值类型 方法名称(参数列表...) throws 异常类1,...,异常类n {} 注意：对于使用 throws 抛出非 RuntimeException 类型的方法，调用方在调用该方法的时候必须进行异常处理，否则编译时报错。如果主方法中使用了 throws 关键字，则表示一切的异常交给 JVM 进行处理，默认的处理方式也是使用 JVM 完成的。调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类，否则编译时报错。 throw throw 关键字的作用是在程序中抛出一个异常。抛出的时候抛出的是一个异常类的实例化对象。throw 总是出现在函数体中，用来抛出一个 Throwable 类型的异常。程序会在 throw 语句后立即终止，它后面的语句执行不到，然后在包含它的所有 try 块中「可能在上层调用函数中」从里向外寻找含有与其匹配的 catch 子句的 try 块。 格式：throw 异常类实例化对象 注意：throw 后面只能跟一个异常类实例化对象 Exception 与 RuntimeException Exception Exception 在程序中是必须使用 try…catch 进行处理，否则编译时报错 RuntimeException RuntimeException 可以不使用 try…catch 进行处理，但是如果有异常产生，则异常将由 JVM 进行处理。 Java 异常注意事项 try 块 try 块后可接零个或多个 catch 块 try 块后至多有一个 finally 块 必须在 try 之后添加 catch 或 finally 块 try 块后可同时接 catch 和 finally 块，但至少有一个块 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后 可嵌套 try-catch-finally 结构 在 try-catch-finally 结构中，可重新抛出异常 一个 try 块可能有多个 catch 块，当匹配到某个 catch 块中的异常类型时，则不会再执行其它 catch 块，转为执行匹配到的 catch 块中的代码 finally 块 当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行 在以下4种特殊情况下，finally 块不会被执行： 1.在 finally 语句块中发生了异常「即抛出了一个未处理的异常」2.在前面的代码中用了 System.exit(int status); 退出程序3.程序所在的线程死亡4.关闭 CPU「主要指：计算机断电、失火、遭遇病毒攻击等使得 CPU 停止运行」 try、catch、finally语句块的执行顺序 1.当 try 没有捕获到异常时：try 语句块中的语句逐一被执行，程序将跳过 catch 语句块，执行 finally 语句块和其后的语句 2.当 try 捕获到异常，catch 语句块里没有处理此异常的情况：当 try 语句块里的某条语句出现异常时，而没有处理此异常的 catch 语句块时，此异常将会抛给 JVM 处理，finally 语句块里的语句还是会被执行，但 finally 语句块后的语句不会被执行 3.当 try 捕获到异常，catch 语句块里有处理此异常的情况：在 try 语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到 catch 语句块，并与 catch 语句块逐一匹配，找到与之对应的处理程序，其他的 catch 语句块将不会被执行，而 try 语句块中，出现异常之后的语句也不会被执行，catch 语句块执行完后，执行 finally 语句块里的语句，最后执行 finally 语句块后的语句 try、catch、finally语句块中有 return 后的执行顺序12345678910111213141516171819202122232425262728293031public class Test &#123; // 当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行 public int test() &#123; try&#123; System.out.println("001"); // 异常发生跳转到 catch 块中执行代码，其后的所有代码均不再执行 int temp = 10 / 0; return 1; &#125;catch (Exception e) &#123; System.out.println("002"); // 在 try 块或 catch 块中遇到 return 语句时，先不着急返回，看看有没有 finally 块，有的话先执行 finally 块，没有则直接返回 return 2; &#125;finally &#123; System.out.println("003"); // 在执行 finally 块的时候直接返回，结束了方法，前面的 try 块或 catch 块均不会再执行 return 3; &#125; &#125; public static void main(String[] args) &#123; int result = new Test().test(); System.out.println(result); &#125;&#125;-------------------------------------程序运行结果：-------------------------------------0010020033 参考博客Java 常见异常及解释深入理解 Java 异常处理机制]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门总结(一)]]></title>
    <url>%2F2018%2F08%2F06%2FDocker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Docker 入门总结(一) —— Docker 入门教程 什么是 Linux 容器？Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。由于容器是进程级别的，相比虚拟机有很多优势。 什么是 Docker？Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组。 Docker 是服务器—-客户端架构。即 C/S 架构。命令行运行docker命令的时候，需要本机有 Docker 服务。 Docker 常用命令 启动 docker 服务：sudo service docker start 或 sudo systemctl start docker 关闭 docker 服务：sudo service docker stop 或 sudo systemctl stop docker 获取 image 文件：docker image pull [image 文件所在的组/image 文件的名字] 列出本机所有的 image 文件：docker image ls 或 docker images 运行 image 文件：docker container run [image 文件的名字]，注意这里是 container 不是 image 删除 image 文件：docker image rm [imageName] 删除 container 文件：docker container rm [containerID] 创建 image 文件：docker image build -t [imageName]，-t 用来指定 image 文件的名字 生成容器：docker container run -p 8000:3000 -it [imageName] /bin/bash 为本地的 image 标注用户名和版本：docker image tag [imageName] [username]/[repository]:[tag]，打 tag 以后需要重新构建一下 image 文件 发布 image 文件：docker image push [username]/[repository]:[tag] image 文件Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。 Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。 实例将 image 文件从仓库抓取到本地 docker image pull library/hello-world。docker image pull 是抓取 image 文件的命令。library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此可以写成 docker image pull hello-world。 抓取成功以后，就可以在本机看到这个 image 文件了 docker image ls。 运行这个 image 文件 docker container run [imageName]。docker container run 命令会从 image 文件，生成一个正在运行的容器实例。注意，docker container run 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。 输出这段提示以后，hello world 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统 docker container run -it ubuntu bash。对于那些不会自动终止的容器，必须使用 docker container kill 命令手动终止 docker container kill [containerID]。 终止运行的容器文件，依然会占据硬盘空间，可以使用 docker container rm 命令删除 docker container rm [containerID]。删除以后可以通过 docker container ls -a 或 docker ps -a 就会发现被删除的容器文件已经消失了。 Dockerfile 文件学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 首先，在项目的根目录下，新建一个文本文件 .dockerignore，表示排除指定文件或文件夹，不要打包进入 image 文件。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。 12345FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是 8.4，即 8.4 版本的 node。COPY . /app：将当前目录下的所有文件（除了 .dockerignore 排除的路径），都拷贝进入 image 文件的 /app 目录。WORKDIR /app：指定接下来的工作路径为 /app。RUN npm install：在 /app 目录下，运行 npm install 命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 有了 Dockerfile 文件以后，就可以使用 docker image build 命令创建 image 文件了。docker image build -t koa-demo . 或者 docker image build -t koa-demo:0.0.1 .。-t 参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 docker container run 命令会从 image 文件生成容器。 12345678$ docker container run -p 8000:3000 -it koa-demo /bin/bash# 或者$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash-p 参数：容器的 3000 端口映射到本机的 8000 端口。-it 参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 这时，Koa 框架已经运行起来了。在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。可以使用 docker container run 命令的 –rm 参数，在容器终止运行后自动删除容器文件 docker container run --rm -p 8000:3000 -it koa-demo /bin/bash。 RUN 命令与 CMD 命令的区别在哪里？简单说，RUN 命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个 RUN 命令，但是只能有一个 CMD 命令。 注意，指定了 CMD 命令以后，docker container run 命令就不能附加命令了（比如前面的 /bin/bash），否则它会覆盖 CMD 命令。 推荐阅读Windows7 安装 Docker 参考博客如何进入、退出 docker 的 containerDocker 入门教程CentOS7 安装 Docker]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(一)]]></title>
    <url>%2F2018%2F08%2F04%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(一) 1、在一个 *.Java 文件中，「至多有一个」 public 声明的类，「注：这里的类特指：class、interface、@interface、enum」但是允许有 0 个或多个不带 public 声明的类。如果存在 public 声明的类，则文件名称必须与 public 声明的类名称一致。如果一个 *.Java 文件中有多个 class 定义，则编译之后会自动划分为多个 *.class 文件。 2、Java 中的标识符可以由任意的字母、数字、下划线、美元符号组成，但是不能以数字开头，不能是 Java 中的保留关键字。不能用作 Java 命名的词：关键词、保留关键词「goto、const」、具有特殊意义的单词「true、false、null」。 3、变量：将内存中的某个内存块保留下来以供程序使用，里面的内容是可变的。常量：一个数字就表示常量，常量内容是不会改变的「比如：数字 1 就是常量，能改变吗？不能啊！」。 4、Java 数据类型划分 5、Java 八大基本数据类型 6、数据的溢出当「整数」的数据大小超出了可以表示的范围，而程序中又没有做数值范围的检查时，这个整数变量所「输出」的值将发生紊乱，而不是预期的运行结果。「注意：这里的整数包括：byte、short、int、long 四种类型」。 对于其他基本数据类型：char 如果超出其取值范围则什么也不会输出。float 和 double 超出其取值范围，输出的值跟其取值范围的值一样，超出部分算精度丢失了。 7、Java 中字符占 2 个字节，取值范围 0~65535，计算机将字符当成整数来处理。 8、在 Java 中，boolean 类型的值只有 true 和 false，不存在用 0 或 1 表示的情况，也不存在和 0 或 1 转换的情况。 9、Java 中，整型和浮点型（float 或 double）做运算，其结果都是浮点型，因为 Java 的自动转型机制所定，首先它们都是数字，其次浮点型表示的范围比整型大，所以向浮点型自动转型。 10、浮点型向整型做强制类型转换，采取的是丢弃小数部分，只保留整数部分的机制。 11、Java 运算符 Java 中一「单」、二、三目运算符，这里的数字指参与运算的对象「即变量」的个数。 赋值运算符：「=」 一元运算符：「+、-、!」 算术运算符：「+、-、*、/、%」 关系运算符：「&gt;、&lt;、&gt;=、&lt;=、==、！=」 逻辑运算符：「&amp;、&amp;&amp;、|、||」 括号运算符：「()」 位运算符：「&amp;、|、^、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;」 自增与自减运算符：「++、–」 12、位运算符如果要想进行位操作，则需要先将十进制的数据变为二进制数据，除 2 的形式，即除基取余。 位运算操作： 如何将一个十进制数转变为计算机中存储的二进制数123456789101112131415161718192021public class Test &#123; // 如何将一个十进制数转变为计算机中存储的二进制数「以 『int b = -3;』 为例」 if (是否是整数) &#123; // 是整数 对整数的绝对值进行除 2 取余操作，求得其二进制数，即真值。「b 的值为 -3，-3 的绝对值是 3，3 的二进制数为 11」 判断整数的类型是哪个？从而决定它的位数 「b 的类型为 int，在内存中占 4 字节，即 32 位」 if (真值的位数是否小于等于变量类型的位数) &#123; if (是否是负数) &#123; // 是负数 「1 + 29 个 0 + 11（2 位） = 32 位」 最高位为 1，其他位补零，得到其原码，然后再进行反码-&gt;补码-&gt;得到该负数在计算机中二进制的存储格式 &#125;else &#123; // 是自然数，原码 = 反码 = 补码 「30 个 0 + 11（2 位） = 32 位」 高位补 0，求得其原码也即补码，得到该整数在计算机中二进制的存储格式 &#125; &#125; &#125;else &#123; // 不是整数，直接报错 &#125;&#125; 位操作注意事项：1.位操作只能用于整型数据，对 float 和 double 类型进行位操作会被编译器报错。「这里的整型数据指的是 long、int、char、short、byte」。 2.位操作符的运算优先级比较低，所以尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。 3.位操作还有一些复合操作符，如&amp;=、|=、 ^=、&lt;&lt;=、&gt;&gt;= 。 4.short、 byte、char 在移位之前首先将数据转换为 int，然后再移位，此时移位符号作用在 32 位 bit 上，并且右操作数只有低５位有效。 5.当左操作数是 long 时，移位之后得到的类型是 long，当左操作数是其它四中类型时，移位之后得到的类型是 int，所以如果做操作数是 byte,char,short 时，你用 &gt;&gt;=,&gt;&gt;&gt;=, &lt;&lt;= 其实是将得到的 int 做低位截取得到的数值。 13、原码、反码、补码 原码：就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。 反码：正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。 补码：正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1。「即在反码的基础上 +1」。 注意：负数在计算机中是以补码的形式存储的。 参考博客Java 中 boolean 类型占用多少个字节char，byte或者short进行移位处理Java 中 8 种基本数据类型Java 位操作全面总结Java 运算符的优先级Java运算符优先级原码,反码,补码详解Java 移位操作符]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解之元注解]]></title>
    <url>%2F2018%2F08%2F03%2FJava%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%85%83%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 注解之元注解 什么是元注解？元注解：所谓元注解就是标记其他注解的注解。 Java 中元注解的共同特点： @Target：都是 ElementType.ANNOTATION_TYPE 表明它们只能用于注释类型。@Retention：都是 RetentionPolicy.RUNTIME 表明它们都能保留到运行时。@Documented：标记了所有的元注解，表明所有元注解都应该被 javadoc 工具记录。 Java 中的四大元注解： @Retention：指定注释的保留时间节点@Target：指定注释的使用位置@Documented：被其标记的注释将会被 javadoc 工具记录@Inherited：被 @Inherited 标记的 Annotation，注释的类的子类会自动继承父类中的该 Annotation @Retention 元注解指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，则保留策略默认为 RetentionPolicy.CLASS。 @Retention 元注解定义：123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125; RetentionPolicy 用于指定 Annotation 的保存范围，RetentionPolicy 包含三种范围： @Retention 使用示例：1234567import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(value = RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "Hello";&#125; @Target 元注解指示注释类型所适用的程序元素的种类。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。一个 ElementType 常量在 Target 注释中只能出现一次，否则编译时报错。 @Target 元注解定义：123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; ElementType 可选保存范围： @Target 使用示例：12345678910import java.lang.annotation.Target;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "Hello";&#125; @Documented 元注解指示某一类型的注释将通过 javadoc 和类似的默认工具进行文档化。应使用此类型来注释这些类型的声明：其注释会影响由其客户端注释的元素的使用。如果类型声明是用 @Documented 来注释的，则其注释将成为注释元素的公共 API 的一部分。 Documented 注解表明这个注解应该被 javadoc 工具记录. 默认情况下，javadoc 是不包括注解的. 但如果声明注解时指定了 @Documented，则它会被 javadoc 之类的工具处理，所以注解类型信息也会被包括在生成的文档中。 @Documented 元注解定义：1234@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; @Documented 使用示例：123456789101112131415161718192021222324import java.lang.annotation.Documented;@Documentedpublic @interface WithDocumented &#123; String value() default "WithDocumented";&#125;---------------------------------------------public @interface WithoutDocumented &#123; String value() default "WithoutDocumented";&#125;----------------------------------------------public class DocumentedTest &#123; @WithDocumented(value = "with_documented") public void with_documented () &#123; System.out.println("with_documented"); &#125; @WithoutDocumented(value = "without_documented") public void without_documented() &#123; System.out.println("without_documented"); &#125;&#125;------------------------------------------------使用 javadoc 命令：javadoc -d doc DocumentedTest.java 输出 doc 文档 输出的 doc 文档示意图： @Inherited 元注解指示注释类型被自动继承。如果在注释类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注释类型，同时该类声明中没有此类型的注释，则将在该类的超类中自动查询该注释类型。此过程会重复进行，直到找到此类型的注释或到达了该类层次结构的顶层 (Object) 为止。如果没有超类具有该类型的注释，则查询将指示当前类没有这样的注释。[看了 n 多遍才理解，写的真特么精辟！] 它指明被注解的类会自动继承。 更具体地说，如果定义注解时使用了 @Inherited 标记，然后用定义的注解来标注一个父类, 父类又有一个子类(subclass)，则父类的所有拥有 @Inherited 标记的注解属性将被继承到它的子类中。 请注意，如果使用注释类型来注释除类之外的任何内容，则此元注释类型不起作用。 还要注意，这个元注释只会导致从超类继承注释；已实现的接口上的注释无效。 @Inherited 元注解定义：1234@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125; @Inherited 使用示例：123456789101112131415161718192021222324@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "Hello";&#125;-------------------------------------@MyAnnotationclass Person &#123;&#125;class Student extends Person &#123;&#125;-------------------------------------public class InheritedTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 注意此处：Student 子类上根本没有 @MyAnnotation，但实际打印的结果中却有，说明注解被自动继承了下来 Class&lt;?&gt; c = Class.forName("cn.yan.annotation.Student"); Annotation[] an = c.getAnnotations(); for (Annotation a : an) &#123; System.out.println(a); &#125; &#125;&#125;------------------------------------输出结果：@cn.yan.annotation.MyAnnotation(value=Hello) 参考博客Java 元注解import static 和 import 的区别]]></content>
  </entry>
  <entry>
    <title><![CDATA[泛型入门]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%B3%9B%E5%9E%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[泛型入门 认识泛型泛型「generic」是在 JDK1.5 之后增加的新功能。由外部指定类对象中具体的操作类型。泛型，即「参数化类型」，把变量类型、方法返回值类型、参数类型等的类型也当成一种参数进行传递。泛型只在编译阶段有效。 泛型作用泛型在编译时检查设置内容的类型与指定的泛型类型是否一致，不一致则在编译时报错，起到了更好的保护数据安全性的作用。 泛型示例1234567891011121314151617public class GenericTest&lt;K, V&gt; &#123; private K key; private V value; public GenericTest(K k, V v) &#123; this.key = k; this.value = v; &#125; public K genericTest1(K k) &#123; return k; &#125; public V genericTest2(V v) &#123; return v; &#125;&#125; 泛型的安全警告在泛型应用中，如果在声明类对象的时候没有指定好其内部的泛型数据类型，则编译时系统会给出 「unchecked」即未经检查或不安全的操作的警告。对于没有指定泛型类型的，其本质是由系统自动将其类型设置为 Object。 匹配任意类型的通配符「?」泛型操作中，在进行引用传递的时候泛型类型必须匹配才可以传递，否则是无法传递的。如果使用「?」意味着可以接收任意的泛型对象，但是其内容却无法直接使用 &lt;?&gt; 修饰的泛型对象进行修改。即使用 &lt;?&gt; 只能接收，不能修改。 受限泛型在受限泛型中，可以将 extends 看成是小于等于「=&lt;」，将 super 看成是大于等于「&gt;=」。 泛型与子类继承的限制一个类的子类可以通过对象多态性，为其父类实例化，但是在泛型操作中，子类的泛型类型是无法使用父类的泛型类型接受。例如：Test&lt;String&gt; 不能使用 Test&lt;Object&gt; 接收。 泛型接口实现的两种方式1234567891011121314151617181920// 泛型接口定义public interface Info&lt;T&gt; &#123; T getValue();&#125;-----------------------------// 实现泛型接口方式 1：在子类的定义上也声明泛型类型public class InfoImpl&lt;T&gt; implements Info&lt;T&gt; &#123; @Override public T getValue() &#123; return null; &#125;&#125;----------------------------// 实现泛型接口方式 2：如果实现接口的子类不想使用泛型声明，则在实现接口的时候直接指定好其具体的操作类型public class InfoImpl implements Info&lt;String&gt;&#123; @Override public String getValue() &#123; return null; &#125;&#125; 泛型方法注意：区别一个方式是不是泛型方法，就看其方法上有没有泛型声明，即 &lt;T&gt; 这样的标识符，表明这个方法是泛型方法，在方法上声明了方法中即将要使用的泛型类型。只要在方法中定义了泛型操作，则可以传递任意的数据类型。 泛型的嵌套12345678910111213141516171819public class Info&lt;K, V&gt; &#123; private K key; private V value;&#125;------------------------------public class Person&lt;S&gt; &#123; private S info; public Person(S info) &#123; this.info = info; &#125;&#125;------------------------------public class Test &#123; public static void main(String[] args) &#123; Info&lt;Integer, String&gt; info = new Info&lt;Integer, String&gt;(); Person&lt;Info&lt;Integer, String&gt;&gt; person = new Person&lt;Info&lt;Integer, String&gt;&gt;(info); &#125;&#125; 参考博客Java 泛型详解Effective Java 泛型]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 注解之自定义注解]]></title>
    <url>%2F2018%2F08%2F03%2FJava%E6%B3%A8%E8%A7%A3%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 注解之自定义注解 自定义 Annotation 格式123[public] @interface Annotation名称 &#123; 数据类型 方法名称();&#125; 自定义 Annotation 示例 示例 1：简单的 Annotation123456// 自定义 Annotation，可以直接在程序中使用「@Annotation 名称」的格式public @interface MyAnnotation &#123;&#125;// 使用自定义 Annotation@MyAnnotationpublic class Test &#123;&#125; 示例 2：接收 1 个参数的 Annotation123456789101112public @interface MyAnnotation &#123; // 向 Annotation 中设置内容，使用变量接受参数 // 接受设置的内容，注意这里 value 是「变量名」，不是「方法名」！ String value();&#125;// 使用时必须清楚的指明变量的内容// @MyAnnotation("Hello")// 或者使用明确的标记，表示内容赋值给哪个变量@MyAnnotation(value = "Hello")public class Test &#123;&#125; 示例 3：接收 2 个参数的 Annotation123456789public @interface MyAnnotation &#123; // 同时设置多个参数 String key(); String value();&#125;// 使用时必须明确的指明变量名，注意变量名 key、value 不能省略@MyAnnotation(key = "Hello", value = "World")public class Test &#123;&#125; 示例 4：变量类型为数组的 Annotation12345678910public @interface MyAnnotation &#123; // 设置变量类型为数组 String[] list();&#125;// 与 @SuppressWarning 类似，其传参有三种形式：// @MyAnnotation(value = &#123;"Hello", "World"&#125;) 或// @MyAnnotation(&#123;"Hello", "World"&#125;) 或@MyAnnotation("Hello")public class Test &#123;&#125; 示例 5：为 Annotation 中的变量设置默认值 12345678public @interface MyAnnotation &#123; String key() default "Hello"; String value() default "World";&#125;// 由于此 Annotation 设置了默认值，所以使用的时候可以不指定参数值@MyAnnotation()public class Test &#123;&#125; 示例 6：为 Annotation 固定其变量取值范围1234567891011public enum AnnotationEnum &#123; RED, GREEN, BLUE;&#125;public @interface MyAnnotation &#123; AnnotationEnum color() default AnnotationEnum.RED;&#125;// 注意：变量名除 「value」外，其他的都需要明确的指出来@MyAnnotationNonoParam(color = AnnotationEnum.GREEN)public class Test &#123;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 注解之入门]]></title>
    <url>%2F2018%2F08%2F02%2FJava%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java 注解之入门 Java 注解 AnnotationJava 注解 Annotation 是在 JDK1.5 时引入的新特性，这种特性被称为元数据特性，在 JDK1.5 之后称为「注释」，即：以注释的方式加入一些程序的信息「通过注释可以完成一些代码的其他功能」。一个注解就是一个类。 Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。 java.lang.annotation.Annotation 接口是所有的 Annotation 都必须实现的接口。 系统内建 Annotation在 JDK1.5 之后，系统中已经建立了三个内建的 Annotation 类型，用户直接使用即可。 @Override: 覆写的 Annotation，表示「方法」覆写的正确性。@Deprecated：不赞成使用的 Annotation，表示不建议使用的操作。@SuppressWarnings：压制安全警告的 Annotation。 No. Annotation Java 中的声明 1 @Override @Target(value=METHOD)@Retention(value=SOURCE)public @interface Override {} 2 @Deprecated @Documented@Retention(value=RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {} 3 @SuppressWarnings @Target(value={TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(value=SOURCE)public @interface SuppressWarnings {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String[] value();} @Override 示例1234567891011121314class Person &#123; public String getInfo() &#123; return "This is a Person."; &#125;&#125;class Student extends Person &#123; // 使用 @Override 保证方法能够被正确覆写 @Override // 此处可能存在某种失误，如：将方法名写错 public String getInfo() &#123; return "This is a Student."; &#125;&#125; @Deprecated 示例123456789101112131415public class Test &#123; public static void main(String[] args) &#123; Person person = new Person(); // 编译时系统会给出安全的警告信息 person.getInfo(); &#125;&#125;class Person &#123; // 声明不建议使用的操作 @Deprecated public String getInfo() &#123; return "This is a Person."; &#125;&#125; @SuppressWarnings 示例123456789101112131415161718192021222324252627public class Test &#123; // 压制「一个」警告信息 // @SuppressWarnings("unchecked") // 同时压制多个警告信息——以数组的形式出现 // @SuppressWarnings(&#123;"unchecked", "deprecation"&#125;) // 由于该注解使用变量名为 value，类型为 String[] 接收传参，使用时可以明确指出用哪个变量接收传参 @SuppressWarnings(value = &#123;"unchecked", "deprecation"&#125;) public static void main(String[] args) &#123; Demo demo = new Demo(); demo.setT("Hello"); &#125;&#125;@Deprecatedclass Demo&lt;T&gt; &#123; private T t; public T getT() &#123; return t; &#125; public void setT(T t) &#123; this.t = t; &#125;&#125; 反射与 Annotation一个 Annotation 如果要想让其变得有意义，则必须结合反射机制取得 Annotation 设置的全部内容。Annotation 在实际开发中，不管如何使用，其最终肯定是结合反射机制，即可以通过 Annotation 设置一些内容到元素上，以完成特定的功能。注意：能通过反射取得的 Annotation 其 Retention 必须是 RUNTIME 范围的。 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "Hello";&#125;-----------------------------------------------------------public class Bean &#123; // 注意：反射只能获取到 Rentention 是 RUNTIME 范围的 Annotation @SuppressWarnings("uncheck") @Deprecated @Override @MyAnnotation public String toString() &#123; return "Hello World"; &#125;&#125;-----------------------------------------------------------用法1：public class GetAnnotation &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class&lt;?&gt; c = Class.forName("cn.yan.annotation.Bean"); Method m = c.getMethod("toString"); Annotation[] a = m.getAnnotations(); for (Annotation annotation : a) &#123; System.out.println(annotation); &#125; &#125;&#125;--------------------------------------------------------------输出结果：@java.lang.Deprecated()@cn.yan.annotation.MyAnnotation(value=Hello)--------------------------------------------------------------用法2：public class GetAnnotation &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class&lt;?&gt; c = Class.forName("cn.yan.annotation.Bean"); Method m = c.getMethod("toString"); // 判断方法上是否存在指定的 Annotation if (m.isAnnotationPresent(MyAnnotation.class)) &#123; // 获取指定的 Annotation MyAnnotation my = m.getAnnotation(MyAnnotation.class); String value = my.value(); System.out.println(value); &#125; &#125;&#125;--------------------------------------------------------------输出结果：Hello 参考博客深入浅出 Java 注解深入理解 Java 注解类型]]></content>
  </entry>
  <entry>
    <title><![CDATA[必知的写作排版指南]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%BF%85%E7%9F%A5%E7%9A%84%E5%86%99%E4%BD%9C%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[必知的写作排版指南 1、空格汉字和英文、数字、符号之间都必须加一个空格。 中英文之间加空格 正例：我感觉自己 very 帅。反例：我感觉自己very帅。 汉字与数字之间加空格 正例：我永远都是 18 岁。反例：我永远都是18岁。 数字与单位之间加空格 正例：我有一只身高 120 cm 的猫。反例：我有一只身高 120cm 的猫。 全是英文的句子中，标点符号与单词之间需要加空格。 正例：Where there is a will, there is a way.反例：Where there is a will,there is a way. 全角标点与其他字符之间不加空格 正例：有志者，事竟成。反例：有志者， 事竟成。 中文与链接之间增加空格 正例：我觉得 知乎 这个网站很赞。反例：我觉得知乎这个网站很赞。 括号、引号前后加空格，中间内容无空格 示例 1：5.04 ounces (143 grams)示例 2：Did you say “I love that” ? 2、标点什么是全角、半角？全角、半角主要是针对标点符号来说的，全角占两个字节，半角占一个字节。中文标点符号是全角，英文标点符号是半角。即：中文标点符号的宽度是英文标点符号宽度的 2 倍。 中文 排版中所有的标点都应该使用 全角中文标点符号 正例：有志者，事竟成。反例：有志者,事竟成. 英文 排版中所有的标点都应该使用 半角英文标点符号 正例：Where there is a will, there is a way.反例：Where there is a will，there is a way。 使用直角引号 正例：这个是「直角引号」的效果。反例：这个是“普通引号” 的效果。 引号再使用引号使用直角双引号 正例：在「直角引号里使用『引号』的情况」。反例：在“普通引号里使用‘引号’的情况”。 不重复使用标点符号 正例：德国队竟然输给了韩国队！反例：德国队竟然输给了韩国队！！！ 注：各种输入法怎样快速打出「直角引号」符号 3、其他 英文名字首字母尽量大写 Facebook 专有名词使用正确的大小写 GitHub 首行不要缩进，改用「空出一行」代替首行缩进 空行代替缩进来区分自然段 参考博客中文文案排版指北写给大家看的中文排版指南每个人都需要的中文排版指南各种输入法怎样快速打出「」符号]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j 日志总结]]></title>
    <url>%2F2018%2F07%2F14%2FLog4j%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Log4j 日志总结 1.日志组件Loggers「记录器」：Logger 负责捕捉事件并将其发送给合适的 Appender。 Appenders「输出源」：也被称为 Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前， Appenders 使用 Layouts 来对事件进行格式化处理。 Layouts「布局」：也被称为 Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts 决定了数据在一条日志记录中的最终形式。 当 Logger 记录一个事件时，它将事件转发给适当的 Appender。然后 Appender 使用 Layout 来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。另外，Filters 可以让你进一步指定一个 Appender 是否可以应用在一条特定的日志记录上。在日志配置中，Filters 并不是必需的，但可以让你更灵活地控制日志消息的流动。 2.日志系统日志系统：日志的具体实现。Java 的常见的日志系统有 Log4j、jdk-jul「即：java.util.logging」、logback 等，这些日志系统各自独立，编程方式也不一致。如果你一个系统要用到多个「框架库」，而这些框架库又可能要用不同的「日志系统」，那么你一个系统中就得使用多套日志系统，那多套日志系统如何融合在一起是个很大的问题。 3.日志框架那么如何解决呢？进行抽象，抽象出一个接口层，对每个日志实现都适配或者转接，这样这些提供给别人的库都直接使用抽象层即可，不需要关注具体的日志实现。常见的日志抽象出来的框架有 Apache commons-logging 和 slf4j。抽象层可以让我们更加容易地改变项目现有的日志框架，或者集成那些使用了不同日志框架的项目。 4.日志故事这里有个故事：最新是开源社区提供了 commons-logging 抽象，被称为 JCL 日志框架「JCL，全称为”Jakarta Commons Logging”，也可称为”Apache Commons Logging”」，出色地完成了兼容主流的日志实现「log4j、JUL、simplelog」，基本一统江湖，就连顶顶大名的 spring 也是依赖了 JCL。 看起来事物确实是美好，但是美好的日子不长，接下来另一个优秀的日志框架 slf4j 的加入导致了更加混乱的场面。比较巧的是 slf4j 的作者(Ceki Gülcü)就是 log4j 的作者，他觉得 JCL 不够优秀，所以他要自己搞一套更优雅的出来，于是 slf4j 日志体系诞生了，并为 slf4j 实现了一个亲子 —— logback，确实更加优雅。 但是由于之前很多代码库已经使用 JCL，虽然出现 slf4j 和 JCL 之间的桥接转换，但是集成的时候问题依然多多，对很多新手来说确实会很懊恼，因为比单独的 log4j 时代“复杂”多了，可以关注下这个，抱怨声确实很多。到此本来应该完了，但是 Ceki Gülcü 觉得还是得回头拯救下自己的 “大阿哥” —— log4j，于是 log4j2 诞生了，同样 log4j2 也参与到了 slf4j 日志体系中。日志体系的江湖又将面临血雨腥风的混乱了。 5.Loggers 组件Loggers 组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度。12345FATAL 0 ERROR 3 WARN 4 INFO 6 DEBUG 7 Log4j 有一个规则：只输出级别不低于设定级别的日志信息，假设 Loggers 级别设定为INFO，则 INFO、WARN、ERROR 和 FATAL 级别的日志信息都会输出，而级别比 INFO 低的 DEBUG 则不会输出。 1234// 获取 Logger 对象import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Test.class); 6.Appenders 组件Appenders 为日志输出目的地，如控制台「Console」、文件「Files」等，还可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。Log4j 提供的 appenders 有以下几种：12345org.apache.log4j.ConsoleAppender「控制台」org.apache.log4j.FileAppender「文件」org.apache.log4j.DailyRollingFileAppender「每天产生一个日志文件」org.apache.log4j.RollingFileAppender「文件大小到达指定尺寸的时候产生一个新的文件」org.apache.log4j.WriterAppender「将日志信息以流格式发送到任意指定的地方」 配置模式：1234log4j.appender.appenderName = classNamelog4j.appender.appenderName.Option1 = value1......log4j.appender.appenderName.OptionN = valueN 7.Layouts 指定日志输出格式Layouts 指定日志输出格式。Layouts 提供四种日志输出样式：HTML样式、自由指定样式、包含日志级别与信息的样式、包含日志时间、线程、类别等信息的样式。 1234org.apache.log4j.HTMLLayout「以HTML表格形式布局」org.apache.log4j.PatternLayout「可以灵活地指定布局模式」org.apache.log4j.SimpleLayout「包含日志信息的级别和信息字符串」org.apache.log4j.TTCCLayout「包含日志产生的时间、线程、类别等等信息」 配置模式：1234log4j.appender.appenderName.layout = classNamelog4j.appender.appenderName.layout.Option1 = value1......log4j.appender.appenderName.layout.OptionN = valueN 8.配置详解在实际应用中，要使 Log4j 在系统中运行须事先设定配置文件。配置文件事实上也就是对 Logger、Appender 及 Layout 进行相应设定。Log4j 支持两种配置文件格式: 一种是 XML 格式的文件。 一种是 properties 属性文件。 下面以 properties 属性文件为例介绍 log4j.properties 的配置。 8.1 配置根记录器 Logger123log4j.rootLogger = [level], appenderName1, appenderName2, ...... # false：表示 Logger 不会在父 Logger 的 appender 里输出，默认为 true。log4j.additivity.org.apache = false; level：设定日志记录的最低级别，可设的值有 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL 或者自定义的级别，Log4j 建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO 级别，则应用程序中所有 DEBUG 级别的日志信息将不会被打印出来。 appendName：指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。1log4j.rootLogger＝INFO, A1, B2, C3 8.2 配置输出目的地 appender12# appenderName：自定义 appderName，在 log4j.rootLogger 设置中使用。log4j.appender.appenderName = className className 可以设如下值：12345678910111213141516171819202122232425262728293031# ConsoleAppender 选项# Threshold = WARN：指定日志信息的最低输出级别，默认为 DEBUG。# ImmediateFlush = true：表示所有消息都会被立即输出，设为 false 则不输出，默认值是 true。# Target = System.err：默认值是 System.out。org.apache.log4j.ConsoleAppender「控制台」# FileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false：true 表示消息增加到指定文件中，false 则将消息覆盖指定的文件内容，默认值是 true。# File = D:/logs/logging.log4j：指定消息输出到 D:/logs/logging.log4j 文件中。也可以使用相对路径。org.apache.log4j.FileAppender「文件」# DailyRollingFileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false「同上」# File = D:/logs/logging.log4j「同上」# encoding = UTF-8 指定输出内容所采用的字符集# DatePattern = '.'yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。org.apache.log4j.DailyRollingFileAppender「每天产生一个日志文件」# RollingFileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false「同上」# File = D:/logs/logging.log4j「同上」# MaxFileSize = 100KB：后缀可以是 KB, MB 或者 GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到 logging.log4j.1 文件中。org.apache.log4j.RollingFileAppender「文件大小到达指定尺寸的时候产生一个新的文件」org.apache.log4j.WriterAppender「将日志信息以流格式发送到任意指定的地方」 注意：配置消息输出路径的时候，可以使用相对路径，这里的相对路径的参照点为服务器的目录。如：log4j.appender.file.File = ../logs/info.log 该日志系统运行在 Tomcat 服务器上，所以其对应的绝对地址为：服务器 Tomcat 的绝对路径 + ../logs/info.log。 8.3 配置输出格式 Layout1log4j.appender.appenderName.layout = className className 可以设如下值： 12345678910# LocationInfo = true：输出 java 文件名称和行号，默认值是 false。# Title = My Logging： 默认值是 Log4J Log Messages。org.apache.log4j.HTMLLayout「以HTML表格形式布局」# ConversionPattern = %m%n：设定以怎样的格式显示消息。org.apache.log4j.PatternLayout「可以灵活地指定布局模式」org.apache.log4j.SimpleLayout「包含日志信息的级别和信息字符串」org.apache.log4j.TTCCLayout「包含日志产生的时间、线程、类别等等信息」 参考博客Java Log 日志log4j 详细介绍日志系统和日志框架Log4j.properties 配置详解-简书log4j.properties 配置详解-CSDN为什么 logger 要声明为 static final]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的戒烟之旅]]></title>
    <url>%2F2018%2F04%2F02%2F%E6%88%91%E7%9A%84%E6%88%92%E7%83%9F%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[我的抽烟史本人男，24 岁，从 18 岁开始抽烟，到开始戒烟时大约有 5 年的烟龄。学会抽烟的条件无非就那么几种：身边的人都抽，带着你也抽了；为了装逼、装酷；再加上一些失恋啊、压力大啊、熬夜提神啊等等各种莫须有的理由，基本就把很大一部分人牢牢的栓死在吸烟的泥潭里，越陷越深，越来越无法自拔，等你想跳出来的时候，发现你的烟瘾已经大到超越你的理智和毅力的地步，想要摆脱已经很难很难了。基本上掉入这个陷阱的人，很少有能跳出来的，直至被烟折磨到死。我是属于第一种情况，身边的人都抽，跟着也抽了。 其实学习抽烟是一件很痛苦的事情，因为要克服生理上的难受，身体本能的抵抗，还要坚持去抽大约一包才能熬过痛苦的开始，没有一点毅力的人，是学不会的。学会抽烟的人当时是有点毅力了，但当时绝对是没有脑子的，事实证明没脑子真可怕，因为一旦方向错了，越多的努力就越是后退的厉害。回首我的吸烟史，从我开始自己买第一包烟的时候，我就已经陷入进去了，只是那时候不知道，等知道的时候已经晚了，烟瘾已经超越了理智。吸烟的过程中真的被很多人嫌弃过，被舍友、被朋友、被自己、被家人、被路人，我也很难过，但只有吸烟的人才能懂烟瘾来的时候不抽烟的痛苦，不是生理上的更多的是心理上的。「脑补一下非常非常口渴的时候，脑子里肯定会不顾一切的找水喝，就是那种渴望的感觉，也算是吸烟者的一种刚需，所以烟草可以卖那么贵」 随着烟龄的增长，烟瘾会越来越大，吸烟的量也会越来越多。我由一天几根发展到了一天一包甚至更多，到后来明显感觉自己抽烟抽的非常的下贱。晚上要是烟盒里面只有一根烟的时候，心里就会缺失安全感，担心不够抽，担心烟瘾来了怎么办，半夜没烟的时候去翻烟灰缸，找半截的去抽；出去游玩的时候，每隔几小时就想找个地方抽烟，然而很多景点不让随便抽烟；坐火车或者高铁的时候，中间停车几分钟，都要冲下去抽几口；平时工作学习生活，每隔一段时间就要去抽根烟；很多人会躲到厕所里抽烟；真的吸烟者被到处赶，为了吸烟，忍受着别人的歧视、厌恶，忍受着厕所的恶臭，别人的谩骂。现在回想真的觉得那时候的自己为了抽烟变得好可怜、好下贱、好可恨。现在看到还在吸烟的人，重复我以前生活的人，我都会抱以同情的目光，一群被烟奴役的人，我想帮，但又无能为力。 尝试戒烟吸烟有害健康，吸烟不仅浪费钱还伤身体等等各种大道理，吸烟者比非吸烟者应该更清楚，然而这些也就是说说，并没有什么卵用，完全的鸡汤道理。我相信每个吸烟者心里都有想戒烟的的渴望，只是烟瘾大于了理智，虽然有时候会理智一下，但最后都败在烟瘾的阵前。我也尝试过戒烟好多次，感冒严重喉咙疼的要死的时候想过这是个机会通过生理抵抗帮助自己戒烟，最后失败了；看到好多因抽烟得肺癌的新闻，想要戒烟，最后失败了；被自己在乎的人鼓励去戒烟，最后失败了；我曾经做过过很多努力去戒烟，去控烟，然而都没用。真正的戒烟是不需要准备的，是不需要挑时机的。戒烟唯一需要的是你自己能够从心底里明白一些道理，比如：你为什么要吸烟，你为什么又要戒烟难，为什么你以前每次戒烟都会失败，吸烟到底有什么好让你放不下等等一些看似简单，但是你从来没有真正搞明白答案的问题。戒烟的时候各种挑日子，挑时机的人大多都会以失败告终，因为你从心底里没有准备好戒烟，你从一开始就是在逃避的，你根本没有认识到你为什么要戒烟，你是为了戒烟而戒烟，你是为了别人所谓的吸烟有害健康的大道理而戒烟。而不是为你自己戒烟。 戒烟成功 一本书：《这本书能让你永久戒烟》 一个突入其来的下午： 2017.12.18 13：30 一个戒烟 APP： 戒烟军团 首先，如果想戒烟，真的好好看看《这本书能让你永久戒烟》，对戒烟有很大的帮助，能够解决你戒烟路上的很多困惑，用经得起逻辑推理的文字去武装你的思想，让你在戒烟路上能够不被干扰。让你站到高处，站到非吸烟者的角度去思考、去审视在吸烟泥潭中的自己。 其次你需要清晰的意识到自己在坑里，你才会挣扎，你才会往出爬，温水煮青蛙的故事大家都知道，殊不知吸烟者就是温水里的青蛙。如果把毒品比作开水，抽烟比作温水，很多人会全力抵抗毒品，却沦陷在吸烟的泥潭里深深不能自拔，让自己活活的被煮死。更可恶的是最后即使知道了自己最后会被活活煮死，也懒得往出跳了，因为当前是舒服的，尽然还找各种理由去为自己的无能和没有从烟瘾手中抢回理智的毅力去开脱。 戒烟路上肯定会有各种阻力，特别是来自于以前身边的烟友的递烟行为，对于这种情况，大声的告诉他我不会，千万不要说你在戒烟。戒烟是不需要准备的，它开始于你掐灭手中烟的那一刻，我以前每次戒烟前都要准备，最后准备了 3 年，失败了 3 年，其实每次都没有准备好，当你真正准备好的时候，就是你突然明悟吸烟的危害的那一瞬间，其实你已经完成了戒烟，以后只是拿时间去证明一下而已。 戒烟过程中你可能遇到生活工作压力大，跟朋友喝酒开心，情感生活不顺利，多年不见老友劝烟等等各种被拿来当复吸借口的理由，我看着这些理由感觉很可笑，完全是在给自己吸烟找理由。请记住生活中的各种喜怒哀乐不会因为你吸了多少烟而改变任何一丝一毫，不管你吸多少烟，它还是原来的样子，遇到问题请勇敢面对，而不是逃避。 总结当你真正的从心底里明白吸烟的害处。能站到高处看到深陷吸烟泥潭的自己，满身污泥侧身躺在那里，不仅浑然不知，还笑着往自己身上抹发臭的污泥。看着自己被控制着，被奴役着，迫使原本自由的自己每隔一段时间就要按照烟的指令去做事，你的生活、工作、学习都被它无时无刻干涉着，你竟然不愤怒，竟然还任由它在你的生活中自由的破坏，破坏你美好的旅途、好不容易集中的注意力等等。而且这其中你明明是一个受害者，但你却偏偏还要为此付出金钱的代价，即使你穷的快连饭都吃不饱了，但它还要去强迫你去为此付费。最后它还要让你付出生命的代价。 它就是抽烟，它是那么的无理蛮横，随意践踏着你，欺负你。它的唯一目标就是搞臭你的人，搞砸你的生活，最后搞死你。我是人，凭什么让它这么欺负，我不想再被这么控制着，我可怜这样的自己，我对它这样欺负我自己感到愤怒，我要反抗，戒烟是你唯一的选择，可以将它直接拍死，还你自由。 作为一个吸烟者，我渴望的无烟生活，是别人唾手可得的，已经被烟控制的我要经过很大的努力才能让自己自由。我会更加珍惜无烟的自由生活，也从心底里感觉我不会再上瘾，因为从心底里已经对烟产生了抵抗，它带给我的深深的伤痛将会一直警醒我。吸烟是一个坑，我不小心掉进去了，虽然受了很多苦难，但最终我从里面爬了出来，虽然伤痕累累，但不致命，这段经历将是我人生的一笔财富。 感谢最后，感谢一路上包容我的人。感谢那些曾经帮助我、劝说我戒烟的人，谢谢你们!]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人对写博客的一些认识]]></title>
    <url>%2F2018%2F03%2F21%2F%E4%B8%AA%E4%BA%BA%E5%AF%B9%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[个人对写博客的一些认识 博客要写吗？随着网络的发展，这两年自媒体很火，我个人关注的一些微信公众号，知识星球等里面的作者基本都提出了要写个人博客的观点。写个人博客的好处有很多，比如锻炼自己的写作能力，培养自己的第二技能，万一你要是火了还可以靠广告赚钱，可以利用写博客加深自己对某个知识或者观点的认知等等。个人实践了一段时间，认为写博客确实有不少好处，能立马看到的好处就是，把自己对某个知识点或者观点写成博客，自己对这些的认识确实会加深很多，而且博客其实还是一个很好的知识归档工具。在学习一个东西的时候，特别是做软件开发的，过段时间不用，基本忘得就跟没学过似的，所以用博客把自己当时的思考结果等记录下来，而且是用自己的语言，特别符合自己的思维习惯，以后在回顾的时候能达到超级好的效果。当然你用心思考的东西发布出去，总能遇到跟你共鸣的人，然后获得关注等，这也是一个写博客的福利吧，想着以后粉丝多了，我就出名啦，也就想想而已哈。 总结：1、写博客能帮助你梳理知识，加深对知识的认识和理解。2、写博客能记录你当时的思考过程，抵抗遗忘，方便自己以后随时查阅。3、写博客可能会让你出名，带来经济收入。 我为什么要写博客？做软件开发的知识更新很快，需要不断的去学习，如此大量的知识，如果不善于总结回顾很容易会忘记。特别是那种平时基本用不到，但偶尔还能用到那么几次的知识点，比如工具破解，开发环境搭建，这种基本很少用到，但每次用到的时候都是一通查找，你要是在自己完成这些工作以后，抽一点时间写下来，那么会节省自己大量的的时间。对！这就是我当前认为写博客的最大原因！而且总结让我加深了对知识的影响，写下来为我以后再做重复的事情节省了大量的重新回顾的时间。其实我们学习的过程就像是拿着手电筒在黑夜里寻宝，手电筒只能照亮一小块区域，当你在看到宝的时候要记得记录下来，别看到了，没带走，等用的时候还得再往回找。 个人认为写博客的一些误区1、在学习一个新东西的时候不要一边学，一边写，很容易变成抄而不是写。我刚开始在学习一个新的知识点的时候，会一边学，一边写博客，但是由于学的是我以前不知道的，所以感觉啥都有必要记录下来，结果就变成了抄别人的博客，抄别人的观点，由于你把所有的东西都记录下来了，感觉就是自己的了，而脑子有了这个想法以后就不会去深入的思考了。人在学习的时候为了记忆会把新知识跟已经学到的知识进行关联然后记忆，这种抄博客的方式变成了打包拷贝，过眼睛，不怎么过脑子了。所以在学习一个新知识的时候，不要一边学，一边写博客，否则就给了本来就有惰性的大脑思考以偷懒的机会。 总结：在学习一个新东西的时候去写博客，一边写一边学，不仅浪费大量的时间，而且基本都是抄的，逃不出作者的写作范围，而且由于拖得时间太长还容易半途而废。实际是你应该看好多相关博客，然后自己会了，懂了，觉得自己明白了，然后用自己的话写出来，这才是真正的博客。你可以写的跟别人的一样，因为真理逻辑就一个，但是输出的方式是从自己的思考中，而不是套用别人的文字。 2、不是所有的知识都有必要写成博客的，不要重复造轮子。我刚开始写博客有一个误区，就是啥都想记录下来，因为总怕自己遗忘，结果导致你会在一个很小的没要必要深究的知识点上花费大量的时间去记录，而且这个知识点别人已经写出来过。博客是要记录那些自己不会的而且自己还为此进行过深入思考的，花费大量时间去探索最后得出让自己满意答案的事，而且重点要记录自己的当时的思考，用自己的话将自己的观点写下来。写的是自己的观点，或者是在别人的观点上有了自己的思考，更或者是你对很多类似观点进行学习以后对其进行归纳总结，让其更全面系统准确。如果你的思考和认识超不出作者的范围，建议还是转载一下完事，没必要花时间造重复的轮子。 3、对待博客的态度需要转变过来，我写博客是为了自己，不是为了获得别人的关注评论。对待博客的态度：我写博客主要不是为了服务于他人，而是怕自己忘记，是自己对抗记忆遗忘曲线的手段。当然同时也服务于他人，给自己带来额外的鼓励等等，但是一定要明白自己写博客是为了服务于自己，不要把自己当成作家，浪费大量的时间在文字的推敲上，只要自己能看懂了就行，否则时间周期过长，容易半途而废。 4、 写短小而精悍的博客，更容易让别人读下去，让自己坚持写下去。我有过这样的体验，刚开始在学 Java 的时候，我是通过看视频学习的，但是视频有长有短，对于那种 30 分钟以上的视频我心里就有抵触感，比如觉得这个视频比较长，我要提前准备进入状态啥的，而且看的过程中还很容易被打断。而对于一些 10 分钟左右的视频我却很容易看下去，也很乐意看下去，而且中间也不容易被打断，其实最终的成果是一样的，但是给人的感受是不同的，这个是人大脑的正常行为，有兴趣的可以去研究一下。这个东西就启发我在写博客的时候要把大的一篇博客拆分成多个小的，写的时候容易坚持下去，看的人也容易看下去，好好利用人类大脑的这个特性。我刚开始就写一大篇，几千字，要阅读 20 多分钟，自己写着头大，看着头大。而对于一些小的短博客，不仅有动力写下去，而且还思考的更深，写的更认真仔细，因为少嘛，所以会精心去雕琢。 总结：博客内容最好短小而精辟，最好不要太长篇大论，如果非得这样的写成一个系列的文章，不要一片文章里面写上所有的内容，写博客最重要的是坚持输出，所以一开始一定要避免很多让自己坚持不下去的外在问题，如果长篇大论的文章，你会一次性写很多，容易导致放弃，最后导致失败，所以少量输出，然后及时获取少量反馈，这样更容易让自己坚持。 5、 在初期的时候写博客的时间成本是很高的。其实在初期要想写好一篇博客是需要大量的时间的，由于对排版，布局，插图，文字表达等各种问题的不熟悉，所以很多东西你是需要推敲而且边学边用的，所以初期写博客的时间成本是很高的。因为有了较高的时间成本，所以我们就要对花大量时间要去写的博客进行精挑细选，这里有几个我认为的挑选规则：在你看来比较有深度的知识，你曾花费大量的时间去思考最终自己真的弄懂了；一些工作生活学习时常要用到的，但又比较容易忘记的；接受了别人的知识输入以后，在自己的大脑里经过消化发酵有了自己的思考和观点，忍不住的想输出分享的内容。 6、 质量 VS 数量。以前看别人说，刚开始写博客，一定要先动起来，即使是抄别人的，也是一种进步。确实对于刚开始来说真的看着不断增长的博客数量有那么些成就感，感觉这些都是自己的成果，当我回头去看那些内容的时候，发现除了抄就是写的很「垃圾」，当然这也证明你成长了。我不否人这个方法确实有效。但是这个方法在初期好使，我们的观点一定是要转变过来的，即质量优先，因为你在注重质量的同时，也是你在成长的时候，从量变一定要转到质变上。集中全部精力，狠打一个点，将一个篇博经过精雕细琢然后输出，这种感觉只有你这么做了，才会有。 全文总结端正态度、认真选主题、自己思考的产物、短小而精悍的输出、尽量不要写没有思考的「垃圾」。]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 代码块]]></title>
    <url>%2F2018%2F03%2F15%2FHexoNext%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Hexo Next 代码块 1、编辑主题配置文件 _config.yml「注意是主题配置文件」此处用来设置代码块的背景色。1highlight_theme: night eighties 2、编辑站点配置文件_config.yml「注意亲测会报错」：在网上 Google 的答案中要求将 auto_detect 设置为 true，但是我设置以后使用 hexo generate 生成静态代码的时候会报错 TypeError: Cannot set property ‘lastIndex’ of undefined 所以最后还是乖乖设置成了 false ，对实际效果也没有任何影响，对于该配置需谨慎使用。 「注意是站点配置文件」auto_detect 主要用来支持代码自动检测。12345highlight: enable: true line_number: true auto_detect: false tab_replace: 3、编辑 Markdown 文章注意：「```」之后需要指定你代码块中所使用的开发语言，也可以不指定，即让系统自动识别你代码块中的开发语言是哪个，系统可能会识别失败或错误，所以最好还是指定。注意：符号「```」,是 Esc 下面那个，不是单引号「’’’」。 效果图：]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 搜索功能]]></title>
    <url>%2F2018%2F03%2F14%2FHexoNext%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[它侧身于生活的污泥中，虽不甘心，却又畏首畏尾 Hexo Next 添加搜索功能过程，本博客采用「Local Search」！ 对主题版本的要求要使用搜索功能对你的主题版本可能有最低要求，我采用的是 Next 主题，最近更新的，为防止后面出现各种莫名其妙的问题，建议最好把主题版本更新一下。 添加搜索功能安装 hexo-generator-searchdb ，在站点的根目录下执行以下命令：1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能：12local_search: enable: true 重新生成静态文本hexo clean -&gt; hexo generate -&gt; hexo server -&gt; 查看效果 -&gt; 收工 参考博客Hexo 博客添加搜索功能]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法笔记]]></title>
    <url>%2F2018%2F02%2F02%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Markdown 语法笔记 1.标题方式一：使用两个或两个以上 = 或 - 标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 方式二：使用 #，表示 1-6 级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 2.段落段落的前后要有空行。在段内强制换行的方式是使用两个或两个以上空格加上回车「注：引用中换行省略回车」。 3.区块引用在段落的每行或者只在第一行使用符号 &gt;，还可使用多个嵌套引用。 > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.代码区块Hexo Next 代码块 5.强调在强调内容两侧分别加上 * 或者 _。 *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 6.列表使用 *、+、- 标记无序列表。注意：标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行。 * 第一项- 第三项+ 第二项 效果： 第一项 第三项 第二项 有序列表的标记方式是将上述的符号换成数字，并辅以「.」。 1. 第一项2. 第二项3. 第三项 效果： 第一项 第二项 第三项 7.分割线分割线最常使用就是三个或以上「*」，还可以使用「-」或 「_」。 ***---___ 效果： 8.链接链接可以由两种形式生成：行内式和参考式。 行内式 [行内式展示内容](https://github.com/ “行内式鼠标悬浮展示内容”) 效果： 行内式展示内容 参考式 [参考式展示内容 1][1][参考式展示内容 2][2][1]:https://github.com/ “参考式鼠标悬浮展示内容 1”[2]:https://github.com/ “参考式鼠标悬浮展示内容 2” 效果： 参考式展示内容 1参考式展示内容 2 9.图片添加图片的形式和链接相似，只需在链接的基础上前方加一个「！」,也分为行内式和参考式。 ![图片的替代文字](/upload_image/1.jpg “图片标题”) 效果： 10.反斜杠「\」相当于反转义作用。使符号成为普通符号。即显示符号本身。 11.符号「`」起到标记作用。即加个阴影背景。 `ctrl + a` 效果： ctrl + a 12.尖括号在 Markdown 中「尖括号」会被默认为 HTML 语句，这将导致尖括号本身及尖括号中的内容都不会被显示。所以就必须得使用转义字符才能够表示出「尖括号」。使用 &amp;lt; 代替 &lt;，使用 &amp;gt; 代替 &gt;。 &amp;lt;&amp;lt;西游记&amp;gt;&amp;gt; 效果： &lt;&lt;西游记&gt;&gt; 13.键盘键 &lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt; 效果： Ctrl+[ and Ctrl+] 14.删除线 ~~删除线~~ 效果： 删除线 15.反引号一个反引号需要引用代码时，如果引用的语句只有一段，不分行，可以用「反引号」将代码包起来，它们会解释成 &lt;code&gt;标签。 两个反引号如果代码的「内容中」有反引号，请用两个反引号包裹，与前后两个反引号之间加空格。代码中的&amp;、&lt;、&gt;符号都会自动转义。 三个反引号如果引用的语句为多行，可以将三个反引号```置于这段代码的首行和末行。 16.其它「表格」列表的使用(非traditonal markdown)用 | 表示表格纵向边界，表头和表内容用 - 隔开，并可用 : 进行对齐设置，两边都有 : 则表示居中，若不加 : 则默认左对齐。 一个普通标题 一个普通标题 一个普通标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 总结Markdown 只是帮助我们排版的工具，重要的还是内容，它是一篇文章的灵魂。好看的皮囊千篇一律，有趣的灵魂万里挑一。Markdown 就是赋予你灵魂一个好看的皮囊，但如果你没有有趣的灵魂，其他的全是扯淡。所以 Markdown 看一遍就行了，大致了解，然后动手写，不会的去查然后调整一下就好了，适应一段时间你就完全脱离了。使用 Markdown 的最高境界永远都是：笔下是语法，心中格式化。你达到了吗？ 参考博客Markdown 基本语法Markdown 入门参考Markdown 语法精讲Markdown 语法介绍]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML 类图]]></title>
    <url>%2F2018%2F02%2F02%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML 类图 类的图示（Class） 类图分三层 类的名称，如果是抽象类就用斜体显示。 类的特性，通常是字段和属性。 类的操作，通常是方法或行为。 Java 四种访问权限在类图中的表示访问范围由大到小为：public、protected、default（即什么都不写）、private；‘+’表示 public，‘#’表示 protected，‘-’表示 private，什么都不写就表示 default 了。 分析图 1-1 Person 类图第一行：类的名称为：Person；如果为抽象类，则“Person”采用斜体。第二行：类的属性为：name ；“:”冒号前面表示属性的名字，后面表示属性的类型，还可以给属性赋初值。第三行：类的方法：“&lt;&lt;Getter&gt;&gt;”或“&lt;&lt;Setter&gt;&gt;”表示方法的注释，可有可无，只是起到一个标记作用而已；冒号前面是方法的名字，注意方法的名字后面都是要带括号的“()”;冒号后面是方法的返回值。 1234567891011121314151617181920public class Person &#123; private String name = "zhangsan"; private int age = 23; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 接口的图示（interface）接口的 UML 图有两种表示方法：1、名称上面 &lt;&lt;interface&gt;&gt; 用这个标识它是一个接口2、「棒棒糖」表示法，圆圈旁边为接口名称，接口方法在实现类中出现 UML 关系图 继承关系「即泛化关系」 继承关系用空心三角形 + 实线来表示注意指向：子类指向父类（即空心三角形在父类这边）助解：因为父类可以有多个子类，所以就会聚集成一个三角形，而子类则是一个线头的点 123456789// 父类public class Person &#123; private String name;&#125;// 子类 继承了 父类public class Student extends Person&#123; private String StudentNumber;&#125; 实现接口 实现接口用空心三角形 + 虚线来表示注意指向：子类指向接口（即空心三角形在接口这边）助解：因为接口可以有多个实现，所以也会聚集成一个三角形，而子类则是一个线头的点 1234567891011121314// 接口public interface Say &#123; String say();&#125;// 实现接口public class Person implements Say&#123; private String name; @Override public String say() &#123; return "person say ..."; &#125;&#125; 关联关系关联关系表示一类对象与另一类对象之间有联系，通常将一个类的对象作为另一个类的成员变量来表示关联关系 关联关系用实线箭头表示注意指向：箭头由引用类指向被引用类，表示引用类 要引用 被引用类的东西助解：比如企鹅需要知道气候，而企鹅和气候是两个类，那么现在企鹅类中用到了气候类，所以企鹅依赖气候因为企鹅需要知道气候的变化，即当一个类需要知道另一个类时，可以用关联关系关联关系有：单向关联、双向关联、自身关联、多重性关联 123456789// 气候类public class Weather &#123;&#125;// 企鹅类public class Penguin &#123; // 企鹅需要知道气候，所以这里引用了气候类，表示企鹅这个类引用了气候类,即一个类中有另一个类的引用 private Weather weather;&#125; 依赖关系依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。 依赖关系用虚线箭头表示注意指向：箭头由依赖方指向被被依赖方，表示依赖方 依赖于 被依赖方提供的东西助解：动物生存依赖氧气、水，注意这里是动物的生存依赖氧气、水，不是动物本身依赖，动物要是挂了就不需要了 12345678910111213// 汽车类public class Car &#123; public void move() &#123; System.out.println("move"); &#125;&#125;// Driver 类的方法使用了 Car 类对象作为方法的参数，即要想开车，必须先有车public class Driver &#123; public void drive(Car car) &#123; car.move(); &#125;&#125; 关联关系 vs 依赖关系依赖关系：是一种 使用关系。一个类 A 使用到了另一个类 B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是 B 类的变化会影响到 A。例如：客户使用产品需要提供者，产品的变更会影响客户的使用，但一个客户需要的产品可以有多个提供者。即一个类可能同时依赖多个类。 关联关系：是一种 结构关系。它指明一个事物的对象与另一个事物的对象之间的联系。关联关系比依赖关系更强，不存在依赖关系的偶然性，关系也不是临时性的，而一般是长期性的。例如：商品和订单，订单中包含商品信息。 小结： 依赖关系是一种 使用关系，即类 A 在做某个动作的时候依赖到了其他对象类 B。 关联关系是一种 结构关系，即类 A 中存在类 B，指明了类 A 对象和 类 B 对象之间的联系。 聚合关系聚合是一种弱的「拥有」关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分 聚合关系用空心的菱形 + 实线箭头表示注意指向：空心的菱形放在聚合的群体那边，箭头指向群体中的每个个体助解：大雁和雁群，因为大雁聚合形成雁群，则空心菱形表示聚合形成堆了，而箭头表示单个点 123456789// 大雁public class Goose &#123;&#125;// 雁群public class GooseGroup &#123; // 雁群类中有大雁的集合 private Goose[] gooseList;&#125; 合成关系「即组合关系」合成是一种强的「拥有」关系，提现了严格的部分和整体的关系，部分和整体的生命周期一样 合成关系用实心的菱形 + 实线箭头表示注意指向：实心的菱形放在合成的整体那边，箭头指向部分，即用来合成整体的部件助解：鸟和翅膀，部分和整体且生命周期一致 12345678910111213// 翅膀public class Wing &#123;&#125;// 鸟类public class Bird &#123; private Wing wing; // 生成鸟类的同时生成翅膀 public Bird() &#123; this.wing = new Wing(); &#125;&#125; 参考列表：《大话设计模式》[深入浅出UML类图]http://www.uml.org.cn/oobject/201211231.asp[UML基础系列：类图]http://www.cnblogs.com/lsgxeva/p/7720224.html 感觉不错：[Java类与类之间的5种关系及uml表示]https://blog.csdn.net/pj36536/article/details/53101764[UML类图与类的关系详解]https://blog.csdn.net/sinat_30397435/article/details/79018467]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客搭建总结]]></title>
    <url>%2F2018%2F02%2F02%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo 博客搭建总结 近期终于下定决定自己搭建一个博客出来了。利用 Hexo+Github+Next， 前后历时差不多一周左右的时间吧，终于把大致框架搭建出来了，剩下的就是小的修修补补了。由于我对前端处于白痴阶段，所以很小的问题都能把我困住，基本上是踩着别人的肩膀一步步走过来的，在此分享下一个白痴搭建的过程，希望你能绕开我走过的坑，少一些为寻找某一个问题而苦苦搜寻的过程，最后祝大家都能顺利搭建成功。如果遇到其他问题留言吧，我乐意帮忙。 下面是我博客搭建过程中踩过的各位大牛的肩膀，希望对你有帮助，在此也真心的感谢他们，不管好坏对错，最后都帮到我了，在我因为一个问题苦苦挣扎寻找的时候，他们的博客或者论坛出现了，帮助我顺利走向下一步，再次谢谢他们。下面是我对他们博客论坛的一些个人过滤，每个里面都有其精华所在，供大家参考。 1、官方文档这个没得说，最最最重要的是它由简体中文版！注意右上角可以切换语言的哦。把它当成一个手册吧，全而细，但我没那个耐心读一遍，索引就跟字典的作用似的。官方文档。 2、博客框架搭建下面这两篇是关于 Hexo 从零开始到搭建完整，比较系统，但细节处理不是特别完美，适合动手搭建整体框架的时候参考，都写的大而详细，里面可能有小瑕疵，注意拉到最后面看评论区，说不定你遇到的坑别人已经踩出来了，还有结合官方文档，综合多方面信息，博主要是在命令里面少打一个空格，对于什么都不懂的你可能执行不下去了，然后就可能放弃掉了。真的很可惜，我们好不容易下次决定还就这么夭折了，那可都是生命啊，请为它们的流逝赋予意义。Hexo 从零开始到搭建完整，Hexo 搭建博客教程。 3、Next 主题搭建是当前比较好用，且被使用次数最高的主题，如果你采用的是这个主题，那么下面这个内容真的是大而全的帮你设置各种小功能，强烈推荐。Next 主题搭建。 4、这个是 Next 主题官网的一个配置参考，有些东西看官方的肯定是好的，大全而且还细，但时我没有那个耐心，所以宁愿 Google 答案，也不愿意去看一大堆的文档。主题配置参考。 5、Next 主题修缮这个对我帮助挺大的，相见恨晚啊，基本上把我踩过的坑都覆盖到了，讲的很详细，重点读一下，对于白痴的我来说，写的很好，前提是你的博客框架搭建好修缮的过程中用。Next 主题修缮。 6、添加分类及标签 7、这个是关于主题的，这个问题困扰了我好久，为什么别人的主页跟我的就是不一样的呢，而且 Next 默认的那个主题比较丑，众里寻他千百度，就是这篇博客帮我解决了这个问题，其实 Next 支持三种主题，默认的只是其中一种。Hexo 应用 NexT 主题。 8、Hexo博客添加评论、打赏、RSS 等功能 9、为文章添加热度 10、不蒜子统计无法显示的原因 11、博客主页显示文字阅读次数 总结：还有些我在搭建过程中参考的博客给搞丢了，不过应该都比较好找，比如添加评论区，打赏，是由统计访问点击量啥的，都可以留言问我。尽管我没有了原来的链接，但是我知道怎么去搜索，这个很关键，在搭建博客过程中，我遇到那些问题，都不到输入什么关键词去查询答案，真的很悲催，我就这么悲催过来了，不希望你们再走我悲催的老路。关键是这些弯路走的没必要。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人迷茫时刻]]></title>
    <url>%2F2018%2F02%2F02%2F%E4%B8%AA%E4%BA%BA%E8%BF%B7%E8%8C%AB%E6%97%B6%E5%88%BB%2F</url>
    <content type="text"><![CDATA[年轻人闲聊扯淡 我对于工具和框架的态度一直都是用到了查一下就好了嘛，框架和工具那么多，要是每个都系统的去学习一下那岂不累死，核心的东西要放在设计上。但是每次遇到了每次查，用的多了发现查的次数也越来多了，最后对工具和框架的认识就像漏勺，看起来会，实际上存满了漏洞，有想过系统的去学习一下，但是发现去学习这些工具和框架枯燥无味，很难坚持下去，总是虎头蛇尾，最后碰到点困难就放弃了。怎么说呢，其实还是对这些工具和框架的需求不够，没有很渴望的去接受这些东西。想象一下你很渴很渴的时候，对水的那种渴望（为此我还特意不喝水体验了一把）真的没什么能阻止你，更直接一点就是对空气的渴望，当你能抱这样的心态去学习我想你会效率很高很快。追过小说的读者应该和我有同样的一种体验，看小说就入迷了，吃饭看，走路看，坐公车看，以前坐公车上班特别怕堵车，但是迷上小说以后特别盼堵车，回家了躺那里就是看，真的跟疯了一样。我一直在想，为什么我学习技术达不到像追小说那样的状态呢，我是有潜力的，只是我所学习的东西不够吸引我罢了。但是没有追求就创造追求，在自己认为对的路上给自己造就渴望，至于怎么做，我还在探索。我相信我会成功的，但是前面的路是要一个坑一个坑的趟，会有迷茫无助，谁都帮不了你，只有自己，探索的路真的很痛苦，我知道胜利就在远方。 最要命的是胜利不仅仅只是努力和坚持就好了，想想也是，如果胜利真的只有努力和坚持这么简单，那岂不是太简单了。比努力和坚持更重要的是方向，想象一下你坐车坐成了反方向就知道有多可怕了。只有在对的方向上做对的努力和坚持才能让你成长，方向选错了，还会妨碍你的成长，其实在当今互联网时代，真的是信息洪流中，不进则退，别说选错方向了，你就是站在那不动都一直在倒退，因为大家都在埋头前进。那么什么是对的方向呢，这个只能自己去判断了，真的不能盲目的去努力，我有过一段这样的经历，到最后越来越迷茫，差距越来越大，那段时间我就停下来，什么都不干，每天看书，冥想。问自己你的目标是什么？你苦苦坚持努力，你最后想要怎样的结果？这个问题其实挺深奥的，我有想过是钱，其实并不是，每天有那么多赚钱的机会，但我并没有特别渴望去赚钱。真正的目标是那些，你心里很渴望，每天都想着努力去完成，每一天都有进步，每天都离自己的目标更近了，对于这样的一群有自己明确目标的人，明确知道要干什么去接近自己的目标，每天都看着自己离目标更进一步，他们真的很可怕，我觉得世上没有什么是难得到他们的，即使没有任何人去支持他们，我也相信他们会一往无前的走下去，成功时候的光芒万丈，耀瞎世俗的眼。 我是一个世俗的人，支持我走下去的东西有太多太多世俗，有时候是别人的一句赞赏，有时候是为了获得别人的关注，为了满足自己活着别人的虚荣心而且活着，做着自己不愿意但是强迫自己去做的事。我内心超级脆弱的，怕孤独，怕孤立，怕被世俗抛弃，怕这怕那，畏首畏尾，想想真觉得可笑。至今我都不直达我真正追求的目标是什么，唯一让我感觉到有点轻松快乐的就是写东西，把很多自己所思所想写出来，有种酣畅淋漓的感觉，会去为了更准确的表达自己内心所想而去推敲每一个字，改过来改过去，会调整格式到自己认为完美的状态会因为一个标点符号或者没有对齐而难受调整半天，而且一点也不绝得累。完事还特别有成就感，我有时候会关注有多少人看，说不在意是假的，但是真的没有那么在意，你看或者不看，我都会坚持写下去，我的读者从来只有我自己，茫茫人海，全是过客，所有的所有都是我人生不同体验的一个风景。 我们每天都会面临各种各样的选择，有选对的有选错的，但是有的人选择是经历思考的，知道自己为什么这么选，有自己明确的目的和思考，他每天的选择都会有意思的去跟自己的目标挂钩，为了自己离自己的目标更近一步，就是人家用脑子了，跟自己的主要目标稍微有些偏差他们能感觉出来，并及时做出调整，而我只会在错的路走不下去的时候才发现自己迷路了，所以我要给自己定目标，一个很明确的目标，指向我心底渴望的未来，我不会立刻给出很明确的目标，但我必须有目标，在跟随自己目标前进的过程中不断调整。 目标如下 最大的目标：提升自己的专业技能，然后找好工作，然后赚更多的钱，给自己更多的自由。1.近期坚持完成一个 SSM + Dubbo + Redis + MQ 的练手项目，做出来就好，不论过程。2.坚持每天写至少一篇博客，梳理自己每天的所思所想，帮助自己更好的调整方向。3.遇到困难了坚持下去，再难再硬也要啃下来，啃的过程就是自己进步最快的时候。]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
</search>
