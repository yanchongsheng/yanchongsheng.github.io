<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux入门总结(三)]]></title>
    <url>%2F2018%2F09%2F12%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(三) —— Linux 网络]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(二)]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[求实英语(二) —— 主谓宾 1、他整天没地方去也没事儿干。He goes nowhere and has nothing to do every day. 2、她天天在哪儿吃午饭？Where does she have lunch every day? 3、你怎么不常和他们一块儿来？Why don’t you often come with them? 4、王芳有姐姐吗？Does WangFang have any sisters? 5、为什么他总听你的而不听我的？我不知道。Why does he always listen to you but doesn’t listen to me? I don’t know. 6、他了解你多少？你非常了解他吗？How much does he know you? Do you know him very well? 7、你们每周怎么去那儿?How do you get there every week? 8、李梅不知道那事儿，但我知道。LiMei doesn’t know that but me. 9、每天下班后，Tod 都载我回家。Tod picks me up home after work every day. 10、这些小狗都叫什么？它的名字是 TianTian,那只叫 LeLe。What are these dogs’ names? Its name is TianTian, that is called LeLe. 11、他准时上学并及时做作业。He goes to school on time and does his homework in time. 12、没人相信他，因为他经常撒谎。他太丢人了。Nobody believes him because he often tell lies. He is very shameful. 13、你妈把我的手表放什么里边了？what does your mother put my watch in? 14、我像他，但却不喜欢他。I am like hime, but I don’t like him. 15、你这么辛苦工作是为了什么？what do you work hard for? 注意事项on time 准时in time 及时]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门总结(四)]]></title>
    <url>%2F2018%2F09%2F11%2FDocker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Docker 入门总结(四) 1、Docker 包括三个基本概念：镜像（Image）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器（Container）：容器的实质是进程。镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 仓库（Repository）：一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 2、$ docker run -it --rm ubuntu:16.04 bash-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。 3、$ docker system df通过以上命令来便捷的查看镜像、容器、数据卷所占用的空间。 4、docker image ls 选项：默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。-q 只列出镜像的 ID。 5、Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 Dockerfile 指令1、FROM 指定基础镜像，一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 2、RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。 3、COPY 复制文件 COPY &lt;源路径&gt;… &lt;目标路径&gt;COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”] 4、ADD 更高级的复制文件ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。这个功能其实并不实用，而且不推荐使用。 5、CMD 容器启动命令 shell 格式：CMD &lt;命令&gt;exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 6、ENTRYPOINT 入口点ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。 7、ENV 设置环境变量 ENV ENV = =… 8、VOLUME 定义匿名卷 VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]VOLUME &lt;路径&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[求实英语(一)]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[求实英语(一) —— 主系表 1、我姐姐在那儿吗？她和谁在一起呢？ 我的：Is my sister at there? whom is my sister with?答案：Is my sister there? whom is she with? 解析：there 在这里是名词，表示哪个地方的意思，所以不用 at。问句中用她来指代我姐姐。 2、我妈妈没在家，她和街坊出去了。 我的：My mother is not at home, she is with neighborhood out.答案：My mother is not at home, she is out with some neighbors. 解析：out 在 这里是形容词，表示外面的。 3、那本书怎么样？它在你的手里吗？ 我的：How is that book? Is it in your hand?答案： 4、这是给我的，那些是给谁的？ 我的：This is for me, whom are those for?答案： 5、Sam Sterm 根本就没在这儿，他每天在二楼办公。 我的：Sam Sterm is not here at all, he is at second floor everday.答案：Sam Sterm is not here at all, he is at work on the 2nd floor ever day. 解析：在工作用 at work 表示，在二楼用 at 2nd floor 表示，everday 是形容词每天的，而不是每天，这个是副词。 6、他是干什么的？他不是经理吗？ 我的：What is he? Is not he a manager?答案： 7、你的小狗在哪儿？它在什么里边？ 我的：Where is your dog? What is it in?答案： 8、这是谁的办公室？里边有人吗？哪间办公室是你的？ 我的：Whom is this office? Who is in the office? Which is your office?答案：Whose office is this? Is anyone in? Which office is yours? 9、我的电话出了毛病，手机在哪儿？ 我的：My phone is wrong, where is cell phone?答案：Something is wrong with my telephone,where is the cellphone? 10、电视开着呢，把它关上吧！ 我的：The TV is on, turn it off!答案： 11、我的备份没在你的电脑里吗？ 我的：Is not my copy in your computer?答案： 12、这是干什么用的？ 我的：What is this for?答案： 13、我的手机昨天就在这儿放着呢! 我的：My cellphone was right here yesterday!答案： 14、这个书包是谁的？那是谁的书包？我的在这儿！她的呢？ 我的：Whose bag is this? Whose bag is that? My bag is here! Where is her bag?答案：Whose is this bag? Whose bag is that? Mine is here! where is hers? 15、这本字典不像我的，但那本像。 我的：This dictionary is not like mine,bug that is like.答案：This dictionary is not like mine,bug that one is. 注意事项1、注意区分以下两种形式：Whose is this bag？这个包是谁的？ This bag is whose.Whose bag is this？这是谁的包？ This is whose bag. 2、区分 我、你、他 这些代词的各种形式： 主格 宾格 属格 属格(名词性) I me my mine you your your yours he him his his she her her hers it its its its they them their theirs 参考博客英语代词有哪些？]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java入门总结(四)]]></title>
    <url>%2F2018%2F09%2F10%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(三)]]></title>
    <url>%2F2018%2F09%2F10%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(三) —— NIO Buffer1、在 Java 中，已有的 IO 操作大部分都属于阻塞的操作。为了提升服务器操作的性能，在 JDK1.4 之后增加了 NIO，在整个 NIO 的操作中，基本上都是使用缓冲区完成的。 2、public abstract class Bufferextends Object 抽象类 Buffer 是一个用于特定基本类型数据的容器。 3、缓冲区是特定基本类型元素的线性有限序列。除内容外，缓冲区的基本属性还包括容量、限制和位置： 缓冲区的 容量(capacity) 是它所包含的元素的数量。缓冲区的容量不能为负并且不能更改。缓冲区的 限制(limit) 是第一个不应该读取或写入的元素的索引。缓冲区的限制不能为负，并且不能大于其容量。缓冲区的 位置(position) 是下一个要读取或写入的元素的索引。缓冲区的位置不能为负，并且不能大于其限制。 对于每个非 boolean 基本类型，此类都有一个子类与之对应。 4、标记、位置、限制和容量值遵守以下不变式： 0 &lt;= 标记 &lt;= 位置 &lt;= 限制 &lt;= 容量 。 5、清除、反转和重绕 clear() 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为容量大小，将位置设置为 0。flip() 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为当前位置，然后将位置设置为 0。rewind() 使缓冲区为重新读取已包含的数据做好准备：它使限制保持不变，将位置设置为 0。 6、直接 与 非直接缓冲区字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。 直接字节缓冲区可以通过调用此类的 allocateDirect 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 直接字节缓冲区还可以通过 mapping 将文件区域直接映射到内存中来创建。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。 Channel1、在 NIO 中，通道是一个可以用来读取和写入数据的一种形式。Channel 接口，用于 I/O 操作的连接。通道表示到实体的开放连接。 通道表示到实体，如硬件设备、文件、网络套接字或可以执行一个或多个不同 I/O 操作（如读取或写入）的程序组件的开放的连接。通道都是通过操作缓冲区来完成全部功能的。所有的内容都是先读或写到缓冲区之中，再通过缓冲区读或写入到通道中的，即程序不会直接操作通道。 2、Java NIO Channel 通道和流非常相似，主要有以下几点区别： 通道可以读也可以写，流一般来说是单向的（只能读或者写）。通道可以异步读写。通道总是基于缓冲区Buffer来读写。 3、什么是内存映射？将文件中的某个区域直接映射到内存中；对于较大的文件，这通常比调用普通的 read 或 write 方法更为高效。 在通道中还有一种方式成为内存映射。内存映射是速度最快的，MapperedByteBuffer，使用此种方式读取的内容是最快的，需要将一个输入的操作流绑定在内存映射上。 内存映射在读取的时候是最快的，但是如果执行的是写入操作则有可能是非常危险的，因为仅仅只是改变数组中的单个元素这样简单的操作就可能直接修改磁盘上的文件，因为修改数据与将数据保存在磁盘上是一样的。 文件锁在 Java NIO 中提供了文件锁的功能，这样当一个线程将文件锁定之后，其他线程是无法操作此文件的，要想进行文件的锁定操作，则要使用 FileLock 类完成，此类的对象需要依靠 FileChannel 进行实例化操作。 锁定方式： 共享锁：允许多个线程进行文件的读取操作。独占锁：只允许一个线程进行文件的读/写操作。 Selector推荐阅读Java NIO 浅析Java NIO Channel 通道]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(二)]]></title>
    <url>%2F2018%2F09%2F06%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(二) —— Linux 系统安装 磁盘分区磁盘分区又叫系统分区，是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。从字面意思来讲，磁盘分区指的就是把大的硬盘按照我的需求划分成几个分区，不同类目录与文件可以存储进不同的分区。 分区类型 主分区：最多只能有 4 个。 扩展分区「是从主分区的 4 个分区之中拿出 1 个分区作为扩展分区」： 扩展分区最多只能有 1 个（注意：针对一块硬盘来讲，一个硬盘最多只能有一个扩展分区）。 主分区加扩展分区最多只能有 4 个。 扩展分区本身不能写入数据也不能格式化，唯一的作用就是用来包含逻辑分区。 逻辑分区「即扩展分区中的逻辑分区」：可以正确的写入数据和格式化。按照硬盘的限制，一块硬盘最多只能分 4 个分区，即 4 个主分区。这种限制不是 Linux 系统的限制而是硬盘本身的限制，只要硬盘结构不发生变化，这种限制会一直存在。 格式化硬盘正确分区以后还不能写入数据，硬盘还必须经过格式化以后才可以写入数据。 格式化 (高级格式化) 又称逻辑格式化，它是指根据用户选定的文件系统（如 fat16、fat32、NTFS、ext2、ext3、ext4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。 在 windows 中可以识别的文件系统有 fat16、fat32、NTFS，在 linux 中可以识别的文件系统有 ext2、ext3、ext4，centOS 默认使用的是 ext4。 硬盘的格式化最主要的目的就是为了在硬盘当中写入文件系统，写入文件系统最主要的工作就是按照文件系统的规则把硬盘分成等大小的数据块，然后建立 iNode 表，我们把表里的编号称为 i 节点号又名 iNode 号。 当在查找文件的时候，是通过 iNode 表找到 i 节点号来找到这个文件的条款，从而知道这个文件保存在哪几个数据块之中，从而找到这几个数据块拿出文件，拼凑成我们的文件。这个格子就叫做数据块，又名 block。 在 centos 当中，默认的文件系统是 ext4，它在进入格式化的时候，它需要把硬盘划分为一个又一个等大小的数据块，这个数据块默认的标准大小为 4kb。假如有一个数据是 10kb，需要占用 3 个格子，最后一个格子只放了 2kb 数据，剩余的 2kb 空闲空间是不能再被其它文件所占用的，这 3 个格子不一定在一块。windows 中有一个磁盘碎皮整理，它的原理就是将保存的同一个文件的格子尽量放到一起，这样更有利于数据的读取。 硬件设备文件名如果是 windows，在进行了分区、格式化之后，给分区分配盘符然后就可以直接使用了。但是 Linux 不行，Linux 在进行了分区、格式化，格式化完成之后，要想给分区分配盘符之前，还必须给每一个分区起一个设备文件名，或者说给每一个分区起一个硬件设备文件名。 在 Linux 中所有的硬件设备都是文件。 「/」表示 Linux 中的最高一级目录，也就是根目录。在根目录下有一个 dev 的一级子目录，在 dev 目录中放入的所有的文件都是硬件文件。我们将硬件文件名，称为硬件的设备文件名。 为什么 Linux 需要「硬件设备文件名」而 windows 不需要？在 windows 中，硬盘分区、格式化之后，然后可以直接分配盘符是因为我们可以在 windows 的图形界面中直接看到这个硬盘在哪（注意：一台机器可能有多个硬盘），所以可以直接分配盘符（windows 有完善的图形界面）。但是 Linux 最早出现的时候，是没有图形界面的，为了让系统知道我要给哪一个硬盘分配盘符，所以被迫需要给每一个硬盘或者硬件设备指定设备文件名。 硬件设备文件名是固定的，系统自动检测的，我们能看懂就行。 关于硬盘，我们现在主要使用的是 SATA 硬盘接口，IDE、SCSI 硬盘接口基本被淘汰了。 分区设备文件名硬盘有了「硬件设备文件名」，还要给分区也要分配文件名，这就是「分区设备文件名」。「分区设备文件名」是在硬盘「硬件设备文件名」之后，直接加分区号就可以了。即硬盘有设备文件名，分区也应该有设备文件名，区别是一个是硬件设备文件名，一个是分区设备文件名。 分区设备文件名：分区文件名是在硬盘文件名之后直接加分区号，1 表示这个硬盘当中的第一个分区，依次类推。注意分区号有主分区号和逻辑分区号。 逻辑分区是从 5 开始的，1234 只能给主分区或者扩展分区使用，即使一个硬盘中没有分够 4 个主分区，逻辑分区也不能占用 1234 这 4 个分区号，即不管如何分区 5 都表示逻辑分区的第一个分区。 挂载windows 中分配盘符的操作在 Linux 中叫做挂载，我们把给分区分配盘符的过程称为挂载，我们把盘符叫做挂载点。在 Linux 中是使用空的目录名称作为盘符，而不是使用 CDEF 作为盘符，理论上任何一个目录都可以作为盘符，实际上有些目录是不可以的。 对于 Linux 来讲有两个必须分区：根分区、swap 分区（交换分区，大小一般为内存的 2 倍，一般不超过 2GB）。这两个是必须分区，如果不分区，则 Linux 不能安装，只要有这两个分区，Linux 就可以正常使用。还有一个推荐分区，/boot（启动分区，大小一般为 200M)。 根分区用于存放剩余数据，swap 分区可以理解为虚拟内存，即当我真正的内存不够用的时候可以拿交换分区的硬盘空间来当内存来用，理论上讲 swap分 区应该是内存的两倍，但是最大不超过 2GB，因为虚拟内存到底不是真正的内存，如果给它给的再大，它也不能取代内存，当它达到 2GB 的时候，如果再给大，只会占用我们更多的硬盘空间，但是对我们的系统不会产生更多的影响，所以最大不超过 2GB。 Boot 分区是专门用来保存启动时候的数据，任何操作系统启动的时候都需要一些硬盘空间，如果不给 boot 分区，万一根分区写满了，系统可能就启动不了了，为了解决这个问题，一般都会给 boot 单独分区。Boot 分区 200MB 足够，不用太大，写完之后不再往 boot 分区写入任何数据，它永远都会有一定的空余空间，就算把根分区写满了，也不会影响 Linux 启动。 Linux 文件系统结构 从 Linux 系统上看，boot、home 都是根分区的子目录。但是从硬盘上来看，它们每一个目录都可以有自己独立的硬盘空间，即每一个目录都可以有自己独立的分区，而每个分区又对应某块硬盘空间，所以每个目录都可以有自己独立的硬盘空间。 挂载点就是分区的盘符，swap 分区即交换分区没有盘符，swap 分区不是给用户用的，是由 Linux 操作系统或者内核直接调用的，所以它根本不需要盘符，有了盘符反而不正确了。swap 对系统性能的影响极小，所以分的空间不用太大。 总结 分区：把大硬盘分为小的逻辑分区；格式化：格式化的目的是为了写入文件系统，当然在写入文件系统的时候会附带的把硬盘当中的数据清空；分区设备文件名：给每个分区定义设备文件名；挂载：给每个分区分配挂载点，这个挂载点必须是目录，而且必须是空的目录才可以进行挂载点分配。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(一)]]></title>
    <url>%2F2018%2F09%2F06%2FLinux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(一) —— Linux 系统简介 Unix 发展史Unix 与 Linux 的关系就像是父子关系，Unix 是父亲，Linux 是儿子。肯.汤普森在 1969 年开发出了 Unix 系统。1971 年，肯.汤普森的同事丹尼斯.里奇发明了 C 语言，随后 Unix 系统绝大部分源代码用 C 语言重写，为提高 Unix 系统的可移植性打下基础。 Unix 主要发行版本 Linux 发展史Linux 系统诞生于 1991 年，由芬兰大学生李纳斯(Linux Torvalds) 和后来陆续加入的爱好者共同完成。Unix 和 Linux 的内核都是用 c 语言写的。Linux 是开源软件。 Linux 发行版和 Linux 内核的区别？内核版是 Linux 官方发布的，仅仅是单纯的内核。在拿到内核以后，每个产商可以加入自己的桌面、应用程序等再进行开发，称为发行版。Linux 内核官网：www.kernel.org。 Linux 主要发行版本Linux 主要分为两个系列：redhat 系列和 debian 系列。其本质是一样的，因为两者采用系统的内核。最主要的区别就是软件安装的方式不一样。Redhat 系列主要分为 HEL 和 federo 两个系列，其中 federo 是个人版，HEL 是企业版。对于 Linux 的企业版和个人版跟 windows 是不一样的，对于 windows 而言 windows7 是个人版，windows2008 是企业版，它们的区别是 windows7 可以看成是 windows2008 的一个阉割版，windows2008 才是完整的。但是 Linux 不同，个人版和企业版的区别在于，个人版是开发版，可能有的功能没有进行过测试，更像是一个实验体，而企业版是稳定版。 开源软件的特点 使用的自由：绝大多数开源软件免费（注意的是开源和免费并不是等同的，开源软件也可以出售，但是卖给你的是源代码，并不是编译之后的代码给你）。 研究自由：可以获得软件源代码（开放源代码带来的好处——安全，足够多的眼睛可以发现更多的问题，可以容易的看到大神级人物的代码风格和注释）。 散步及改良自由：可以自由传播、改良甚至销售。 Linux 的应用领域 基于 Linux 的企业服务器：企业服务器。 嵌入式应用：Android 平台就是一个典型的 Linux 嵌入式应用、智能家电如机顶盒、游戏机、数码相机等。 电影娱乐业：用于电影、图片的后期处理。 Linux 为什么选择命令行？Linux 选用命令行界面主要是考虑到系统的稳定性和安全性，如果装了图形界面，对系统资源的占用是比较庞大的，所以比较不好用。而 windows 考虑的是易用性，windows 系统主要考虑的是系统的易用性。 拓展1、www.netcraft.com 是一个典型的扫描和踩点网站。只要输入你要查询的网站，就可以获取网站后台服务器所采用的操作系统。该网站是一个全球著名的信息统计网站。从攻击的角度叫踩点，从防御的角度叫扫描。 2、www.top500.org 会统计全球范围内运算能力排在前 500 的服务器或者叫群组。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门总结(三)]]></title>
    <url>%2F2018%2F09%2F04%2FDocker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Docker 入门总结(三) —— Nginx 容器教程 1、CentOS7 修改 Nginx 默认 web 目录后 403 ？我这边的原因是：SElinux 没关导致的，直接使用命令 setenforce 0 关闭 SELinux 以后就正常了。具体原因查看：Docker nginx SELinux。 2、CentOS7 修改 Nginx 默认 web 目录后 403 ？docker container run -d -p 8000:80 --rm --name mynginx -v &quot;$PWD/html&quot;:/usr/share/nginx/html nginxdocker container run -d -p 8000:80 --rm --name mynginx -v &quot;$pwd/html&quot;:/usr/share/nginx/html nginx注意：对 PWD 大小写敏感，深坑啊！！！否则会报 403 的错误。 参考博客Nginx 容器教程Nginx 报 403 forbidden 错误]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门总结(二)]]></title>
    <url>%2F2018%2F09%2F04%2FDocker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Docker 入门总结(二) —— Docker 微服务教程 1、站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器……Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。 2、如何在一台计算机上实现多个服务，让它们互相配合，组合出一个应用程序？ 3、Docker 容器中是否可以再包含 Docker 容器，这样层层嵌套？ 推荐阅读Docker 教程 参考博客Docker 微服务教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 入门总结]]></title>
    <url>%2F2018%2F08%2F30%2FRabbitMQ%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[RabbitMQ 入门总结 安装关于 RabbitMQ 的安装参考：windows7 RabbitMQ 的安装。 RabbitMQ 角色1.超级管理员 (administrator)可登陆管理控制台(启用 management plugin 的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 2.监控者 (monitoring)可登陆管理控制台(启用 management plugin 的情况下)，同时可以查看 rabbitmq 节点的相关信息(进程数，内存使用情况，磁盘使用情况等) 3.策略制定者 (policymaker)可登陆管理控制台(启用 management plugin 的情况下), 同时可以对 policy 进行管理。 4.普通管理者 (management)仅可登陆管理控制台(启用 management plugin 的情况下)，无法看到节点信息，也无法对策略进行管理。 5.其他的无法登陆管理控制台，通常就是普通的生产者和消费者。 RabbitMQ 常用命令插件管理：1234567开启某个插件： rabbitmq-plugins enable &#123;插件名&#125;关闭某个插件： rabbitmq-plugins disable &#123;插件名&#125;插件名可以在 rabbitmq 的安装目录下的 plugins 目录中查看举例：开启后台管理插件：rabbitmq-plugins enable rabbitmq_management列出可用插件：rabbitmq-plugins list 用户管理：12345678910添加用户：rabbitmqctl add_user &#123;username&#125; &#123;password&#125;删除用户：rabbitmqctl delete_user &#123;username&#125;修改密码：rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;设置用户角色：rabbitmqctl set_user_tags &#123;username&#125; &#123;tag&#125;tag 可以为 administrator、monitoring、management举例：添加用户：rabbitmqctl add_user root root设置用户角色：rabbitmqctl set_user_tags root administrator列出所有用户：rabbitmqctl list_users RabbitMQ 概述RabbitMQ 是消息代理。它接受来自生产者的信息，并将它们传递给消费者。在两者之间，它可以根据你给它的路由，缓冲规则进行传递消息。 RabbitMQ 术语1.生产者(Producer) 2.消费者(Consumer) 3.队列(Queue) 工作队列（即任务队列）的主要思想是不用一直等待资源密集型的任务处理完成，这就像一个生产线，将半成品放到生产线中，然后在生产线后面安排多个工人同时对半成品进行处理，这样比一个生产线对应一个工人的吞吐量大几个数量级。 为了确保消息或者任务不会丢失，RabbitMQ 支持消息确认 ACK。ACK 机制是消费者端从 RabbitMQ 收到消息并处理完成后，反馈给 RabbitMQ，RabbitMQ 收到反馈后才将此消息从队列中删除。如果一个消费者在处理消息时挂掉（网络不稳定、服务器异常、网站故障等原因导致频道、连接关闭或者 TCP 连接丢失等），那么他就不会有 ACK 反馈，RabbitMQ 会认为这个消息没有正常消费，会将此消息重新放入队列中。如果有其他消费者同时在线，RabbitMQ 会立即将这个消息推送给这个在线的消费者。这种机制保证了在消费者服务器故障的时候，能不丢失任何消息和任务。 如果 RabbitMQ 向消费者发送消息时，消费者服务器挂了，消息也不会有超时；即使一个消息需要非常长的时间处理，也不会导致消息超时。这样消息永远不会从 RabbitMQ 服务器中删除。只有当消费者正确的发送 ACK 确认反馈，RabbitMQ 确认收到后，消息才会从 RabbitMQ 服务器的数据中删除。 消息的 ACK 确认机制默认是打开的。 忘记通过 basicAck 返回确认信息是常见的错误。这个错误非常严重，将导致消费者客户端退出或者关闭后，消息会被退回 RabbitMQ 服务器，这会使 RabbitMQ 服务器内存爆满，而且 RabbitMQ 也不会主动删除这些被退回的消息。 如果要监控这种错误，可以使用 rabbitmqctl messages_unacknowledged 命令打印出出相关的信息。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十四)]]></title>
    <url>%2F2018%2F08%2F28%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十四) —— CompletionService 1、在异步任务程序中，一种常见的场景是，主线程提交多个异步任务，然后希望有任务完成就处理结果，并且按任务完成顺序逐个处理，对于这种场景，Java 并发包提供了一个方便的方法，使用 CompletionService，这是一个接口，它的实现类是 ExecutorCompletionService。 2、与 ExecutorService 一样，CompletionService 也可以提交异步任务，它的不同是，它可以按任务完成顺序获取结果，其具体定义为：1234567public interface CompletionService&lt;V&gt; &#123; Future&lt;V&gt; submit(Callable&lt;V&gt; task); Future&lt;V&gt; submit(Runnable task, V result); Future&lt;V&gt; take() throws InterruptedException; Future&lt;V&gt; poll(); Future&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException;&#125; submit 方法与 ExecutorService 是一样的，多了 take 和 poll 方法，它们都是获取下一个完成任务的结果，take() 会阻塞等待，poll() 会立即返回，如果没有已完成的任务，返回 null，带时间参数的 poll 方法会最多等待限定的时间。 2、CompletionService 的主要实现类是 ExecutorCompletionService，它依赖于一个 Executor 完成实际的任务提交，而自己主要负责结果的排队和处理。它的构造方法有两个：12public ExecutorCompletionService(Executor executor)public ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) 至少需要一个 Executor 参数，可以提供一个 BlockingQueue 参数，用作完成任务的队列，没有提供的话，ExecutorCompletionService 内部会创建一个 LinkedBlockingQueue。 3、ExecutorCompletionService 是怎么让结果有序处理的呢？因为它有一个额外的队列，每个任务完成之后，都会将代表结果的 Future 入队。在 FutureTask 中，任务完成后，不管是正常完成、异常结束、还是被取消，都会调用 finishCompletion 方法，而该方法会调用一个 done 方法 protected void done() { } 该方法的实现为空，但它是一个 protected 方法，子类可以重写该方法。ExecutorCompletionService 的内部类 QueueingFuture 中重写了该方法。 在 ExecutorCompletionService 中，提交的任务类型不是一般的 FutureTask，而是一个子类 QueueingFuture123456789101112131415161718192021public Future&lt;V&gt; submit(Callable&lt;V&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;V&gt; f = newTaskFor(task); // 注意 QueueingFuture executor.execute(new QueueingFuture(f)); return f;&#125;----------------------------// ExecutorCompletionService 类中的私有实例变量private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;private class QueueingFuture extends FutureTask&lt;Void&gt; &#123; QueueingFuture(RunnableFuture&lt;V&gt; task) &#123; super(task, null); this.task = task; &#125; // 子类重写了 done 方法，在任务完成时将结果加入到完成队列中 protected void done() &#123; completionQueue.add(task); &#125; private final Future&lt;V&gt; task;&#125;--------------------------- 而 ExecutorCompletionService 的 take/poll 方法就是从该队列获取结果：123public Future&lt;V&gt; take() throws InterruptedException &#123; return completionQueue.take();&#125; 4、AbstractExecutorService 的 invokeAny 的实现，就利用了 ExecutorCompletionService，它的基本思路是，提交任务后，通过 take 方法获取结果，获取到第一个有效结果后，取消所有其他任务。 5、CompletionService 它通过一个额外的结果队列，方便了对于多个异步任务结果的处理。 参考博客Java编程的逻辑 - 方便的 CompletionService]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程总结(十三)]]></title>
    <url>%2F2018%2F08%2F27%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十三) —— 线程池 1、Java 并发包中的任务执行服务的主要实现机制是线程池。线程池，顾名思义，就是一个线程的池子，里面有若干线程，它们的目的就是执行提交给线程池的任务，执行完一个任务后不会退出，而是继续等待或执行新任务。线程池主要由两个概念组成，一个是任务队列，另一个是工作者线程，工作者线程主体就是一个循环，循环从队列中接受任务并执行，任务队列保存待执行的任务。 线程池的优点： 它可以重用线程，避免线程创建的开销。 在任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争，确保任务有序完成。 Java 并发包中线程池的实现类是 ThreadPoolExecutor，它继承自 AbstractExecutorService，实现了 ExecutorService。 2、ThreadPoolExecutor 构造方法中的参数解析12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 线程池的大小主要与四个参数有关： corePoolSize：线程池中核心线程个数。不过，这并不是说，一开始就创建这么多线程，刚创建一个线程池后，实际上并不会创建任何线程。一般情况下，有新任务到来的时候，如果当前线程个数小于 corePoolSiz，就会创建一个新线程来执行该任务，需要说明的是，即使其他线程现在也是空闲的，也会创建新线程。不过，如果线程个数大于等于 corePoolSiz，那就不会立即创建新线程了，它会先尝试排队，需要强调的是，它是「尝试」排队，而不是「阻塞等待」入队，如果队列满了或其他原因不能立即入队，它就不会排队，而是检查线程个数是否达到了 maximumPoolSize，如果没有，就会继续创建线程，直到线程数达到 maximumPoolSize。 maximumPoolSize：线程池中允许的最大线程数。 keepAliveTime：当实际线程数大于核心线程数时，此为终止前，多余的空闲线程，等待新任务的最长时间。keepAliveTime 的目的是为了释放多余的线程资源，它表示，当线程池中的线程个数大于 corePoolSize 时，额外空闲线程的存活时间，也就是说，一个非核心线程，在空闲等待新任务时，会有一个最长等待时间，即 keepAliveTime，如果到了时间还是没有新任务，就会被终止。如果该值为 0，表示所有线程都不会超时终止。 unit：keepAliveTime 参数的时间单位。 3、队列之线程参数「BlockingQueue workQueue」ThreadPoolExecutor 要求的队列类型是阻塞队列 BlockingQueue： LinkedBlockingQueue：基于链表的阻塞队列，可以指定最大长度，但默认是无界的。 ArrayBlockingQueue：基于数组的有界阻塞队列。 PriorityBlockingQueue：基于堆的无界阻塞优先级队列。 SynchronousQueue：没有实际存储空间的同步阻塞队列。 如果用的是无界队列，需要强调的是，线程个数最多只能达到 corePoolSize，到达 corePoolSize 后，新的任务总会排队，参数 maximumPoolSize 也就没有意义了。 对于 SynchronousQueue，它没有实际存储元素的空间，当尝试排队时，只有正好有空闲线程在等待接受任务时，才会入队成功，否则，总是会创建新线程，直到达到 maximumPoolSize。 4、任务拒绝策略之线程参数「RejectedExecutionHandler handler」如果队列有界，且 maximumPoolSize 有限，则当队列排满，线程个数也达到了 maximumPoolSize，这时，新任务来了，就会触发线程池的任务拒绝策略。默认情况下，提交任务的方法如 execute/submit/invokeAll 等会抛出异常，类型为 RejectedExecutionException。拒绝策略是可以自定义的，ThreadPoolExecutor 实现了四种处理方式： ThreadPoolExecutor.AbortPolicy：这就是默认的方式，抛出异常。 ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛异常，也不执行。 ThreadPoolExecutor.DiscardOldestPolicy：将等待时间最长的任务扔掉，然后自己排队。 ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，而不是交给线程池中的线程执行。 它们都是 ThreadPoolExecutor 的 public 静态内部类，都实现了 RejectedExecutionHandler 接口，RejectedExecutionHandler 接口定义为：123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 当线程池不能接受任务时，调用其拒绝策略的 rejectedExecution 方法。 ThreadPoolExecutor 中的拒绝策略可以在构造方法中进行指定，也可以通过如下方法进行指定：public void setRejectedExecutionHandler(RejectedExecutionHandler handler)。 默认的 RejectedExecutionHandler 是一个 AbortPolicy 实例 private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 而 AbortPolicy 的 rejectedExecution 实现就是抛出异常。 拒绝策略只有在队列有界，且 maximumPoolSize 有限的情况下才会触发。 如果队列无界，服务不了的任务总是会排队，请求处理队列可能会消耗非常大的内存，甚至引发内存不够的异常。如果队列有界但 maximumPoolSize 无限，可能会创建过多的线程，占满 CPU 和内存，使得任何任务都难以完成。 在任务量非常大的场景中，让拒绝策略有机会执行是保证系统稳定运行很重要的方面。 5、线程工厂之线程参数「ThreadFactory threadFactory」线程池还可以接受一个参数 ThreadFactory，它是一个接口，定义为：123public interface ThreadFactory &#123; Thread newThread(Runnable r);&#125; ThreadFactory 接口根据 Runnable 创建一个 Thread，ThreadPoolExecutor 的默认实现是 Executors 类中的静态内部类 DefaultThreadFactory，主要就是创建一个线程，给线程设置一个名称，设置 daemon 属性为 false，设置线程优先级为标准默认优先级，线程名称的格式为： pool-&lt;线程池编号&gt;-thread-&lt;线程编号&gt;。 6、关于核心线程的特殊配置线程个数小于等于 corePoolSize 时，我们称这些线程为核心线程，默认情况下： 核心线程不会预先创建，只有当有任务时才会创建。 核心线程不会因为空闲而被终止，keepAliveTime参数不适用于它。 ThreadPoolExecutor 有如下方法，可以改变这个默认行为：123456// 预先创建所有的核心线程public int prestartAllCoreThreads()// 创建一个核心线程，如果所有核心线程都已创建，返回 falsepublic boolean prestartCoreThread()// 如果参数为 true，则 keepAliveTime 参数也适用于核心线程public void allowCoreThreadTimeOut(boolean value) 7、工厂类 Executors类 Executors 提供了一些静态工厂方法，可以方便的创建一些预配置的线程池，主要方法有：12345678910111213141516171819202122// newSingleThreadExecutor 只使用一个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止，该线程顺序执行所有任务。该线程池适用于需要确保所有任务被顺序执行的场合public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;----------------------------------------------------------------------// newFixedThreadPool 使用固定数目的 n 个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止。和 newSingleThreadExecutor 一样，由于是无界队列，如果排队任务过多，可能会消耗非常大的内存public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;---------------------------------------------------------------------// newCachedThreadPool 的 corePoolSize 为 0，maximumPoolSize 为 Integer.MAX_VALUE，keepAliveTime 是 60 秒，队列为 SynchronousQueue// 当新任务到来时，如果正好有空闲线程在等待任务，则其中一个空闲线程接受该任务，否则就总是创建一个新线程，创建的总线程个数不受限制，对任一空闲线程，如果60秒内没有新任务，就终止public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 实际中，应该使用 newFixedThreadPool 还是 newCachedThreadPool 呢？在系统负载很高的情况下，newFixedThreadPool 可以通过队列使新任务排队，保证有足够的资源处理实际的任务，而 newCachedThreadPool 会为每个任务创建一个线程，导致创建过多的线程竞争 CPU 和内存资源，使得任何实际任务都难以完成，这时，newFixedThreadPool 更为适用。 如果系统负载不太高，单个任务的执行时间也比较短，newCachedThreadPool 的效率可能更高，因为任务可以不经排队，直接交给某一个空闲线程。 在系统负载可能极高的情况下，两者都不是好的选择，newFixedThreadPool 的问题是队列过长，而 newCachedThreadPool 的问题是线程过多，这时，应根据具体情况自定义 ThreadPoolExecutor，传递合适的参数。 8、线程的死锁关于提交给线程池的任务，需要特别注意一种情况，就是任务之间有依赖，这种情况可能会出现死锁。对于相互依赖的任务，需要特别注意，避免出现死锁。 避免死锁的策略： 替换 newFixedThreadPool 为 newCachedThreadPool，让创建线程不再受限。 使用 SynchronousQueue，它可以避免死锁。因为对于普通队列，入队只是把任务放到了队列中，而对于 SynchronousQueue 来说，入队成功就意味着已有线程接受处理，如果入队失败，可以创建更多线程直到 maximumPoolSize，如果达到了 maximumPoolSize，会触发拒绝机制，不管怎么样，都不会死锁。 9、ThreadPoolExecutor 实现了生产者/消费者模式，工作者线程就是消费者，任务提交者就是生产者，线程池自己维护任务队列。当我们碰到类似生产者/消费者问题时，应该优先考虑直接使用线程池，而非重新发明轮子，自己管理和维护消费者线程及任务队列。 10、小结：ThreadPoolExecutor 参数 corePoolSize, maximumPoolSize, keepAliveTime, unit 用于控制线程池中线程的个数，workQueue 表示任务队列，threadFactory 用于对创建的线程进行一些配置，handler 表示任务拒绝策略。 参考博客Java编程的逻辑 - 线程池]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十二)]]></title>
    <url>%2F2018%2F08%2F26%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十二) —— 异步任务执行服务 1、Java 并发包提供了一套框架，大大简化了执行异步任务所需的开发。在之前的学习中，线程 Thread 既表示要执行的任务，又表示执行的机制，而这套框架引入了一个「执行服务」的概念，它将「任务的提交」和「任务的执行」相分离，「执行服务」封装了任务执行的细节，对于任务提交者而言，它可以关注于任务本身，如提交任务、获取结果、取消任务，而不需要关注任务执行的细节，如线程创建、任务调度、线程关闭等。 2、任务执行服务涉及的基本接口： Runnable 和 Callable：表示要执行的异步任务。 Executor 和 ExecutorService：表示执行服务。 Future：表示异步任务的结果。 Runnable 和 Callable 都表示任务，Runnable 没有返回结果，而 Callable 有，Runnable 不会抛出异常，而 Callable 会。 Executor 表示最简单的执行服务，其定义为：123public interface Executor &#123; void execute(Runnable command);&#125; 在未来某个时间执行给定的任务 Runnable，没有返回结果。该任务可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。 ExecutorService 扩展了 Executor，定义了更多服务，基本方法有：12345678910111213141516171819202122232425262728293031323334353637public interface ExecutorService extends Executor &#123; // 这三个 submit 都表示提交一个任务，返回值类型都是 Future，返回后，只是表示任务已提交，不代表已执行，通过 Future 可以查询异步任务的状态、获取最终结果、取消任务等 // 对于 Callable，任务最终有个返回值，而对于 Runnable 是没有返回值的 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); // 提交 Runnable 的方法可以同时提供一个结果，在异步任务结束时返回 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); // 异步任务的最终返回值为 null Future&lt;?&gt; submit(Runnable task); // shutdown 和 shutdownNow 表示关闭任务执行服务 // shutdown 表示不再接受新任务，但已提交的任务会继续执行，即使任务还未开始执行 void shutdown(); // shutdownNow 不仅不接受新任务，已提交但尚未执行的任务会被终止，对于正在执行的任务，一般会调用线程的 interrupt 方法尝试中断，不过，线程可能不响应中断，shutdownNow 会返回已提交但尚未执行的任务列表 List&lt;Runnable&gt; shutdownNow(); // shutdown 和 shutdownNow 不会阻塞等待，它们返回后不代表所有任务都已结束，不过 isShutdown 方法会返回 true boolean isShutdown(); boolean isTerminated(); // 调用者可以通过 awaitTermination 等待所有任务结束，它可以限定等待的时间，如果超时前所有任务都结束了，即 isTerminated 方法返回 true，则返回 true，否则返回 false boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; // ExecutorService 有两组批量提交任务的方法，invokeAll 和 invokeAny，它们都有两个版本，其中一个限定等待时间 // invokeAll 等待所有任务完成，返回的 Future 列表中，每个 Future 的 isDone 方法都返回 true，不过 isDone 为 true 不代表任务就执行成功了，可能是被取消了，invokeAll 可以指定等待时间，如果超时后有的任务没完成，就会被取消 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; // invokeAny 只要有一个任务在限时内成功返回了，它就会返回该任务的结果，其他任务会被取消，如果没有任务能在限时内成功返回，抛出 TimeoutException，如果限时内所有任务都结束了，但都发生了异常，抛出 ExecutionException &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 使用 ExecutorService 编写并发异步任务的代码就像写顺序程序一样，不用关心线程的创建和协调，只需要提交任务、处理结果就可以了，大大简化了开发工作。 3、Future 接口1234567891011121314151617181920// Future 表示异步计算的结果public interface Future&lt;V&gt; &#123; // cancel 用于取消异步任务，如果任务已完成、或已经取消、或由于某种原因不能取消，cancel 返回 false，否则返回 true // 如果任务还未开始或已经结束，则不再运行 // 如果任务已经在运行，则不一定能取消，参数 mayInterruptIfRunning 表示，如果任务正在执行，是否调用 interrupt 方法中断线程，如果为 false 就不会，如果为 true，就会尝试中断线程，interrupt() 不一定能取消线程 boolean cancel(boolean mayInterruptIfRunning); // isDone 和 isCancelled 用于查询任务状态 // isCancelled 表示任务是否被取消，只要 cancel 方法返回了 true，随后的 isCancelled 方法都会返回 true，即使执行任务的线程还未真正结束 boolean isCancelled(); // isDone 表示任务是否结束，不管什么原因都算，可能是任务正常结束、可能是任务抛出了异常、也可能是任务被取消 boolean isDone(); // get 用于返回异步任务最终的结果，如果任务还未执行完成，会阻塞等待 V get() throws InterruptedException, ExecutionException; // 可以限定阻塞等待的时间，如果超时任务还未结束，会抛出 TimeoutException V get(long timeout, TimeUnit unit) throws InterruptedException,ExecutionException, TimeoutException;&#125; get() 方法，任务最终大概有三个结果： 正常完成，get 方法会返回其执行结果，如果任务是 Runnable 且没有提供结果，返回 null。 任务执行抛出了异常，get 方法会将异常包装为 ExecutionException 重新抛出，通过异常的 getCause 方法可以获取原异常。 任务被取消了，get 方法会抛出异常 CancellationException。 如果调用 get 方法的线程被中断了，get 方法会抛出 InterruptedException。 Future 是一个重要的概念，是实现「任务的提交」与「任务的执行」相分离的关键，是其中的纽带，任务提交者和任务执行服务通过它隔离各自的关注点，同时进行协作。 4、ExecutorService 的主要实现类是 ThreadPoolExecutor，它是基于线程池实现的。ExecutorService 有一个抽象实现类 AbstractExecutorService，接下来简要分析下 AbstractExecutorService 的原理。12345678910111213141516// AbstractExecutorService 提供了 submit、invokeAll、invokeAny 的默认实现，子类只需要实现如下方法即可public abstract class AbstractExecutorService implements ExecutorService &#123; // 除了 execute 方法，其他方法都与执行服务的生命周期管理有关 public void shutdown() public List&lt;Runnable&gt; shutdownNow() public boolean isShutdown() public boolean isTerminated() public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException // submit/invokeAll/invokeAny 最终都会调用 execute，execute 决定了到底如何执行任务 public void execute(Runnable command)&#125; 5、AbstractExecutorService 抽象类中 submit() 方法源码解析12345678910111213141516171819202122232425public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); // 调用 newTaskFor 生成了一个 RunnableFuture，RunnableFuture 是一个接口，既扩展了 Runnable，又扩展了 Future，没有定义新方法 // 作为 Runnable，它表示要执行的任务，传递给 execute 方法进行执行 // 作为 Future，它又表示任务执行的异步结果 RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;----------------------protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; // 就是创建了一个 FutureTask 对象，FutureTask 实现了 RunnableFuture 接口 return new FutureTask&lt;T&gt;(runnable, value);&#125;----------------------public FutureTask(Runnable runnable, V result) &#123; // 如果 FutureTask 接受的是一个 Runnable 对象，它会调用 Executors.callable 转换为 Callable 对象 this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;---------------------// RunnableFuture 接口定义public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; 6、FutureTask 源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Future 的主要实现类是 FutureTaskpublic class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; // 表示状态，可取值如下 private volatile int state; private static final int NEW = 0;// 刚开始的状态，或任务在运行 private static final int COMPLETING = 1;// 临时状态，任务即将结束，在设置结果 private static final int NORMAL = 2;// 任务正常执行完成 private static final int EXCEPTIONAL = 3;// 任务执行抛出异常结束 private static final int CANCELLED = 4;// 任务被取消 private static final int INTERRUPTING = 5;// 任务在被中断 private static final int INTERRUPTED = 6;// 任务被中断 // 表示待执行的任务 private Callable&lt;V&gt; callable; // 表示最终的执行结果或异常 private Object outcome; // non-volatile, protected by state reads/writes // 表示运行任务的线程 private volatile Thread runner; // 单向链表表示等待任务执行结果的线程 private volatile WaitNode waiters; // FutureTask 的构造方法会初始化 callable 和状态，如果 FutureTask 接受的是一个 Runnable 对象，它会调用 Executors.callable 转换为 Callable 对象 public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable &#125; // 任务执行服务会使用一个线程执行 FutureTask 的 run 方法 public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125;&#125; FutureTask 的 run() 方法的基本逻辑为： 调用 callable 的 call 方法，捕获任何异常。 如果正常执行完成，调用 set 设置结果，保存到 outcome。 如果执行过程发生异常，调用 setException 设置异常，异常也是保存到 outcome，但状态不一样。 set 和 setException 除了设置结果，修改状态外，还会调用 finishCompletion ，它会唤醒所有等待结果的线程。 7、FutureTask 中 get() 方法源码解析123456789101112131415161718192021public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; if (unit == null) throw new NullPointerException(); int s = state; // 如果任务还未执行完毕，就等待 if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); // 最后调用 report 报告结果, report 根据状态返回结果或抛出异常 return report(s);&#125;-----------------------------------private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x);&#125; 8、FutureTask 中 cancel() 方法源码解析123456789101112131415161718192021222324public boolean cancel(boolean mayInterruptIfRunning) &#123; // 如果任务已结束或取消，返回 false // 如果 mayInterruptIfRunning 为 false，设置状态为 CANCELLED if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; // in case call to interrupt throws exception // 如果 mayInterruptIfRunning 为 true，调用 interrupt 中断线程，设置状态为 INTERRUPTED if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) t.interrupt(); &#125; finally &#123; // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); &#125; &#125; &#125; finally &#123; // 调用 finishCompletion 唤醒所有等待结果的线程 finishCompletion(); &#125; return true;&#125; 9、Java 并发包中任务执行服务的基本概念和原理，该服务体现了并发异步开发中「关注点分离」的思想，使用者只需要通过 ExecutorService 提交任务，通过 Future 操作任务和结果即可，不需要关注线程创建和协调的细节。 参考博客Java编程的逻辑 - 异步任务执行服务]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十一)]]></title>
    <url>%2F2018%2F08%2F26%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十一) —— 各种队列]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器总结(四)]]></title>
    <url>%2F2018%2F08%2F25%2FJava%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Java 容器总结(四) —— HashSet 1、HashSet 由两个单词组成，Hash 和 Set，Set 表示接口，实现 Set 接口有多种方式，HashSet 实现的方式利用了 Hash。Set 表示的是没有重复元素、且不保证顺序的容器接口，它扩展了 Collection，但没有定义任何新的方法，不过，对于其中的一些方法，它有自己的规范。 2、Set 接口定义123456789101112131415161718192021public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); // 迭代遍历时，不要求元素之间有特别的顺序 // HashSet 的实现就是没有顺序，但有的 Set 实现可能会有特定的顺序，比如 TreeSet Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); // 如果集合中已经存在相同元素了，则不会改变集合，直接返回 false，只有不存在时，才会添加，并返回 true boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); // 重复的元素不添加，不重复的添加，如果集合有变化，返回 true，没变化返回 false boolean addAll(Collection&lt;? extends E&gt; c); boolean retainAll(Collection&lt;?&gt; c); boolean removeAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode();&#125; 3、注意：HashSet 要求元素重写 hashCode 和 equals 方法，且对两个对象，equals 相同，则 hashCode 也必须相同，如果元素是自定义的类，需要注意这一点。因为 HashSet 就是依靠 hashCode 和 equals 方法来判断对象是否相等的，所以使用 HashSet 的时候一定要注意重写这两个方法。 4、HashSet 内部组成1234567public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; // HashSet 内部是用 HashMap 实现的，它内部有一个 HashMap 实例变量 private transient HashMap&lt;E,Object&gt; map; // HashSet 相当于只有键，值都是相同的固定值 PRESENT private static final Object PRESENT = new Object();&#125; 5、HashSet 的构造方法，主要就是调用了对应的 HashMap 的构造方法。 6、add() 方法源码解析1234public boolean add(E e) &#123; // 返回值为 boolean 类型 return map.put(e, PRESENT)==null;&#125; 就是调用 map 的 put 方法，元素 e 用于键，值就是那个固定值 PRESENT，put 返回 null 表示原来没有对应的键，添加成功了。HashMap 中一个键只会保存一份，所以重复添加 HashMap 不会变化。 7、remove() 方法源码解析1234// 调用 map 的 remove 方法，返回值为 PRESENT 表示原来有对应的键且删除成功了public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 8、迭代器1234// 返回 map 的 keySet 的迭代器public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; 9、HashSet 特点分析HashSet 实现了 Set 接口，内部是通过 HashMap 实现的，这决定了它有如下特点： 没有重复元素。 可以高效的添加、删除元素、判断元素是否存在，效率都为 O(1)。 没有顺序。 10、HashSet 实现了 Set 接口，不含重复元素，内部实现利用了 HashMap，可以方便高效地实现如去重、集合运算等功能。HashSet 没有顺序，如果要保持添加的顺序，可以使用 HashSet 的一个子类 LinkedHashSet。 参考博客Java编程的逻辑 - 剖析 HashSet]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十)]]></title>
    <url>%2F2018%2F08%2F24%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%8D%81)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十) —— 基于 SkipList 的 Map 和 Set]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(九)]]></title>
    <url>%2F2018%2F08%2F24%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(九) —— ConcurrentHashMap 1、ConcurrentHashMap，它是 HashMap 的并发版本，与 HashMap 相比，它有如下特点： 并发安全。 直接支持一些原子复合操作。 支持高并发、读操作完全并行、写操作支持一定程度的并行。 与同步容器 Collections.synchronizedMap 相比，迭代不用加锁，不会抛出 ConcurrentModificationException。 弱一致性。 2、HashMap 不是并发安全的，在并发更新的情况下，HashMap 的链表结构可能形成环，出现死循环，占满 CPU。死循环出现在多个线程同时扩容哈希表的时候，不是同时更新一个链表的时候，那种情况可能会出现更新丢失，但不会死循环。具体参考 Java HashMap 的死循环。 使用 Collections.synchronizedMap 方法可以生成一个同步容器，可以避免该问题。在 Java 中，HashMap 还有一个同步版本 Hashtable，它与使用 synchronizedMap 生成的 Map 基本是一样的，也是在每个方法调用上加了 synchronized。然而同步容器存在以下问题： 每个方法都需要同步，支持的并发度比较低。 对于迭代和复合操作，需要调用方加锁，使用比较麻烦，且容易忘记。 3、ConcurrentHashMap 没有以上那些问题，它同样实现了 Map 接口，也是基于哈希表实现的。除了 Map 接口，ConcurrentHashMap 还实现了一个接口 ConcurrentMap，接口定义了一些条件更新操作。12345678910public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; // 条件更新，如果 Map 中没有 key，设置 key 的值为 value，返回原来 key 对应的值，如果没有，返回 null V putIfAbsent(K key, V value); // 条件删除，如果 Map 中有 key，且对应的值为 value，则删除，如果删除了，返回 true，否则 false boolean remove(Object key, Object value); // 条件替换，如果 Map 中有 key，且对应的值为 oldValue，则替换为 newValue，如果替换了，返回 ture，否则 false boolean replace(K key, V oldValue, V newValue); // 条件替换，如果 Map 中有 key，则替换值为 value，返回原来 key 对应的值，如果原来没有，返回 null V replace(K key, V value);&#125; 如果使用同步容器，调用方必须加锁，而 ConcurrentMap 将它们实现为了原子操作。实际上，使用 ConcurrentMap，调用方也没有办法进行加锁，它没有暴露锁接口，也不使用 synchronized。 4、ConcurrentHashMap 是为高并发设计的，其主要思路有两点： 分段锁 读不需要锁 同步容器使用 synchronized，所有方法，竞争同一个锁，而 ConcurrentHashMap 采用分段锁技术，将数据分为多个段，而每个段有一个独立的锁，每一个段相当于一个独立的哈希表，分段的依据也是哈希值，无论是保存键值对还是根据键查找，都先根据键的哈希值映射到段，再在段对应的哈希表上进行操作。 采用分段锁，可以大大提高并发度，多个段之间可以并行读写。默认情况下，段是 16个，不过，这个数字可以通过构造方法进行设置:public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)concurrencyLevel 表示估计的并行更新的线程个数，ConcurrentHashMap 会将该数转换为2的整数次幂，比如 14 转换为 16，25 转换为 32。 在对每个段的数据进行读写时，ConcurrentHashMap 也不是简单的使用锁进行同步，内部使用了 CAS、对一些写采用原子方式，实现比较复杂，实现的效果是，对于写操作，需要获取锁，不能并行，但是读操作可以，多个读可以并行，写的同时也可以读，这使得 ConcurrentHashMap 的并行度远远大于同步容器。 5、使用同步容器，在迭代中需要加锁，否则可能会抛出 ConcurrentModificationException。ConcurrentHashMap 没有这个问题，在迭代器创建后，在迭代过程中，如果另一个线程对容器进行了修改，迭代会继续，不会抛出异常。 但是迭代器是否会反映别的线程的修改，就需要视情况而定了。这是因为 ConcurrentHashMap 的弱一致性。类似的情况还会出现在 ConcurrentHashMap 的另一个方法：public void putAll(Map&lt;? extends K, ? extends V&gt; m) 该方法并非原子操作，而是调用 put 方法逐个元素进行添加的，在该方法没有结束的时候，部分修改效果就会体现出来。 6、ConcurrentHashMap 的弱一致性ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。 7、ConcurrentHashMap 通过分段锁、CAS 等技术实现了高并发；实现了 ConcurrentMap 接口，支持原子条件更新操作；不会抛出 ConcurrentModificationException，实现了弱一致性。 8、Java 中没有并发版的 HashSet，但可以通过 Collections.newSetFromMap 方法基于 ConcurrentHashMap 构建一个。HashMap/HashSet 基于哈希，不能对元素排序，对应的可排序的容器类是 TreeMap/TreeSet，并发包中可排序的对应版本不是基于树，而是基于 Skip List（跳跃表）的，类分别是 ConcurrentSkipListMap 和 ConcurrentSkipListSet。 参考博客Java编程的逻辑 - ConcurrentHashMap]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(八)]]></title>
    <url>%2F2018%2F08%2F24%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%85%AB)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(八) —— 写时拷贝的 List 和 Set 1、Java 并发包中的容器类。注意这个是并发容器，要跟 Collections 返回的同步容器区分开。这里主要学习 CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个类，Copy-On-Write，即写时拷贝或写时复制，这是解决并发问题的一种重要思路。 2、CopyOnWriteArrayList 基本用法CopyOnWriteArrayList 实现了 List 接口，它的用法与其他 List 如 ArrayList 基本是一样的，它的区别是： 它是线程安全的，可以被多个线程并发访问。 它的迭代器不支持修改操作，但也不会抛出 ConcurrentModificationException。 它直接以原子方式支持一些复合操作。 3、基于 synchronized 的同步容器迭代时，需要对整个列表对象加锁，否则会抛出 ConcurrentModificationException。但 CopyOnWriteArrayList 没有这个问题，迭代时不需要加锁。因为 CopyOnWriteArrayList 的迭代器根本不支持修改，这也是 CopyOnWriteArrayList 思想的本质，写时拷贝，CopyOnWriteArrayList 有点像 String，一旦创建，内容不可变，变的只是引用。 在 JDK 1.8 之前的实现中，CopyOnWriteArrayList 的迭代器不支持修改操作，也不支持一些依赖迭代器修改方法的操作，比如 Collections 的 sort 方法，因为 Collections.sort 方法依赖迭代器的 set 方法。但是在 JDK 1.8 中，List 接口增加了 sort 方法，并提供了默认实现，而 CopyOnWriteArrayList 重写了该实现，从以下其源码可以看出，加锁了。12345678910111213public void sort(Comparator&lt;? super E&gt; c) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); Object[] newElements = Arrays.copyOf(elements, elements.length); @SuppressWarnings("unchecked") E[] es = (E[])newElements; Arrays.sort(es, c); setArray(newElements); &#125; finally &#123; lock.unlock(); &#125;&#125; 基于 synchronized 的同步容器的一个问题是复合操作，比如先检查再更新，也需要调用方加锁，而 CopyOnWriteArrayList 直接支持两个原子方法，其本质都是加锁了。1234// 不存在才添加，如果添加了，返回 true，否则返回 falsepublic boolean addIfAbsent(E e)// 批量添加 c 中的非重复元素，不存在才添加，返回实际添加的个数public int addAllAbsent(Collection&lt;? extends E&gt; c) 4、CopyOnWriteArrayList 的基本原理CopyOnWriteArrayList 的内部也是一个数组，但这个数组是以原子方式被整体更新的。每次修改操作，都会新建一个数组，复制原数组的内容到新数组，在新数组上进行需要的修改，然后以原子方式设置内部的数组引用，这就是写时拷贝。 所有的读操作，都是先拿到当前引用的数组，然后直接访问该数组，在读的过程中，可能内部的数组引用已经被修改了，但不会影响读操作，它依旧访问原数组内容。即数组内容是只读的，写操作都是通过新建数组，然后原子性的修改数组引用来实现的。 123456789101112131415161718public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; // 内部数组，注意，它声明为了 volatile，这是必需的，保证内存可见性，写操作更改了之后，读操作能看到。 private transient volatile Object[] array; final transient ReentrantLock lock = new ReentrantLock(); final Object[] getArray() &#123; return array; &#125; final void setArray(Object[] a) &#123; array = a; &#125; // 默认构造方法 public CopyOnWriteArrayList() &#123; setArray(new Object[0]); &#125; &#125; 在 CopyOnWriteArrayList 中，读不需要锁，可以并行，读和写也可以并行，但多个线程不能同时写，每个写操作都需要先获取锁，CopyOnWriteArrayList 内部使用 ReentrantLock。 5、add() 方法源码解析1234567891011121314151617public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获取原数组 Object[] elements = getArray(); int len = elements.length; // 拷贝到一个新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; // 调用 setArray 原子性的修改内部数组引用 setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 解析为什么 add() 方法需要加锁？内部数组 array 是被 volatile 关键字修饰的，其内存可见性是不存在问题的，但是却存在另一个问题 —— 竞态条件，所以通过加锁来解决并发写时的竞态条件问题。此处加锁的目的就是为了解决竞态条件问题。 6、indexOf() 方法源码解析12345678910111213141516171819public int indexOf(Object o) &#123; Object[] elements = getArray(); return indexOf(o, elements, 0, elements.length);&#125;-----------------------------// 这个 indexOf 方法访问的所有数据都是通过参数传递进来的，数组内容也不会被修改，不存在并发问题private static int indexOf(Object o, Object[] elements, int index, int fence) &#123; if (o == null) &#123; for (int i = index; i &lt; fence; i++) if (elements[i] == null) return i; &#125; else &#123; for (int i = index; i &lt; fence; i++) if (o.equals(elements[i])) return i; &#125; return -1;&#125; 7、iterator() 迭代器方法源码解析1234567891011121314151617public Iterator&lt;E&gt; iterator() &#123; // COWIterator 是内部类，传递给它的是不变的数组，它也只是读该数组，不支持修改 return new COWIterator&lt;E&gt;(getArray(), 0);&#125;-------------------static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; /** Snapshot of the array */ // final 修饰，表明数组的引用不可变，而写时拷贝的特性，表明数组一旦被创建其内容不会再变，所以该数组是不可变的 private final Object[] snapshot; /** Index of element to be returned by subsequent call to next. */ private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125;&#125; 8、CopyOnWriteArrayList 小结每次修改都创建一个新数组，然后复制所有内容，如果数组比较大，修改操作又比较频繁，CopyOnWriteArrayList 的性能是很低的。CopyOnWriteArrayList 不适用于数组很大，且修改频繁的场景。它是以优化读操作为目标的，读不需要同步，性能很高，但在优化读的同时就牺牲了写的性能。 保证线程安全的两种思路，一种是锁，使用 synchronized 或 ReentrantLock，另外一种是循环 CAS，写时拷贝体现了保证线程安全的另一种思路。对于绝大部分访问都是读，且有大量并发线程要求读，只有个别线程进行写，且只是偶尔写的场合，这种写时拷贝就是一种很好的解决方案。 写时拷贝是一种重要的思维，用于各种计算机程序中，比如经常用于操作系统内部的进程管理和内存管理。 9、CopyOnWriteArraySet 实现了 Set 接口，不包含重复元素，内部，它是通过 CopyOnWriteArrayList 实现的。1234567891011121314public class CopyOnWriteArraySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements java.io.Serializable &#123; // 内部实现依赖 CopyOnWriteArrayList private final CopyOnWriteArrayList&lt;E&gt; al; public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;(); &#125; // 调用了 CopyOnWriteArrayList 的 addIfAbsent 方法 public boolean add(E e) &#123; return al.addIfAbsent(e); &#125; &#125; 由于 CopyOnWriteArraySet 是基于 CopyOnWriteArrayList 实现的，所以与 Set 的实现类如 HashSet/TreeSet 相比，它的性能比较低，不适用于元素个数特别多的集合。如果元素个数比较多，可以考虑 ConcurrentHashMap 或 ConcurrentSkipListSet。 ConcurrentHashMap 与 HashMap 类似，适用于不要求排序的场景，ConcurrentSkipListSet 与 TreeSet 类似，适用于要求排序的场景。Java 并发包中没有与 HashSet 对应的并发容器，但可以很容易的基于 ConcurrentHashMap 构建一个，利用 Collections.newSetFromMap 方法即可。 参考博客Java 编程的逻辑 - 写时拷贝的 List 和 Set]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(七)]]></title>
    <url>%2F2018%2F08%2F23%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%83)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(七) —— 显式条件 1、显式条件也可以被称做条件变量、条件队列、或条件。锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与 synchronzied 相对应，而显式条件与 wait/notify 相对应。wait/notify 与 synchronized 配合使用，显式条件与显式锁配合使用。条件与锁相关联，创建条件变量需要通过显式锁，Lock 接口定义了创建方法：Condition newCondition();。 2、Condition 接口表示条件变量123456789101112public interface Condition &#123; void await() throws InterruptedException; void awaitUninterruptibly(); // 等待时间也是相对时间，但参数单位是纳秒，返回值是 nanosTimeout 减去实际等待的时间，即剩余未用的等待时间 long awaitNanos(long nanosTimeout) throws InterruptedException; // 等待时间是相对时间，如果由于等待超时返回，返回值为 false，否则为 true boolean await(long time, TimeUnit unit) throws InterruptedException; // 等待时间是绝对时间，如果由于等待超时返回，返回值为 false，否则为 true boolean awaitUntil(Date deadline) throws InterruptedException; void signal(); void signalAll();&#125; 除 awaitUninterruptibly() 之外，await 方法都是响应中断的，如果发生了中断，会抛出 InterruptedException，但中断标志位会被清空。awaitUninterruptibly() 方法不会由于中断结束，但当它返回时，如果等待过程中发生了中断，中断标志位会被设置。 3、一般而言，与 Object 的 wait 方法一样，调用 await 方法前需要先获取锁，如果没有锁，会抛出异常 IllegalMonitorStateException。await 在进入等待队列后，会释放锁，释放 CPU，当其他线程将它唤醒后，或等待超时后，或发生中断异常后，它都需要重新获取锁，获取锁后，才会从 await 方法中退出。 另外，与 Object 的 wait 方法一样，await 返回后，不代表其等待的条件就一定满足了，通常要将 await 的调用放到一个循环内，只有条件满足后才退出。 一般而言，signal/signalAll 与 notify/notifyAll 一样，调用它们需要先获取锁，如果没有锁，会抛出异常 IllegalMonitorStateException。signal 与 notify 一样，挑选一个线程进行唤醒，signalAll 与 notifyAll 一样，唤醒所有等待的线程，但这些线程被唤醒后都需要重新竞争锁，获取锁后才会从 await 调用中返回。 4、显式条件与显式锁配合，wait/notify 与 synchronized 配合。 5、显示条件的实现原理1234567891011121314151617// ReentrantLock 类中的 newCondition 方法public Condition newCondition() &#123; return sync.newCondition();&#125;-------------------------// ReentrantLock 内部类 Sync 中的 newCondition 方法final ConditionObject newCondition() &#123; // ConditionObject 是 AQS 中定义的一个内部类 return new ConditionObject();&#125;-------------------------public class ConditionObject implements Condition, java.io.Serializable &#123; // 条件队列的头节点 private transient Node firstWaiter; // 条件队列的尾节点 private transient Node lastWaiter;&#125; ConditionObject 内部也有一个队列，表示条件等待队列。ConditionObject 是 AQS 的成员内部类，它可以直接访问 AQS 中的数据，比如 AQS 中定义的锁等待队列。 6、await 方法源码解析1234567891011121314151617181920212223242526public final void await() throws InterruptedException &#123; // 如果等待前中断标志位已被设置，直接抛异常 if (Thread.interrupted()) throw new InterruptedException(); // 1.为当前线程创建节点，加入条件等待队列 Node node = addConditionWaiter(); // 2.释放持有的锁 int savedState = fullyRelease(node); int interruptMode = 0; // 3.放弃CPU，进行等待，直到被中断或 isOnSyncQueue 变为 true // isOnSyncQueue 为 true 表示节点被其他线程从条件等待队列 // 移到了外部的锁等待队列,等待的条件已满足 while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; // 4.重新获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); // 5.处理中断，抛出异常或设置中断标志位 if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 7、signal 方法源码解析1234567public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125; doSignal 的代码就不列举了，其基本逻辑是：将节点从条件等待队列移到锁等待队列；调用 LockSupport.unpark 将线程唤醒。 8、总结：显示条件的本质就是一个队列，该队列提供了两个系列的方法，await 系列的方法用于条件不满足时将线程对象加入队列，signal 系列方法用于条件满足时从队列中释放线程对象。实际业务可以根据具体的条件是否满足来决定当前线程对象是加入队列等待，还是从队列中释放执行。 参考博客Java编程的逻辑 - 显式条件]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(三)]]></title>
    <url>%2F2018%2F08%2F23%2FJava%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Java 容器总结(三) —— HashMap 1、ArrayList 和 LinkedList，它们的一个共同特点是，查找元素的效率都比较低，都需要逐个进行比较，而 HashMap 它的查找效率则要高的多。Map 表示映射关系，实现 Map 接口有多种方式，HashMap 实现的方式利用了 Hash。 2、Map 接口Map 按照键存储和访问值，键不能重复，即一个键只会存储一份，给同一个键重复设值会覆盖原来的值。使用 Map 可以方便地处理需要根据键访问对象的场景。数组、ArrayList、LinkedList 可以视为一种特殊的 Map，键为索引，值为对象。1234567891011121314151617181920212223public interface Map&lt;K,V&gt; &#123; V put(K key, V value); V get(Object key); V remove(Object key); int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); interface Entry&lt;K,V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); &#125; boolean equals(Object o); int hashCode();&#125; Map 接口有两个类型参数，K 和 V，分别表示键 (Key) 和值 (Value) 的类型。在 HashMap 中，key 相同的依据是，要么都为 null，要么 equals 方法返回 true。Map.Entry 是一个嵌套接口，定义在 Map 接口内部，表示一条键值对。 注意：keySet()/values()/entrySet() 有一个共同的特点，它们返回的都是视图，不是拷贝的值，基于返回值的修改会直接修改 Map 自身。 Set 是一个接口，表示的是数学中的集合概念，即没有重复的元素集合。它扩展了 Collection，但没有定义任何新的方法，不过，它要求所有实现者都必须确保 Set 的语义约束，即不能有重复元素。Map 中的键是没有重复的，所以 ketSet() 返回了一个 Set。 3、HashMap 主要围绕以下几个变量来实现的，几乎所有的操作都是在操作以下几个变量：12345678// table 是一个 Node (单向链表) 类型的数组，数组中的每个元素都是一个单向链表，链表中的每个节点表示一个键值对，Node 是一个内部类transient Node&lt;K,V&gt;[] table;// size 表示实际键值对的个数transient int size;// 扩容的阈值int threshold;// loadFactor 是负载因子，表示整体上 table 被占用的程度，是一个浮点数，默认为 0.75，可以通过构造方法进行修改final float loadFactor; 4、HashMap 内部组成12345678910111213141516171819202122232425262728293031public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // table 是一个 Node 类型的数组，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对，Node 是一个内部类 transient Node&lt;K,V&gt;[] table; // size 表示实际键值对的个数 transient int size; int threshold; final float loadFactor; // 静态内部类，实现了 Map.Entry 接口 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // hash 是 key 的哈希值，直接存储 hash 值是为了在比较的时候加快计算 final int hash; final K key; V value; // next 指向下一个 Node 节点，即链表元素的下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; // 直接存储 hash 值是为了在比较的时候加快计算 this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; &#125;&#125; table 默认为 null，当添加键值对后，table 就不是空表了，它会随着键值对的添加进行扩展，扩展的策略类似于 ArrayList，添加第一个元素时，默认分配的大小为 16，不过，并不是 size 大于 16 时再进行扩展，下次什么时候扩展与 threshold 有关。threshold 表示阈值，当键值对个数 size 大于等于 threshold 时考虑进行扩展。一般而言，threshold 等于 table.length 乘以 loadFactor。loadFactor 是负载因子，表示整体上 table 被占用的程度，是一个浮点数，默认为 0.75，可以通过构造方法进行修改。 5、put(K key, V value) 方法源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 调用 HashMap 的 put() 方法public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;-------------------------// 获取 key 的 hash 值static final int hash(Object key) &#123; int h; // 做异或 和 无符号右移的位运算得到最后的 hash 值 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;------------------------// onlyIfAbsent：if true, don't change existing value// evict：if false, the table is in creation mode.final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table 为 null，表示第一次保存时，调用 resize() 方法进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 注意：(n - 1) &amp; hash 用来计算应该将这个键值对放到 table 的哪个位置 // HashMap 中，length 为 2 的幂次方，(n - 1) &amp; hash 等同于求模运算：h % length // 找到了保存位置 i，table[i] 指向一个单向链表，接下来，就是在这个链表中逐个查找是否已经有这个键了 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 无哈希冲突,创建新的 Node tab[i] = newNode(hash, key, value, null); else &#123; // 进到这里表明有哈希冲突了 Node&lt;K,V&gt; e; K k; // 节点 key 存在,直接覆盖 value，保证 key 的唯一性 // 而比较的时候，是先比较 hash 值，hash 相同的时候，再使用 equals 方法进行比较。注意：比较的时候先比较 hash，再比较地址值，最后才使用 equals() // 因为 hash 是整数，比较的性能一般要比 equals 比较高很多，hash 不同，就没有必要调用 equals 方法了，这样整体上可以提高比较性能 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断是否为为红黑树 else if (p instanceof TreeNode) // 是红黑树，赋值 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 是链表，并且 table 的 [i] 值相同的情况 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 如果 p 后的 Node 为空，表明当前链表只有一个结点 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 链表长度达到 8，改变链表结构为红黑树 treeifyBin(tab, hash); break; &#125; // key 相同则跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 就是移动指针方便继续取 p.next，因为前面有 e = p.next 这样的赋值 p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 根据规则选择是否覆盖value if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 扩容检测，并且此处完成对 size 加 1 if (++size &gt; threshold) // size 大于阈值则扩容 resize(); afterNodeInsertion(evict); return null;&#125;------------------------final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 扩容为原先的两倍大小 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 初始容量设为阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 零初始阈值表示使用默认值 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 扩容后的对旧数组中值的拷贝操作 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 6、get() 方法源码解析123456789101112131415161718192021222324public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;--------------------final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 7、remove() 方法源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;------------------------------final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // 要删除的结点是头结点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 不是要删除的结点头结点的情况 else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) // 红黑树节点 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; // 链表节点 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // node 表示要删除的结点，获取到 node 后，分情形删除节点 // node 不为 null 的情况下，再判断 value 是否一致，相当于双重保障吧 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) // 红黑树结点删除，牵扯到由红黑树变链表的逻辑 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 头结点 else if (node == p) tab[index] = node.next; // 非头结点，注意：node 为要删除的结点，p 为要删除结点的前一个结点 else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 8、HashMap 的主结构类似于一个数组，添加值时通过 key 确定储存位置。当发生冲突时,相同 hash 值的键值对会组成链表。在 JDK 1.8 以前，数组 + 链表的组合形式大部分情况下都能有不错的性能效果。但是在极端情况下，一组「比如经过精心设计的」键值对都发生了冲突，这时的哈希结构就会退化成一个链表，使 HashMap 性能急剧下降。所以在 JDK 1.8 之后，采用数组+链表+红黑树「链表长度大于 8 时转为红黑树」的方式对元素进行存储。 9、HashMap 实现原理小结HashMap 的基本实现原理，内部有一个数组 table，每个元素 table[i] 指向一个单向链表，根据键存取值，用键算出 hash，取模得到数组中的索引位置 buketIndex，然后操作 table[buketIndex] 指向的单向链表。 存取的时候依据键的 hash 值，只在对应的链表中操作，不会访问别的链表，在对应链表操作时也是先比较 hash 值，相同的话才用 equals 方法比较，这就要求，相同的对象其 hashCode() 返回值必须相同，如果键是自定义的类，就特别需要注意这一点。这也是hashCode和equals方法的一个关键约束。 HashMap 它实现了 Map 接口，可以方便的按照键存取值，它的实现利用了哈希，可以根据键自身直接定位，存取效率很高。 10、HashMap 特点分析HashMap 实现了 Map 接口，内部使用数组+链表+红黑树和哈希的方式进行实现，这决定了它有如下特点： 根据键保存、获取、删除操作的效率都很高，为 O(1)，每个单向链表往往只有一个或少数几个节点，根据 hash 值就可以直接快速定位。 HashMap 中的键值对没有顺序，因为 hash 值是随机的。 综上所述，HashMap 适用于不要求顺序，经常需要根据键存取值的场景。 11、根据哈希值存取对象、比较对象是计算机程序中一种重要的思维方式，它使得存取对象主要依赖于自身哈希值，而不是与其他对象进行比较，存取效率也就与集合大小无关，高达 O(1)，即使进行比较，也利用哈希值提高比较性能。 参考博客Java 编程的逻辑 - 剖析 HashMapJava8 HashMap 源码分析]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(二)]]></title>
    <url>%2F2018%2F08%2F22%2FJava%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Java 容器总结(二) —— LinkedList 1、LinkedList 与 ArrayList 一样，同样实现了 List 接口，而 List 接口扩展了 Collection 接口，Collection 又扩展了 Iterable 接口，所有这些接口的方法都是可以使用的。123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125; 2、队列 (Queue) LinkedList 还实现了队列接口 Queue，队列的特点就是先进先出，在尾部添加元素，从头部删除元素。 12345678 public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek();&#125; Queue 扩展了 Collection，它的主要操作有三个： 在尾部添加元素 (add, offer)。 查看头部元素 (element, peek)，返回头部元素，但不改变队列。 删除头部元素 (remove, poll)，返回头部元素，并且从队列中删除。 每种操作都有两种形式，区别在于，对于特殊情况的处理不同。特殊情况是指，队列为空或者队列为满。为满是指队列有长度大小限制，而且已经占满了。LinkedList 的实现中，队列长度没有限制，但别的 Queue 的实现可能有。 在队列为空时，element 和 remove 会抛出异常 NoSuchElementException，而 peek 和 poll 返回特殊值 null，在队列为满时，add 会抛出异常 IllegalStateException，而 offer 只是返回 false。 3、栈栈也是一种常用的数据结构，与队列相反，它的特点是先进后出、后进先出。Java 中用 Stack 类来表示栈，但这个类已经过时了，就 Stack 而言，在新的设计中，Queue 可以直接取代它。Java 中没有单独的栈接口，栈相关方法包括在了表示双端队列的接口 Deque 中。123456// push 表示入栈，在头部添加元素，栈的空间可能是有限的，如果栈满了，push 会抛出异常 IllegalStateExceptionvoid push(E e);// pop 表示出栈，返回头部元素，并且从栈中删除，如果栈为空，会抛出异常 NoSuchElementExceptionE pop();// peek 查看栈头部元素，不修改栈，如果栈为空，返回 nullE peek(); 4、双端队列 (Deque)栈和队列都是在两端进行操作，栈只操作头部，队列两端都操作，但尾部只添加、头部只查看和删除，有一个更为通用的操作两端的接口 Deque，Deque 扩展了 Queue，包括了栈的操作方法，此外，它还有更为明确的操作两端的方法。 xxxFirst 操作头部，xxxLast 操作尾部。与队列类似，每种操作有两种形式，区别也是在队列为空或满时，处理不同。为空时，getXXX/removeXXX 会抛出异常，而 peekXXX/pollXXX 会返回 null。队列满时，addXXX 会抛出异常，offerXXX 只是返回 false。 栈和队列只是双端队列的特殊情况，它们的方法都可以使用双端队列的方法替代，不过，使用不同的名称和方法，概念上更为清晰。 5、LinkedList 内部组成LinkedList 直译就是链表，确切的说，它的内部实现是双向链表，每个元素在内存都是单独存放的，元素之间通过链接连在一起。 为了表示链接关系，需要一个节点的概念，节点包括实际的元素，但同时有两个链接，分别指向前一个节点(前驱)和后一个节点(后继)，节点是一个内部类。123456789101112// Node 类表示节点private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList 内部组成中有三个实例变量：1234// size 表示链表长度，默认为 0transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; LinkedList 的所有 public 方法内部操作的都是这三个实例变量。 6、 add() 方法源码解析12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true;&#125;---------------------void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 7、根据索引访问元素 get()1234567891011121314151617181920212223242526272829public E get(int index) &#123; // 检查索引位置的有效性，如果无效，抛出异常 checkElementIndex(index); return node(index).item;&#125;------------------------private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;-------------------------private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;-------------------------Node&lt;E&gt; node(int index) &#123; // 根据 index 位置，来决定从前还是从后查找 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 8、indexOf 源码分析1234567891011121314151617public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 9、指定位置插入元素 add(int index, E element)12345678910111213141516171819202122232425262728293031323334353637383940414243public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;----------------------------private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;----------------------------private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;-----------------------------void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;----------------------------// 参数 succ 表示后继节点。变量 pred 就表示前驱节点。目标就是在 pred 和 succ 中间插入一个节点。void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 10、删除元素123456789101112131415161718192021222324252627282930public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;--------------------------E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 11、需要注意的是：对于队列、栈和双端队列接口，长度可能有限制，LinkedList 实现了这些接口，不过 LinkedList 对长度并没有限制。使用的时候需要特别留意那些限制。 12、对于 LinkedList 内部是用双向链表实现的，维护了长度、头节点和尾节点，这决定了它有如下特点： 按需分配空间，不需要预先分配很多空间。 不可以随机访问，按照索引位置访问效率比较低，必须从头或尾顺着链接找，效率为 O(N/2)。 不管列表是否已排序，只要是按照内容查找元素，效率都比较低，必须逐个比较，效率为 O(N)。 在两端添加、删除元素的效率很高，为 O(1)。 在中间插入、删除元素，要先定位，效率比较低，为 O(N)，但修改本身的效率很高，效率为 O(1)。 参考博客Java编程的逻辑 - 剖析 LinkedList]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(一)]]></title>
    <url>%2F2018%2F08%2F22%2FJava%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 容器总结(一) —— ArrayList 1、ArrayList 的基本原理是：内部有一个数组 elementData，一般会有一些预留的空间，有一个整数 size 记录实际的元素个数。elementData 会随着实际元素个数的增多而重新分配，而 size 则始终记录实际的元素个数。 2、add(E e) 方法源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean add(E e) &#123; // 首先调用 ensureCapacityInternal 确保数组容量是够的 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;------------------private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;-----------------private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;-----------------private void ensureExplicitCapacity(int minCapacity) &#123; // modCount 表示内部的修改次数，modCount++ 当然就是增加修改次数 modCount++; // overflow-conscious code 这里指整数运算超出其取值范围的情况 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;----------------private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 右移一位相当于除 2，所以，newCapacity 相当于 oldCapacity 的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 新建一个数组，将原先的数据拷贝到新的数组中 elementData = Arrays.copyOf(elementData, newCapacity);&#125;---------------private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 3、remove(int index) 方法源码解析12345678910111213141516171819public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;---------------private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 4、迭代foreach 适用于各种容器，比较通用。其背后的实现原理是，编译器会将 foreach 转换为类似如下代码：12345678910111213141516171819202122232425// 原先代码public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String s : list) &#123; System.out.println(s); &#125; &#125;&#125;// 编译后的 class 代码public class Test &#123; public Test() &#123; &#125; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList(); Iterator var2 = list.iterator(); while(var2.hasNext()) &#123; String s = (String)var2.next(); System.out.println(s); &#125; &#125;&#125; 迭代相关的源码：1234567891011121314// ArrayList 实现了 Iterable 接口，Iterable 表示可迭代的public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125;--------------// Iterable 中的 iterator 方法返回一个实现了 Iterator 接口的对象public interface Iterator&lt;E&gt; &#123; // hasNext() 判断是否还有元素未访问 boolean hasNext(); // next() 返回下一个元素 E next(); // remove() 删除最后返回的元素 void remove();&#125; 所以，只要对象实现了 Iterable 接口，就可以使用 foreach 语法，编译器会转换为调用 Iterable 和 Iterator 接口的方法。 5、Iterable &amp; Iterator Iterable 表示对象可以被迭代，它有一个方法 iterator()，返回 Iterator 对象，实际通过 Iterator 接口的方法进行遍历。 如果对象实现了 Iterable，就可以使用 foreach 语法。 类可以不实现 Iterable，也可以创建 Iterator 对象。 6、除了 iterator()，ArrayList 还提供了两个返回 Iterator 接口的方法：public ListIterator listIterator()public ListIterator listIterator(int index) ListIterator 扩展了 Iterator 接口，增加了一些方法，向前遍历、添加元素、修改元素、返回索引位置等。12345678public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void set(E e); void add(E e);&#125; listIterator() 方法返回的迭代器从 0 开始，而 listIterator(int index) 方法返回的迭代器从指定位置 index 开始。 7、迭代器的陷阱关于迭代器，有一种常见的误用，就是在迭代的中间调用容器的删除方法。这时候一般都会抛出 java.util.ConcurrentModificationException 异常。12345678// 调用容器的 remove 方法，会产生 ConcurrentModificationExceptionpublic void remove(ArrayList&lt;Integer&gt; list)&#123; for(Integer a : list)&#123; if(a&lt;=100)&#123; list.remove(a); &#125; &#125;&#125; 因为迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。 123456789// 而使用迭代器的 remove 方法，则不会产生异常public static void remove(ArrayList&lt;Integer&gt; list)&#123; Iterator&lt;Integer&gt; it = list.iterator(); while(it.hasNext())&#123; if(it.next()&lt;=100)&#123; it.remove(); &#125; &#125;&#125; 8、迭代器的实现原理 —— ArrayList 中 iterator 方法的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;--------------// Itr 是 ArrayList 的一个成员内部类，实现了 Iterator 接口private class Itr implements Iterator&lt;E&gt; &#123; // 表示下一个要返回的元素位置 int cursor; // index of next element to return // 表示最后一个被返回元素的索引位置，-1 表示没有返回过任何元素或者被删除了 int lastRet = -1; // index of last element returned; -1 if no such // expectedModCount 期望的修改次数，初始化为外部类当前的修改次数 modCount int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; // 每次迭代都去检查预期的 ModCount 和 现在的 ModCount 是否一致 checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 刚才判断 i &lt; size 这会 i &gt; 数组 length，中间数组结构发生改变 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; // 调用了 ArrayList 的 remove 方法，注意这里删除的是最后一个返回的元素的索引位置！！！ ArrayList.this.remove(lastRet); // 删除元素以后，后面的元素就会顶上来，所以指示下一个元素为被删除位置上的元素 cursor = lastRet; // 最后一个返回的元素删了，不存在了，所以 -1 表示 lastRet = -1; // 修改 expectedModCount，只有这样迭代的时候才不会抛异常 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;-------------- 每次发生结构性变化的时候 modCount 都会增加，而每次迭代器操作的时候都会检查 expectedModCount 是否与 modCount 相同，这样就能检测出结构性变化。 注意：使用 iterator 的 remove 方法前，必须先调用 next，从而为 lastRet 赋上正确的值，要不然是默认值 0，输出的结果很可能就是错的。而且循环删除的时候，第一次删除成功以后 lastRet 的值为 -1，再删的时候会抛异常 java.lang.IllegalStateException。 9、迭代器的好处迭代器语法更为通用，它适用于各种容器类。迭代器表示的是一种关注点分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个 Iterator 接口的引用，不需要关注数据的实际组织方式，可以使用一致和统一的方式进行访问。而提供 Iterator 接口的代码了解数据的组织方式，可以提供高效的实现。从封装的思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口。 10、Java 的各种容器类有一些共性的操作，这些共性以接口的方式体现，Iterable 接口就是如此。此外，ArrayList 还实现了三个主要的接口 Collection, List 和 RandomAccess。 11、Collection 接口Collection 表示一个数据集合，数据间没有位置或顺序的概念。boolean retainAll(Collection&lt;?&gt; c); retainAll 只保留参数容器中的元素，其他元素会进行删除。 有一个抽象类 AbstractCollection 对 Collection 接口中的很多方法都提供了默认实现，实现的方式就是利用迭代器方法逐个操作。ArrayList 继承了 AbstractList，而 AbstractList 又继承了 AbstractCollection，ArrayList 对其中一些方法进行了重写，以提供更为高效的实现。 12、List 表示有顺序或位置的数据集合，它扩展了 Collection。 13、RandomAccess 接口RandomAccess 是一个标记接口，是一个没有任何代码的接口，用于声明类的一种属性。 实现了 RandomAccess 接口的类表示可以随机访问，可随机访问就是具备类似数组那样的特性，数据在内存是连续存放的，根据索引值就可以直接定位到具体的元素，访问效率很高。 有没有声明 RandomAccess 有什么关系呢？主要用于一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现。 14、ArrayList 与 数组的相互转换1234567891011121314151617// 第一个方法返回是 Object 数组public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;-----------// 第二个方法返回对应类型的数组，如果参数数组长度足以容纳所有元素，就使用该数组，否则就新建一个数组@SuppressWarnings("unchecked")public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); // 如果指定的数组能容纳队列，并有剩余的空间（即数组的元素比队列多），那么会将数组中紧接 collection 尾部的元素设置为 null。（仅在调用者知道列表中不包含任何 null 元素时才能用此方法确定列表长度）。 if (a.length &gt; size) a[size] = null; return a;&#125; 15、Arrays 中有一个静态方法 asList 可以返回对应数组的 List。12345678public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125;--------// Arrays 类中的 ArrayList 静态内部类private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123;......&#125; 需要注意的是，这个方法返回的 List，它的实现类并不是真正的 ArrayList，而是 Arrays 类的一个内部类，在这个内部类的实现中，内部用的的数组就是传入的数组，没有拷贝，也不会动态改变大小，所以对数组的修改也会反映到 List 中。对 List 调用 add/remove 方法会抛出 java.lang.UnsupportedOperationException 异常，因为内部类中根本就不存在这些方法。 要使用 ArrayList 完整的方法，应该新建一个 ArrayList：List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(i)); 16、对于 ArrayList，它的特点是：内部采用动态数组实现，这决定了： 可以随机访问，按照索引位置进行访问效率很高，效率是 O(1)。 除非数组已排序，否则按照内容查找元素效率比较低，具体是 O(N)。 添加元素的效率还可以，重新分配和拷贝数组的开销被平摊了，具体来说，添加 N 个元素的效率为 O(N)。 插入和删除元素的效率比较低，因为需要移动元素，具体为 O(N)。 参考博客Java编程的逻辑 - 剖析 ArrayList]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(六)]]></title>
    <url>%2F2018%2F08%2F19%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(六) —— 显式锁 ReentrantLock 锁相关注意：在学习显示锁的时候要跟 synchronized 锁对比的学，synchronized 锁是由 JVM 去实现的，而显示锁是由我们来实现的，但是它们的功能都很类似，都可以对比着来学的。线程也会去争夺显示锁，争夺不到的时候也可能会阻塞，当前线程也会被放到等待队列中。 1、Java 并发包中的显式锁接口和类位于包 java.util.concurrent.locks 下，主要接口和类有： 锁接口 Lock，主要实现类是 ReentrantLock。读写锁接口 ReadWriteLock，主要实现类是 ReentrantReadWriteLock。 相比 synchronized，显式锁支持以非阻塞方式获取锁、可以响应中断、可以限时，这使得它灵活的多。 2、可重入锁 ReentrantLockLock 接口的主要实现类是 ReentrantLock，它的基本用法 lock/unlock 实现了与 synchronized 一样的语义，包括： 可重入，一个线程在持有一个锁的前提下，可以继续获得该锁。可以解决竞态条件问题。可以保证内存可见性。 public ReentrantLock(boolean fair)参数 fair 表示是否保证公平，不指定的情况下，默认为 false，表示不保证公平。所谓公平是指，等待时间最长的线程优先获得锁。保证公平会影响性能，一般也不需要，所以默认不保证，synchronized 锁也是不保证公平的。 使用显式锁，一定要记得调用 unlock。 一般而言，应该将 lock 之后的代码包装到 try 语句内，在 finally 语句内释放锁。 3、ReentrantLock 的实现原理在最底层，它依赖于 CAS 方法，另外，它依赖于类 LockSupport 中的一些方法。 LockSupport 锁相关4、类 LockSupport 也位于包 java.util.concurrent.locks 下。public static void park() park 方法使得当前线程放弃 CPU，进入等待状态(WAITING)，操作系统不再对它进行调度，只有其他线程对它调用了 unpark，unpark 需要指定一个线程，unpark 会使之恢复可运行状态。 LockSupport.park() 不同于 Thread.yield()，yield 只是告诉操作系统可以先让其他线程运行，但自己依然是可运行状态，而 park 会放弃调度资格，使线程进入 WAITING 状态。park 是响应中断的，当有中断发生时，park 会返回，线程的中断状态会被设置。另外，需要说明一下，park 可能会无缘无故的返回，程序应该重新检查 park 等待的条件是否满足。 park/unpark 方法的底层实现调用了 Unsafe 类中的对应方法，Unsafe 类最终调用了操作系统的 API，从程序员的角度，我们可以认为 LockSupport 中的这些方法就是基本操作。 AQS 相关AQS：AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等），JUC 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。AQS 解决了实现同步器时涉及到的大量细节问题，例如获取同步状态、FIFO 同步队列。在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。AQS 的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。AQS 的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。AbstractQueuedSynchronizer 为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件，等等）提供一个框架。 5、AQS (AbstractQueuedSynchronizer)利用 CAS 和 LockSupport 提供的基本方法，就可以用来实现 ReentrantLock 了。但 Java 中还有很多其他并发工具，如 ReentrantReadWriteLock、Semaphore、CountDownLatch，它们的实现有很多类似的地方，为了复用代码，Java 提供了一个抽象类 AbstractQueuedSynchronizer，我们简称为 AQS。 用于实现锁时，AQS 可以保存锁的当前持有线程，提供了方法进行查询和设置： private transient Thread exclusiveOwnerThread;protected final void setExclusiveOwnerThread(Thread t);protected final Thread getExclusiveOwnerThread(); AQS 内部维护了一个等待队列，借助 CAS 方法实现了无阻塞算法进行更新。等待队列是 FIFO 先进先出，只有前一个节点的状态为 SIGNAL 时，当前节点的线程才能被挂起。子类重写 tryAcquire 和 tryRelease 方法通过 CAS 指令修改状态变量 state。 6、保证公平整体性能比较低，低的原因不是这个检查慢，而是会让活跃线程得不到锁，进入等待状态，引起上下文切换，降低了整体的效率，通常情况下，谁先运行关系不大，而且长时间运行，从统计角度而言，虽然不保证公平，也基本是公平的。 需要说明是，即使 fair 参数为 true，ReentrantLock 中不带参数的 tryLock 方法也是不保证公平的，它不会检查是否有其他等待时间更长的线程。 7、ReentrantLock 对比 synchronized相比 synchronized，ReentrantLock 可以实现与 synchronized 相同的语义，但还支持以非阻塞方式获取锁、可以响应中断、可以限时等，更为灵活。不过，synchronized 的使用更为简单，写的代码更少，也更不容易出错。 synchronized 代表一种声明式编程，程序员更多的是表达一种同步声明，由 Java 系统负责具体实现，程序员不知道其实现细节，显式锁代表一种命令式编程，程序员实现所有细节。 声明式编程的好处除了简单，还在于性能，在较新版本的 JVM 上，ReentrantLock 和 synchronized 的性能是接近的，但 Java 编译器和虚拟机可以不断优化 synchronized 的实现，比如，自动分析 synchronized 的使用，对于没有锁竞争的场景，自动省略对锁获取/释放的调用。 8、显式锁 ReentrantLock 使用 CAS、LockSupport 和 AQS 实现的。 9、总结：能用 synchronized 就用 synchronized，不满足要求，再考虑 ReentrantLock。 参考博客Java编程的逻辑 - 显式锁深入浅出 Java 同步器 AQS深入学习 Java 同步器 AQS]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(五)]]></title>
    <url>%2F2018%2F08%2F17%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(五) —— 原子变量和 CAS 原子变量相关1、Java 并发包中的基本原子变量类型有： AtomicBoolean：原子 Boolean 类型AtomicInteger：原子 Integer 类型AtomicLong：原子 Long 类型AtomicReference：原子引用类型 针对 Integer, Long 和 Reference 类型，还有对应的数组类型： AtomicIntegerArrayAtomicLongArrayAtomicReferenceArray 为了便于以原子方式更新对象中的字段，还有如下的类： AtomicIntegerFieldUpdaterAtomicLongFieldUpdaterAtomicReferenceFieldUpdater AtomicReference 还有两个类似的类，在某些情况下更为易用： AtomicMarkableReferenceAtomicStampedReference 2、对于 char, short, float, double 类型的原子变量，可以转为 int/long，然后使用 AtomicInteger 或 AtomicLong。eg：float 类型和 int 类型互相转换：12public static int floatToIntBits(float value)public static float intBitsToFloat(int bits); 3、之所以称为原子变量，是因为其包含一些以原子方式实现组合操作的方法。这些方法的实现都依赖另一个 public 方法：public final boolean compareAndSet(int expect, int update)比较并设置。该方法以原子方式实现了如下功能：如果当前值等于 expect，则更新为 update，否则不更新，如果更新成功，返回 true，否则返回 false。 AtomicInteger 源码解析：12345678910111213141516171819public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; // 用 volatile 关键字保证获取到的当前值是内存中的最新值 private volatile int value; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; // unsafe 中的 compareAndSwapInt 方法，用 native 声明，该方法封装了底层操作系统的硬件级别的原子操作 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);&#125; 什么是 unsafe 呢？Java 语言不像 C，C++ 那样可以直接访问底层操作系统，但是 JVM 为我们提供了一个后门，这个后门就是 unsafe。unsafe 为我们提供了硬件级别的原子操作。 至于 valueOffset 对象，是通过 unsafe.objectFieldOffset 方法得到，它是一个 native 声明的方法，所代表的是 AtomicInteger 对象的成员变量 value 在内存中的偏移量。我们可以简单地把 valueOffset 理解为 value 变量的内存地址。 CAS 的底层实现？1、用 volatile 关键字保证获取到的 value 当前值是内存中的最新值。2、使用静态代码块在类初始化的时候就获取到某个对象的成员变量 value 在内存中的偏移量 valueOffset，可以简单的理解为 value 变量的内存地址。3、compareAndSwapInt 是 native 声明的方法，封装了底层操作系统的硬件级别的原子操作。4、所谓的自旋操作实际上就是在一个死循环中不断的调用操作系统硬件级别的原子操作，直到成功为止。说到底，正是因为 unsafe 该方法封装了底层操作系统的硬件级别的原子操作，例如：compareAndSwapInt，才能有 Java 的 CAS。 什么是 ABA 问题？如何解决？所谓 ABA 问题，就是一个变量的值从 A 改成了 B，又从 B 改成了 A。虽然表面上看，某块内存里的值没有改变，但是实际上此 A 非彼 A。但是在使用 CAS 进行更新的时候，会认为两个 A 是同一个 A，从而产生问题。「当一个值从 A 更新成 B，又更新会 A，普通 CAS 机制会误判通过检测。利用版本号比较可以有效解决 ABA 问题。」 要想解决 ABA 问题，本质上就是要区分此 A 非彼 A。例如：给 A 加个版本号。真正要做到严谨的 CAS 机制，在 Compare 阶段不仅要比较期望值和地址中的实际值，还要比较变量的版本号是否一致。在 Java 当中，AtomicStampedReference 类 和 AtomicMarkableReference 类就实现了用版本号做比较的 CAS 机制。 4、synchronized VS CASsynchronized 是悲观的，它假定更新很可能冲突，所以先获取锁，得到锁后才更新。原子变量的更新逻辑是乐观的，它假定冲突比较少，但使用 CAS 更新，也就是进行冲突检测，如果确实冲突了，那也没关系，继续尝试就好了。 synchronized 代表一种阻塞式算法，得不到锁的时候，进入锁等待队列，等待其他线程唤醒，有上下文切换开销。原子变量的更新逻辑是非阻塞式的，更新冲突的时候，它就重试，不会阻塞，不会有上下文切换开销。 原子变量是比较简单的，但对于复杂一些的数据结构和算法，非阻塞方式往往难于实现和理解，幸运的是，Java 并发包中已经提供了一些非阻塞容器。 ConcurrentLinkedQueue 和 ConcurrentLinkedDeque：非阻塞并发队列。ConcurrentSkipListMap 和 ConcurrentSkipListSet：非阻塞并发 Map 和 Set。 5、AtomicReference 用来以原子方式更新复杂类型，它有一个类型参数，使用时需要指定引用的类型。 原子数组方便以原子的方式更新数组中的每个元素。public AtomicIntegerArray(int[] array) 注意：该方法接受一个已有的数组，但不会直接操作该数组，而是会创建一个新数组，只是拷贝参数数组中的内容到新数组。 FieldUpdater 方便以原子方式更新对象中的字段，字段不需要声明为原子变量，FieldUpdater 是基于反射机制实现的。 CAS 相关1、什么是 CAS？CAS 是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换。CAS 机制当中使用了 3 个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。 2、CAS 机制的缺点？CAS 虽然没有上下文切换了，但却是在消耗 CPU 不停的自旋，即 CPU 不停的重新计算。CAS 机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。ABA 问题。 3、CAS 的底层实现？什么是 unsafe 呢？Java 语言不像 C，C++ 那样可以直接访问底层操作系统，但是 JVM 为我们提供了一个后门，这个后门就是 unsafe。unsafe 为我们提供了硬件级别的原子操作。unsafe 是 Sun 的私有实现，从名字看，表示的也是”不安全”，一般应用程序不应该直接使用。原理上，一般的计算机系统都在硬件层次上直接支持 CAS 指令，而 Java 的实现都会利用这些特殊指令。从程序的角度看，我们可以将 compareAndSet 视为计算机的基本操作，直接接纳就好。 至于 valueOffset 对象，是通过 unsafe.objectFieldOffset 方法得到，所代表的是 AtomicInteger 对象 value 成员变量在内存中的偏移量。我们可以简单地把 valueOffset 理解为 value 变量的内存地址。 CAS 是 Java 并发包的基础，基于它可以实现高效的、乐观、非阻塞式数据结构和算法，它也是并发包中锁、同步工具和各种容器的基础。 123456789101112131415private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 4、CAS 中的 ABA 问题？所谓 ABA 问题，就是一个变量的值从 A 改成了 B，又从 B 改成了 A。即当一个值从 A 更新成 B，又更新会 A，普通 CAS 机制会误判通过检测。真正要做到严谨的 CAS 机制，我们在 Compare 阶段不仅要比较期望值 A 和地址 V 中的实际值，还要比较变量的版本号是否一致。在 Java 中，AtomicStampedReference 类就实现了用版本号做比较的 CAS 机制。ABA 是不是一个问题与程序的逻辑有关。 volatile 相关首先明确一点，volatile 修饰符并不是 Java 语言的首创，早在 C 和 C++ 当中就已经存在了。 注意：工作内存所做的修改不会立刻同步到主内存，所以可能会产生问题。 1、什么是 volatile 关键字？Java 内存模型简称 JMM（Java Memory Model）。线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。 volatile 关键字保证了用 volatile 修饰的变量对所有线程的可见性。可见性是指：当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。注意的是 volatile 只能保证变量的可见性，并不能保证变量的原子性。 volatile 保证可见性的特性，得益于 Java 语言的 先行发生原则（happens-before）。先行发生原则是指：在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。 2、什么是指令重排？指令重排是指JVM在编译Java代码的时候，或者 CPU 在执行 JVM 字节码的时候，对现有的指令顺序进行重新排序。指令重排是在字节码指令的层面进行重排序的。 指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。 3、什么是内存屏障？内存屏障（Memory Barrier）是一种 CPU 指令。内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使 CPU 或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。 内存屏障共分为四种类型： 1.LoadLoad 屏障抽象场景：Load1; LoadLoad; Load2Load1 和 Load2 代表两条读取指令。在 Load2 要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。 2.StoreStore 屏障抽象场景：Store1; StoreStore; Store2Store1 和 Store2 代表两条写入指令。在 Store2 写入执行前，保证 Store1 的写入操作对其它处理器可见。 3.LoadStore 屏障抽象场景：Load1; LoadStore; Store2在 Store2 被写入前，保证 Load1 要读取的数据被读取完毕。 4.StoreLoad 屏障抽象场景：Store1; StoreLoad; Load2在 Load2 读取操作执行前，保证 Store1 的写入对所有处理器可见。StoreLoad 屏障的开销是四种屏障中最大的。 4、volatile 如何使用内存屏障来保证变量在线程之间的可见性？在一个变量被 volatile 修饰后，JVM 会为我们做两件事：1.在每个 volatile 写操作前插入 StoreStore 屏障，在写操作后插入 StoreLoad 屏障。2.在每个 volatile 读操作前插入 LoadLoad 屏障，在读操作后插入 LoadStore 屏障。 5、volatile 只是保证，写的时候能够立刻从工作内存同步到主内存中，读的时候，一定读的是当前内存中的最新值，仅此而已。它不会保证原子性，如果 10 个线程同时读，它们都会读到内存中的最新值，但是，只会读一次，之后内存中的值改变了，就必须重新读了，重新读的时候，依然是当前时刻内存中的最新值。即 volatile 值负责它读的那一刻，读取到的是内存中的最新值，至于以后内存中的该值怎么变化，跟它已经没关系了。 参考博客什么是 CAS 机制？什么是 CAS 机制？(进阶篇)什么是 volatile 关键字？Java 编程的逻辑 - 原子变量和 CAS用户模式和内核模式]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(四)]]></title>
    <url>%2F2018%2F08%2F17%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(四) —— 线程的中断 1、在 Java 中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。 2、每个线程都有一个标志位，表示该线程是否被中断了。被中断了为 true，没有被中断或默认值为 false。 3、Thread 类定义了以下关于中断的方法： public boolean isInterrupted()：就是返回对应线程的中断标志位是否为 true。 public void interrupt()。 public static boolean interrupted() interrupted() 是静态方法，实际会调用 Thread.currentThread() 操作当前线程。返回当前线程的中断标志位是否为 true，但它还有一个重要的副作用，就是清空中断标志位，也就是说，连续两次调用 interrupted()，第一次返回的结果为 true，第二次一般就是 false「除非同时又发生了一次中断」。 4、线程对中断的反应interrupt() 对线程的影响与线程的状态和正在进行的 IO 操作有关，我们先主要考虑线程的状态： RUNNABLE：线程在运行或具备运行条件只是在等待操作系统调度。如果线程在运行中，且没有执行 IO 操作，interrupt() 只是会设置线程的中断标志位，没有任何其它作用。线程应该在运行过程中合适的位置检查中断标志位 WAITING/TIMED_WAITING：线程在等待某个条件或超时。在这些状态时，对线程对象调用 interrupt() 会使得该线程抛出 InterruptedException，需要注意的是，抛出异常后，中断标志位会被清空，而不是被设置。 BLOCKED：线程在等待锁，试图进入同步块。如果线程在等待锁，对线程对象调用 interrupt() 只是会设置线程的中断标志位，线程依然会处于 BLOCKED 状态，也就是说，interrupt() 并不能使一个在等待锁的线程真正”中断”。在使用 synchronized 关键字获取锁的过程中不响应中断请求，这是 synchronized 的局限性。 如果这对程序是一个问题，应该使用显式锁，它支持以响应中断的方式获取锁。 NEW/TERMINATED：线程还未启动或已结束。如果线程尚未启动 (NEW)，或者已经结束 (TERMINATED)，则调用 interrupt() 对它没有任何效果，中断标志位也不会被设置。 5、捕获到 InterruptedException，通常表示希望结束该线程，线程大概有两种处理方式： 1.向上传递该异常，这使得该方法也变成了一个可中断的方法，需要调用者进行处理。 2.有些情况，不能向上传递异常，比如 Thread 的 run 方法，它的声明是固定的，不能抛出任何受检异常，这时，应该捕获异常，进行合适的清理操作，清理后，一般应该调用 Thread的 interrupt 方法设置中断标志位，使得其他代码有办法知道它发生了中断。 6、IO 操作如果线程在等待 IO 操作，尤其是网络 IO，则会有一些特殊的处理： 如果 IO 通道是可中断的，即实现了 InterruptibleChannel 接口，则线程的中断标志位会被设置，同时，线程会收到异常 ClosedByInterruptException。 如果线程阻塞于 Selector 调用，则线程的中断标志位会被设置，同时，阻塞的调用会立即返回。 7、InputStream 的 read 调用，该操作是不可中断的，如果流中没有数据，read 会阻塞 (但线程状态依然是 RUNNABLE)，且不响应 interrupt()，与 synchronized 类似，调用 interrupt() 只会设置线程的中断标志，而不会真正”中断”它。 8、如何正确地取消/关闭线程？interrupt 方法不一定会真正”中断”线程，它只是一种协作机制，如果不明白线程在做什么，不应该贸然的调用线程的 interrupt 方法，以为这样就能取消线程。 对于以线程提供服务的程序模块而言，它应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用者应该调用这些方法而不是直接调用 interrupt。 在 Java 中如何取消/关闭线程，主要依赖的技术是中断，但它是一种协作机制，不会强迫终止线程。作为线程的实现者，应该提供明确的取消/关闭方法，并用文档描述清楚其行为，作为线程的调用者，应该使用其取消/关闭方法，而不是贸然调用 interrupt。 参考博客Java 编程的逻辑 - 线程的中断]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(三)]]></title>
    <url>%2F2018%2F08%2F16%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(三) —— 线程的基本协作机制 1、Java 中多线程协作的基本机制 wait/notify。 2、常见的线程协作场景： 生产者/消费者协作模式 同时开始 等待结束 异步结果 集合点 3、Java 在 Object 类中，定义了一些线程协作的基本方法，使得每个对象都可以调用这些方法，这些方法有两类，一类是 wait，另一类是 notify。 4、wait() 方法的原理？每个对象都有一把锁和一个锁等待队列，一个线程在进入 synchronized 代码块时，会尝试获取锁，获取不到的话会把当前线程加入到锁等待队列中。除了用于锁的等待队列，每个对象还有另一个等待队列，表示条件队列，该队列用于线程间的协作。调用 wait 就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，这个条件它自己改变不了，需要其他线程改变。当其他线程改变了条件后，应该调用 Object 的 notify 方法。wait 虽然是在 synchronzied 方法内，但调用 wait 时，线程会释放对象锁。 而 notify 做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll 和 notify 的区别是，它会移除条件队列中所有的线程并全部唤醒。wait 的具体过程是： 1.把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为 WAITING 或 TIMED_WAITING。 2.等待时间到或被其他线程调用 notify/notifyAll 从条件队列中移除，这时，要重新竞争对象锁。 如果能够获得锁，线程状态变为 RUNNABLE，并从 wait 调用中返回。 否则，该线程加入对象锁等待队列，线程状态变为 BLOCKED，只有在获得锁后才会从 wait 调用中返回。 3.线程从 wait 调用中返回后，不代表其等待的条件就一定成立了，它需要重新检查其等待的条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class WaitThread extends Thread&#123; // 协作的条件变量是 fire private volatile boolean fire = false; @Override public void run() &#123; try &#123; synchronized (this) &#123; while (!fire) &#123; System.out.println("wait......before"); wait(); System.out.println("wait......after"); &#125; &#125; System.out.println("fired"); &#125; catch (InterruptedException e) &#123; &#125; &#125; // 两个线程都要访问协作的变量 fire，容易出现竞态条件，所以相关代码都需要被 synchronized 保护 public synchronized void fire() &#123; this.fire = true; notify(); &#125; public static void main(String[] args) throws InterruptedException &#123; WaitThread t = new WaitThread(); /** * 线程启动以后，开始了 run 方法的执行，首先获取 WaitThread 的对象锁 * 然后执行 while 循环，由于「fire = false」，所以进入 while 循环体 * 执行 wait 方法，即放弃对象锁，并把单前线程 t 加入到条件等待队列中，然后线程阻塞在了 wait 方法这，不再向下执行 */ t.start(); Thread.sleep(1000); System.out.println("fire"); /** * 主线程执行 fire 方法，干了两件事：把 fire 设置为 true，调用了 WaitThread 对象的 notify 方法 * 一旦调用 notify 方法，等待的 t 线程就被唤醒了，并且把 t 线程从条件等待队列中移除 * 接下来，t 线程要尝试去获取 WaitThread 对象的锁，但是现在这把锁被主线程在 fire 方法中占用了，只有等到主线程释放它才可以获得到 * 由于 t 获取锁没有获取到，所以 t 线程加入到了 WaitThread 对象的锁等待队列中了，挪坑了！ * 当主线程释放锁以后，t 线程终于抢到了锁，然后 t 线程从 wait 调用中返回了，开始执行 wait 调用下面的语句 「System.out.println("wait......after");」 * 然后开始执行下一轮 while 循环，发现条件变了，所以不再进入 while 循环，直接执行「System.out.println("fired");」，然后 t 线程结束使命 */ t.fire(); &#125;&#125; 5、notify() 方法的原理？notify 做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒。调用 notify 会把在条件队列中等待的线程唤醒并从队列中移除，但它「这里指主线程」不会释放对象锁，也就是说，只有在包含 notify 的 synchronzied 代码块执行完后，等待的线程才会从 wait 调用中返回。 6、wait/notify 方法只能在 synchronized 代码块内被调用，如果调用 wait/notify 方法时，当前线程没有持有对象锁，会抛出异常 java.lang.IllegalMonitorStateException。 那么问题来了：为什么wait(),notify(),notifyAll() 必须在同步方法/代码块中调用？因为 wait() 和 notify() 之间的竞态条件导致必须在同步方法/代码块中调用，因为 wait 和 notify 都需要访问和操作对象的等待队列，wait 入队，notify 出队，它们对等待队列的访问顺序是敏感的，所以需要放到同步代码中，以避免竞态条件问题。 在 Java 中，所有对象都能够被作为「监视器即 Monitor」，而监视器是指：一个拥有 一个独占锁，一个入口队列和一个等待队列的 实体。对于对象的同步方法来说，在任意时刻有且仅有一个拥有该对象独占锁的线程能够调用它们。eg：一个同步方法是独占的。如果在线程调用某一对象的同步方法时，对象的独占锁被其他线程拥有，那么当前线程将处于阻塞状态，并添加到对象的入口队列中。 当一个线程正在某一个对象的同步方法中运行时调用了这个对象的 wait() 方法，那么这个线程将释放该对象的独占锁并被放入这个对象的等待队列。注意，wait() 方法强制当前线程释放对象锁。这意味着在调用某对象的 wait() 方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的 wait() 方法。 当某线程调用某对象的 notify() 或 notifyAll() 方法时，任意一个或者所有在该对象的等待队列中的线程，将被转移到该对象的入口队列。 调用 wait() 方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用 notify()或notifyAll() 方法的原因通常是，调用线程希望告诉其他等待中的线程「特殊状态已经被设置」。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。 假设 wait(),notify(),notifyAll() 方法不需要加锁就能够被调用。此时消费者线程调用 wait() 正在进入状态变量的等待队列(可能还未进入)。在同一时刻，生产者线程调用 notify() 方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞「因为该线程还没有进入到等待队列中，但是 notify 开始检查等待队列是否有线程了，检查发现没有，notify 失效，这时该线程进入到了等待队列，可能永远错过被唤醒的机会」。因此，对象的 wait(),notify(),notifyAll() 方法必须在该对象的同步方法或同步代码块中被互斥地调用。 简单总结一下，wait/notify 方法看上去很简单，但往往难以理解 wait 等的到底是什么，而 notify 通知的又是什么，我们需要知道，它们与一个共享的条件变量有关，这个条件变量是程序自己维护的，当条件不成立时，线程调用 wait 进入条件等待队列，另一个线程修改了条件变量后调用 notify，调用 wait 的线程唤醒后需要重新检查条件变量。从多线程的角度看，它们围绕共享变量进行协作，从调用 wait 的线程角度看，它阻塞等待一个条件的成立。 我们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心。 上面的代码的共享变量是 WaitThread 对象的 fire 变量，结束等待的条件是 fire 的值为 true，这是面代码协作的核心。但是，协作的核心虽然是 fire 变量，但是作用的却是 WaitThread 整个对象，是通过这个对象的条件队列进行协作的，而不是这个对象的某个变量。 7、Java 中每个对象只能有一个条件等待队列，这是 Java wait/notify 机制的局限性，这使得对于等待条件的分析变得复杂。 8、Java 提供了专门的阻塞队列实现，包括： 接口 BlockingQueue 和 BlockingDeque 基于数组的实现类 ArrayBlockingQueue 基于链表的实现类 LinkedBlockingQueue 和 LinkedBlockingDeque 基于堆的实现类 PriorityBlockingQueue 9、Java 中线程间协作的基本机制 wait/notify，协作关键要想清楚协作的共享变量和条件是什么。 参考博客Java 编程的逻辑 - 线程的基本协作机制 (上)Java 编程的逻辑 - 线程的基本协作机制 (下)为什么 wait(),notify(),notifyAll() 必须在同步方法/代码块中调用？为什么 wait 和 notify 必须在同步方法或同步块中调用]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(二)]]></title>
    <url>%2F2018%2F08%2F15%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(二) —— synchronized 关键字 1、Java 中的每一个对象都可以作为锁。具体表现为以下三种形式： 对于普通同步方法，锁是当前实例对象。对于静态同步方法，锁是当前类的 Class 对象。对于同步代码块，锁是 synchronized 括号里配置的对象。 synchronized 可以用于修饰「普通方法、静态方法、代码块」。 2、synchronized 用于「实例方法」的时候？synchronized 用于「实例方法」的时候到底做了什么呢？看上去，synchronized 使得同时只能有一个线程执行实例方法，但这个理解是不确切的。多个线程是可以同时执行同一个 synchronized 实例方法的，只要它们「访问的对象」是不同的。 synchronized 实例方法实际保护的是 同一个对象的方法调用，确保同时只能有一个线程执行。 再具体来说，synchronized 实例方法保护的是当前实例对象，即 this，this 对象有 一个锁和一个等待队列，锁只能被一个线程持有，其他试图获得同样锁的线程需要等待，加入到等待队列中。 执行 synchronized 实例方法的过程大概如下： 1.尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒。2.执行实例方法体代码。3.释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的，不保证公平性。 当前线程不能获得锁的时候，它会加入等待队列等待，线程的状态会变为 BLOCKED。 3、synchronized 保护的是对象而非代码，只要访问的是同一个对象的 synchronized 方法，即使是不同的代码，也会被同步顺序访问。 synchronized 方法不能防止非 synchronized 方法被同时执行。一般在保护变量时，需要在所有访问该变量的方法上加上 synchronized。 4、synchronized 用于「静态方法」的时候？前面我们说，synchronized 保护的是对象，对实例方法，保护的是当前实例对象 this，对静态方法，保护的是哪个对象呢？是类对象，即「类名称.class」，实际上，每个对象都有一个锁和一个等待队列，类对象也不例外。 synchronized 静态方法和 synchronized 实例方法保护的是不同的对象，不同的两个线程，可以同时，一个执行 synchronized 静态方法，另一个执行 synchronized 实例方法。 5、synchronized 用于「代码块」的时候？synchronized 括号里面的就是保护的对象，对于实例方法，就是 this，{} 里面是同步执行的代码。synchronized 同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。 6、synchronized 之可重入性synchronized 有一个重要的特征，它是可重入的，也就是说，对同一个执行线程，它在获得了锁之后，在调用其他需要 同样锁 的代码时，可以直接调用。 可重入是通过记录锁的持有线程和持有数量来实现的，当调用被 synchronized 保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。 7、synchronized 之内存可见性synchronized 除了保证原子操作外，它还有一个重要的作用，就是保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据。 不过，如果只是为了保证内存可见性，使用 synchronzied 的成本有点高，有一个更轻量级的方式，那就是给变量加修饰符 volatile。加了 volatile 之后，Java 会在操作对应变量时插入特殊的指令，保证读写到内存最新值，而非缓存的值。 8、synchronized 之解决死锁使用 synchronized 或者其他锁，要注意死锁。关于死锁解决，首先，应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁。使用显式锁接口 Lock，它支持尝试获取锁和带时间限制的获取锁方法，使用这些方法 可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。 一旦出现了死锁，Java 不会主动处理，借助一些工具，我们可以发现运行中的死锁。eg：Java 自带的 jstack 命令会报告发现的死锁。 9、同步容器Collections 的一些方法，它们可以返回线程安全的同步容器，它们是给所有容器方法都加上 synchronized 来实现安全的。这里线程安全针对的是容器对象，指的是当多个线程并发访问同一个容器对象时，不需要额外的同步操作，也不会出现错误的结果。 但是，加了 synchronized，所有方法调用变成了原子操作，客户端在调用时，是不是就绝对安全了呢？不是的，至少有以下情况需要注意： 复合操作，比如先检查再更新。对于 putIfAbsent 方法，虽然 get、put 方法是同步的，但是可能有多个线程都执行了检查者一步，然后都调用 put 方法，破坏了 putIfAbsent 方法期望保持的语义。 伪同步，即同步了不同的对象。如果给 putIfAbsent 方法加上 synchronized 关键字，虽然 putIfAbsent 方法是同步方法了，但是，put 方法没有加呢，其他线程照样可以调用该方法进行 put，同步错对象了。解决办法是要么 EnhancedMap 中的所有方法都需要加上 synchronized，要么使用 map 作为锁。 迭代，对于同步容器对象，虽然单个操作是安全的，但迭代并不是。eg：创建一个同步 List 对象，一个线程修改 List，另一个遍历，会产生 ConcurrentModificationException 异常。如果在遍历的同时容器发生了结构性变化，就会抛出该异常，同步容器并没有解决这个问题，如果要避免这个异常，需要在遍历的时候给整个容器对象加锁。 123456789101112131415161718192021public class EnhancedMap &lt;K, V&gt; &#123; Map&lt;K, V&gt; map; public EnhancedMap(Map&lt;K,V&gt; map)&#123; this.map = Collections.synchronizedMap(map); &#125; public V putIfAbsent(K key, V value)&#123; V old = map.get(key); if(old!=null)&#123; return old; &#125; // 注意这里的 put 方法是下面即本类中定义的 put 方法，不是 map 中的 put 方法 map.put(key, value); return null; &#125; public void put(K key, V value)&#123; map.put(key, value); &#125;&#125; 11、并发容器同步容器的性能是比较低的，当并发访问量比较大的时候性能很差。所幸的是，Java 中还有很多专为并发设计的容器类，比如： CopyOnWriteArrayListConcurrentHashMapConcurrentLinkedQueueConcurrentSkipListSet 这些容器类都是线程安全的，但都没有使用 synchronized、没有迭代问题、直接支持一些复合操作、性能也高得多。 参考博客Java编程的逻辑 - 理解 synchronizedsynchronized 的可重入性]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 未解之谜]]></title>
    <url>%2F2018%2F08%2F15%2FJava%E6%9C%AA%E8%A7%A3%E4%B9%8B%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[记录 Java 学习过程中百思不得其解的问题 问题1：Thread 类的 join() 方法，到底释放对象锁吗？从 join() 的源码来看其调用了 wait() 方法，那么就是要释放对象锁，但是看到的好多博客却说它不会释放对象锁？求解！ 问题2：synchronized 锁住类对象的时候，到底锁住了些什么？为什么实例对象还可以正常使用？这个问题可以转化为，实例对象和类对象的区别？或者说它们都包含了些什么？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(一)]]></title>
    <url>%2F2018%2F08%2F14%2FJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 线程总结(一) —— 线程的基本概念 1、并发：在程序中创建线程来启动多条执行流，从而达到并发。 2、线程：表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。 3、Java 中有两种创建线程的方式，不管用哪种方式创建线程，都有以下特征： run() 方法是线程执行的主体，run() 方法也是线程执行的入口。线程只会执行 run() 方法里面的语句「包括被 run() 方法调用的语句」。 启动线程必须通过 Thread 对象的 start() 方法进行启动，线程启动以后就会去执行对应的 run() 方法。 4、在多线程中，当所有线程都执行完毕的时候，程序才会退出「这里的线程不包括 daemon 守护线程」。即：当整个程序中剩下的都是 daemo 线程的时候，程序就会退出。 5、Java 中线程有一个优先级的概念，这个优先级会被映射到操作系统中线程的优先级，优先级映射到操作系统中时，到底有没有用，有多大用，都是未知不可控的。优先级对操作系统而言更多的是一种建议和提示，开发中，不要过于依赖优先级。 6、线程的状态 7、什么是守护线程 daemon？它一般是其他线程的辅助线程，在它辅助的主线程退出的时候，它就没有存在的意义了。例如：在我们运行一个即使最简单的 「hello world」的程序时，实际上，Java 也会创建多个线程，除了 main 线程外，至少还有一个负责垃圾回收的线程，这个线程就是 daemo 线程，在 main 线程结束的时候，垃圾回收线程也会退出。 8、Thread 的 sleep 方法：让当前线程睡眠指定的时间。睡眠期间，线程会让出 cpu，但是不会放弃对象锁。 9、Thread 的 yield 方法：让当前线程让出 cup。调用该方法，是告诉操作系统的调度器，我现在不着急占用 CPU，你可以先让其他线程运行。不过这个也仅仅只是建议，调度器如何处理是不一定的。该方法可能会让出 CPU，让出 CPU 后，它自己进入到就绪队列，接着参与下一次的 CPU 竞争，有可能再次拿到 CPU，并且该方法是不释放对象锁的。 10、Thread 的 join 方法：让调用 join 的线程等待该线程结束。123456789101112public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(); t.start(); /** * main 线程调用 t.join() 方法 * 即调用 join 的线程是 main 线程 * 即让 main 线程等到 t 线程结束 */ t.join(); &#125;&#125; join 方法的本质是调用了 wait() 方法，由于使用 wait() 方法，那么必定有一个地方在 wait() 所等待的条件满足时，唤醒该线程。这个地方就是：当线程运行结束的时候，Java 系统调用 notifyAll 来通知。 11、在分析代码执行过程时，理解代码在被哪个线程执行是很重要的。要理清执行流、内存和程序代码之间的关系。 12、当多条执行流执行相同的程序代码时，每条执行流都有自己单独的栈，方法中的参数和局部变量都有自己的一份。 当多条执行流可以操作相同的变量时，可能会出现一些意料之外的结果。 13、什么竞态条件？所谓竞态条件「race condition」是指，当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确。 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。 解决竞态条件的方法有：使用 synchronized 关键字、使用显示锁、使用原子变量。 14、什么是内存可见性问题？多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到，甚至永远也看不到。 在计算机系统中，除了内存，数据还会被缓存在 CPU 的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或 CPU 缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，而稍后才会同步更新到内存中。在单线程的程序中，这一般不是个问题，但在多线程的程序中，尤其是在有多 CPU 的情况下，这就是个严重的问题。一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。 解决内存可见性的方法有：使用 volatile 关键字、使用 synchronized 关键字、使用显示锁。 15、线程的优点：充分利用多 CPU 的计算能力；充分利用硬件资源；在用户界面「GUI」应用程序中，保持程序的响应性；简化建模及 IO 处理。 16、线程的成本：需要消耗操作系统的资源；需要创建时间；线程调度和切换。 参考博客Java编程的逻辑——线程的基本概念Java 线程 Thread.join 方法解析竞态条件与临界区]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的加载]]></title>
    <url>%2F2018%2F08%2F13%2F%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031public class A &#123; private static A a1 = new A(); private static A a2 = new A(); static &#123; System.out.println("A 静态块"); &#125; &#123; System.out.println("A 构造块"); &#125; public A() &#123; System.out.println("A 构造方法"); &#125;&#125;----------------------------public class Test &#123; public static void main(String[] args) &#123; A a = new A(); &#125;&#125;---------------------------输出结果：A 构造块A 构造方法A 构造块A 构造方法A 静态块A 构造块A 构造方法 1234567891011121314151617181920212223242526272829303132public class B extends A&#123; static &#123; System.out.println("B 静态块"); &#125; &#123; System.out.println("B 构造块"); &#125; public B() &#123; System.out.println("B 构造方法"); &#125;&#125;-----------------------public class Test &#123; public static void main(String[] args) &#123; A a = new A(); &#125;&#125;----------------------输出结果：A 构造块A 构造方法A 构造块A 构造方法A 静态块B 静态块A 构造块A 构造方法B 构造块B 构造方法--------------------- 12345678910111213141516171819202122232425262728public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println("构造块"); &#125; static &#123; System.out.println("静态块"); &#125; public static void main(String[] args) &#123; B t = new B(); &#125;&#125;--------------静态块：用static申明，JVM加载类时执行，仅执行一次构造块：类中直接用&#123;&#125;定义，每一次创建对象时执行执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法静态块按照申明顺序执行，所以先执行publicstaticB t1 = newB();该语句创建对象，则又会调用构造块，输出构造块接着执行public static B t1 = new B();输出构造块再执行static&#123;System.out.println("静态块");&#125;输出静态块最后main方法执行，创建对象，输出构造块。 一个类的信息主要包括以下部分： 1.类变量（静态变量）2.类初始化代码3.类方法（静态方法）4.实例变量5.实例初始化代码6.实例方法7.父类信息引用 类初始化代码包括： 定义静态变量时的赋值语句 静态初始化代码块 实例初始化代码包括： 定义实例变量时的赋值语句 实例初始化代码块 构造方法 instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F12%2FJava%E7%B1%BB%E9%9B%86%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 类集总结(一) 什么是类集？类集实际上就是一个动态的对象数组，与一般的对象数组不同，类集中的对象内容可以任意扩充。类集是专门解决对象数组长度限制问题的，使用类集可以方便的向数组中增加任意多个数据。 类集框架主要接口参考博客https://blog.csdn.net/ljcITworld/article/details/52041836]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(二)]]></title>
    <url>%2F2018%2F08%2F10%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(二) 1、一般来说，程序的结构包含以下三种： 1.顺序结构2.选择结构3.循环结构：根据判断条件的成立与否，决定程序段落的执行次数，而这个程序段落就称为循环主体。 2、三目运算符：「变量 = 条件判断 ？ 表达式1 : 表达式2」；日常开发中，要善于利用三目运算符来减少代码量。 3、switch 语句 注意： break 表示退出整个 switch() 语句块，如果不写 break，则表示从第一个满足条件的 case 开始，之后的所有 case 中的语句都要执行，直到遇到 break 为止或 swithc() 语句块结束。所以使用时每个 case 包括 default 中都必须加上 break 语句。 12345678910111213141516171819/*** 表达式类型取值范围：* char、byte、short、int* Character、Byte、Short、Integer* String、enum*/switch (表达式) &#123; case 选择值1: 语句主体1; // break 表示退出整个 switch() 语句块 break; case 选择值2: 语句主体2; break; ...... default: 语句主体; break;&#125; 4、循环结构 while 循环，当事先不知道循环该执行多少次时使用。先判断，后循环。1234while (循环条件判断) &#123; 语句n; 循环条件更改;&#125; do…while 循环，也是用于事先未知循环执行次数的时候。先循环，后判断。 无论循环条件是否成立，至少都会执行一次循环主体。1234do &#123; 语句n; 循环条件更改;&#125; while (循环条件判断); for 循环：采用两个分号「;」，分隔了三条语句的形式。12345678910111213141516171819/*** for 循环执行流程：* 1、执行初始化指令* 2、检查循环条件是否为 true，如果为 false，跳转到第 6 步* 3、循环条件为真，执行循环体* 4、执行循环条件更改* 5、循环条件更改执行完后，跳转到第 2 步，即继续检查循环条件* 6、for循环后面的语句*/for (初始化「必须是一个声明」; 循环条件判断; 循环条件更改) &#123; 语句n;&#125;-------------------------for 循环变体「不推荐」-------------------------int i = 0;for (; i &lt; 10 ;) &#123; i ++;&#125; 4、break 语句循环中遇到 break 语句，则直接退出整个 for 循环，并且 break 之后的语句也不再执行。 5、continue 语句continue 语句可以强迫程序跳到循环的起始处，当程序运行到 continue 语句时，即会停止运行剩余的循环主体，而是回到循环的开始出继续运行。即：使用 continue 就是中断一次循环的执行。 参考博客强大的循环]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常总结]]></title>
    <url>%2F2018%2F08%2F08%2FJava%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java 异常总结 什么是异常？异常是导致程序中断运行的一种指令流。一旦产生异常之后，异常之后的语句并不会执行，而是直接结束程序，并将错误报告给用户。 异常处理格式注意：捕获更粗的异常要放在捕获更细的异常之后，否则程序编译的时候将出错。 Java 异常类的继承结构 Exception：是程序可以自己处理的异常Error：表示 JVM 错误，一般程序无法处理 Java 的异常处理机制每当异常产生之后，会在程序中产生一个异常类的实例化对象，之后使用此对象与 catch 中的异常类型相匹配，如果匹配成功，则执行 catch 中的内容，如果匹配不成功，则向下继续匹配，如果都无法成功，程序中出现中断执行的问题。 throws 与 throw 关键字 throws 只能在定义方法的时候使用，表示该方法不处理异常，而交给调用处进行处理 格式：public 返回值类型 方法名称(参数列表...) throws 异常类1,...,异常类n {} 注意：对于使用 throws 抛出非 RuntimeException 类型的方法，调用方在调用该方法的时候必须进行异常处理，否则编译时报错。如果主方法中使用了 throws 关键字，则表示一切的异常交给 JVM 进行处理，默认的处理方式也是使用 JVM 完成的。调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类，否则编译时报错。 throw throw 关键字的作用是在程序中抛出一个异常。抛出的时候抛出的是一个异常类的实例化对象。throw 总是出现在函数体中，用来抛出一个 Throwable 类型的异常。程序会在 throw 语句后立即终止，它后面的语句执行不到，然后在包含它的所有 try 块中「可能在上层调用函数中」从里向外寻找含有与其匹配的 catch 子句的 try 块。 格式：throw 异常类实例化对象 注意：throw 后面只能跟一个异常类实例化对象 Exception 与 RuntimeException Exception Exception 在程序中是必须使用 try…catch 进行处理，否则编译时报错 RuntimeException RuntimeException 可以不使用 try…catch 进行处理，但是如果有异常产生，则异常将由 JVM 进行处理。 Java 异常注意事项 try 块 try 块后可接零个或多个 catch 块 try 块后至多有一个 finally 块 必须在 try 之后添加 catch 或 finally 块 try 块后可同时接 catch 和 finally 块，但至少有一个块 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后 可嵌套 try-catch-finally 结构 在 try-catch-finally 结构中，可重新抛出异常 一个 try 块可能有多个 catch 块，当匹配到某个 catch 块中的异常类型时，则不会再执行其它 catch 块，转为执行匹配到的 catch 块中的代码 finally 块 当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行 在以下4种特殊情况下，finally 块不会被执行： 1.在 finally 语句块中发生了异常「即抛出了一个未处理的异常」2.在前面的代码中用了 System.exit(int status); 退出程序3.程序所在的线程死亡4.关闭 CPU「主要指：计算机断电、失火、遭遇病毒攻击等使得 CPU 停止运行」 try、catch、finally语句块的执行顺序 1.当 try 没有捕获到异常时：try 语句块中的语句逐一被执行，程序将跳过 catch 语句块，执行 finally 语句块和其后的语句 2.当 try 捕获到异常，catch 语句块里没有处理此异常的情况：当 try 语句块里的某条语句出现异常时，而没有处理此异常的 catch 语句块时，此异常将会抛给 JVM 处理，finally 语句块里的语句还是会被执行，但 finally 语句块后的语句不会被执行 3.当 try 捕获到异常，catch 语句块里有处理此异常的情况：在 try 语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到 catch 语句块，并与 catch 语句块逐一匹配，找到与之对应的处理程序，其他的 catch 语句块将不会被执行，而 try 语句块中，出现异常之后的语句也不会被执行，catch 语句块执行完后，执行 finally 语句块里的语句，最后执行 finally 语句块后的语句 try、catch、finally语句块中有 return 后的执行顺序12345678910111213141516171819202122232425262728293031public class Test &#123; // 当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行 public int test() &#123; try&#123; System.out.println("001"); // 异常发生跳转到 catch 块中执行代码，其后的所有代码均不再执行 int temp = 10 / 0; return 1; &#125;catch (Exception e) &#123; System.out.println("002"); // 在 try 块或 catch 块中遇到 return 语句时，先不着急返回，看看有没有 finally 块，有的话先执行 finally 块，没有则直接返回 return 2; &#125;finally &#123; System.out.println("003"); // 在执行 finally 块的时候直接返回，结束了方法，前面的 try 块或 catch 块均不会再执行 return 3; &#125; &#125; public static void main(String[] args) &#123; int result = new Test().test(); System.out.println(result); &#125;&#125;-------------------------------------程序运行结果：-------------------------------------0010020033 参考博客Java 常见异常及解释深入理解 Java 异常处理机制]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门总结(一)]]></title>
    <url>%2F2018%2F08%2F06%2FDocker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Docker 入门总结(一) —— Docker 入门教程 什么是 Linux 容器？Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。由于容器是进程级别的，相比虚拟机有很多优势。 什么是 Docker？Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组。 Docker 是服务器—-客户端架构。即 C/S 架构。命令行运行docker命令的时候，需要本机有 Docker 服务。 Docker 常用命令 启动 docker 服务：sudo service docker start 或 sudo systemctl start docker 关闭 docker 服务：sudo service docker stop 或 sudo systemctl stop docker 获取 image 文件：docker image pull [image 文件所在的组/image 文件的名字] 列出本机所有的 image 文件：docker image ls 或 docker images 运行 image 文件：docker container run [image 文件的名字]，注意这里是 container 不是 image 删除 image 文件：docker image rm [imageName] 删除 container 文件：docker container rm [containerID] 创建 image 文件：docker image build -t [imageName]，-t 用来指定 image 文件的名字 生成容器：docker container run -p 8000:3000 -it [imageName] /bin/bash 为本地的 image 标注用户名和版本：docker image tag [imageName] [username]/[repository]:[tag]，打 tag 以后需要重新构建一下 image 文件 发布 image 文件：docker image push [username]/[repository]:[tag] image 文件Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。 Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。 实例将 image 文件从仓库抓取到本地 docker image pull library/hello-world。docker image pull 是抓取 image 文件的命令。library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此可以写成 docker image pull hello-world。 抓取成功以后，就可以在本机看到这个 image 文件了 docker image ls。 运行这个 image 文件 docker container run [imageName]。docker container run 命令会从 image 文件，生成一个正在运行的容器实例。注意，docker container run 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。 输出这段提示以后，hello world 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统 docker container run -it ubuntu bash。对于那些不会自动终止的容器，必须使用 docker container kill 命令手动终止 docker container kill [containerID]。 终止运行的容器文件，依然会占据硬盘空间，可以使用 docker container rm 命令删除 docker container rm [containerID]。删除以后可以通过 docker container ls -a 或 docker ps -a 就会发现被删除的容器文件已经消失了。 Dockerfile 文件学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 首先，在项目的根目录下，新建一个文本文件 .dockerignore，表示排除指定文件或文件夹，不要打包进入 image 文件。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。 12345FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是 8.4，即 8.4 版本的 node。COPY . /app：将当前目录下的所有文件（除了 .dockerignore 排除的路径），都拷贝进入 image 文件的 /app 目录。WORKDIR /app：指定接下来的工作路径为 /app。RUN npm install：在 /app 目录下，运行 npm install 命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 有了 Dockerfile 文件以后，就可以使用 docker image build 命令创建 image 文件了。docker image build -t koa-demo . 或者 docker image build -t koa-demo:0.0.1 .。-t 参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 docker container run 命令会从 image 文件生成容器。 12345678$ docker container run -p 8000:3000 -it koa-demo /bin/bash# 或者$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash-p 参数：容器的 3000 端口映射到本机的 8000 端口。-it 参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 这时，Koa 框架已经运行起来了。在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。可以使用 docker container run 命令的 –rm 参数，在容器终止运行后自动删除容器文件 docker container run --rm -p 8000:3000 -it koa-demo /bin/bash。 RUN 命令与 CMD 命令的区别在哪里？简单说，RUN 命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个 RUN 命令，但是只能有一个 CMD 命令。 注意，指定了 CMD 命令以后，docker container run 命令就不能附加命令了（比如前面的 /bin/bash），否则它会覆盖 CMD 命令。 推荐阅读Windows7 安装 Docker 参考博客如何进入、退出 docker 的 containerDocker 入门教程CentOS7 安装 Docker]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(一)]]></title>
    <url>%2F2018%2F08%2F04%2FJava%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Java 入门总结(一) 1、在一个 *.Java 文件中，「至多有一个」 public 声明的类，「注：这里的类特指：class、interface、@interface、enum」但是允许有 0 个或多个不带 public 声明的类。如果存在 public 声明的类，则文件名称必须与 public 声明的类名称一致。如果一个 *.Java 文件中有多个 class 定义，则编译之后会自动划分为多个 *.class 文件。 2、Java 中的标识符可以由任意的字母、数字、下划线、美元符号组成，但是不能以数字开头，不能是 Java 中的保留关键字。不能用作 Java 命名的词：关键词、保留关键词「goto、const」、具有特殊意义的单词「true、false、null」。 3、变量：将内存中的某个内存块保留下来以供程序使用，里面的内容是可变的。常量：一个数字就表示常量，常量内容是不会改变的「比如：数字 1 就是常量，能改变吗？不能啊！」。 4、Java 数据类型划分 5、Java 八大基本数据类型 6、数据的溢出当「整数」的数据大小超出了可以表示的范围，而程序中又没有做数值范围的检查时，这个整数变量所「输出」的值将发生紊乱，而不是预期的运行结果。「注意：这里的整数包括：byte、short、int、long 四种类型」。 对于其他基本数据类型：char 如果超出其取值范围则什么也不会输出。float 和 double 超出其取值范围，输出的值跟其取值范围的值一样，超出部分算精度丢失了。 7、Java 中字符占 2 个字节，取值范围 0~65535，计算机将字符当成整数来处理。 8、在 Java 中，boolean 类型的值只有 true 和 false，不存在用 0 或 1 表示的情况，也不存在和 0 或 1 转换的情况。 9、Java 中，整型和浮点型（float 或 double）做运算，其结果都是浮点型，因为 Java 的自动转型机制所定，首先它们都是数字，其次浮点型表示的范围比整型大，所以向浮点型自动转型。 10、浮点型向整型做强制类型转换，采取的是丢弃小数部分，只保留整数部分的机制。 11、Java 运算符 Java 中一「单」、二、三目运算符，这里的数字指参与运算的对象「即变量」的个数。 赋值运算符：「=」 一元运算符：「+、-、!」 算术运算符：「+、-、*、/、%」 关系运算符：「&gt;、&lt;、&gt;=、&lt;=、==、！=」 逻辑运算符：「&amp;、&amp;&amp;、|、||」 括号运算符：「()」 位运算符：「&amp;、|、^、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;」 自增与自减运算符：「++、–」 12、位运算符如果要想进行位操作，则需要先将十进制的数据变为二进制数据，除 2 的形式，即除基取余。 位运算操作： 如何将一个十进制数转变为计算机中存储的二进制数123456789101112131415161718192021public class Test &#123; // 如何将一个十进制数转变为计算机中存储的二进制数「以 『int b = -3;』 为例」 if (是否是整数) &#123; // 是整数 对整数的绝对值进行除 2 取余操作，求得其二进制数，即真值。「b 的值为 -3，-3 的绝对值是 3，3 的二进制数为 11」 判断整数的类型是哪个？从而决定它的位数 「b 的类型为 int，在内存中占 4 字节，即 32 位」 if (真值的位数是否小于等于变量类型的位数) &#123; if (是否是负数) &#123; // 是负数 「1 + 29 个 0 + 11（2 位） = 32 位」 最高位为 1，其他位补零，得到其原码，然后再进行反码-&gt;补码-&gt;得到该负数在计算机中二进制的存储格式 &#125;else &#123; // 是自然数，原码 = 反码 = 补码 「30 个 0 + 11（2 位） = 32 位」 高位补 0，求得其原码也即补码，得到该整数在计算机中二进制的存储格式 &#125; &#125; &#125;else &#123; // 不是整数，直接报错 &#125;&#125; 位操作注意事项：1.位操作只能用于整型数据，对 float 和 double 类型进行位操作会被编译器报错。「这里的整型数据指的是 long、int、char、short、byte」。 2.位操作符的运算优先级比较低，所以尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。 3.位操作还有一些复合操作符，如&amp;=、|=、 ^=、&lt;&lt;=、&gt;&gt;= 。 4.short、 byte、char 在移位之前首先将数据转换为 int，然后再移位，此时移位符号作用在 32 位 bit 上，并且右操作数只有低５位有效。 5.当左操作数是 long 时，移位之后得到的类型是 long，当左操作数是其它四中类型时，移位之后得到的类型是 int，所以如果做操作数是 byte,char,short 时，你用 &gt;&gt;=,&gt;&gt;&gt;=, &lt;&lt;= 其实是将得到的 int 做低位截取得到的数值。 13、原码、反码、补码 原码：就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。 反码：正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。 补码：正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1。「即在反码的基础上 +1」。 注意：负数在计算机中是以补码的形式存储的。 参考博客Java 中 boolean 类型占用多少个字节char，byte或者short进行移位处理Java 中 8 种基本数据类型Java 位操作全面总结Java 运算符的优先级Java运算符优先级原码,反码,补码详解Java 移位操作符]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解之元注解]]></title>
    <url>%2F2018%2F08%2F03%2FJava%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%85%83%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 注解之元注解 什么是元注解？元注解：所谓元注解就是标记其他注解的注解。 Java 中元注解的共同特点： @Target：都是 ElementType.ANNOTATION_TYPE 表明它们只能用于注释类型。@Retention：都是 RetentionPolicy.RUNTIME 表明它们都能保留到运行时。@Documented：标记了所有的元注解，表明所有元注解都应该被 javadoc 工具记录。 Java 中的四大元注解： @Retention：指定注释的保留时间节点@Target：指定注释的使用位置@Documented：被其标记的注释将会被 javadoc 工具记录@Inherited：被 @Inherited 标记的 Annotation，注释的类的子类会自动继承父类中的该 Annotation @Retention 元注解指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，则保留策略默认为 RetentionPolicy.CLASS。 @Retention 元注解定义：123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125; RetentionPolicy 用于指定 Annotation 的保存范围，RetentionPolicy 包含三种范围： @Retention 使用示例：1234567import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(value = RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "Hello";&#125; @Target 元注解指示注释类型所适用的程序元素的种类。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。一个 ElementType 常量在 Target 注释中只能出现一次，否则编译时报错。 @Target 元注解定义：123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; ElementType 可选保存范围： @Target 使用示例：12345678910import java.lang.annotation.Target;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "Hello";&#125; @Documented 元注解指示某一类型的注释将通过 javadoc 和类似的默认工具进行文档化。应使用此类型来注释这些类型的声明：其注释会影响由其客户端注释的元素的使用。如果类型声明是用 @Documented 来注释的，则其注释将成为注释元素的公共 API 的一部分。 Documented 注解表明这个注解应该被 javadoc 工具记录. 默认情况下，javadoc 是不包括注解的. 但如果声明注解时指定了 @Documented，则它会被 javadoc 之类的工具处理，所以注解类型信息也会被包括在生成的文档中。 @Documented 元注解定义：1234@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; @Documented 使用示例：123456789101112131415161718192021222324import java.lang.annotation.Documented;@Documentedpublic @interface WithDocumented &#123; String value() default "WithDocumented";&#125;---------------------------------------------public @interface WithoutDocumented &#123; String value() default "WithoutDocumented";&#125;----------------------------------------------public class DocumentedTest &#123; @WithDocumented(value = "with_documented") public void with_documented () &#123; System.out.println("with_documented"); &#125; @WithoutDocumented(value = "without_documented") public void without_documented() &#123; System.out.println("without_documented"); &#125;&#125;------------------------------------------------使用 javadoc 命令：javadoc -d doc DocumentedTest.java 输出 doc 文档 输出的 doc 文档示意图： @Inherited 元注解指示注释类型被自动继承。如果在注释类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注释类型，同时该类声明中没有此类型的注释，则将在该类的超类中自动查询该注释类型。此过程会重复进行，直到找到此类型的注释或到达了该类层次结构的顶层 (Object) 为止。如果没有超类具有该类型的注释，则查询将指示当前类没有这样的注释。[看了 n 多遍才理解，写的真特么精辟！] 它指明被注解的类会自动继承。 更具体地说，如果定义注解时使用了 @Inherited 标记，然后用定义的注解来标注一个父类, 父类又有一个子类(subclass)，则父类的所有拥有 @Inherited 标记的注解属性将被继承到它的子类中。 请注意，如果使用注释类型来注释除类之外的任何内容，则此元注释类型不起作用。 还要注意，这个元注释只会导致从超类继承注释；已实现的接口上的注释无效。 @Inherited 元注解定义：1234@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125; @Inherited 使用示例：123456789101112131415161718192021222324@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "Hello";&#125;-------------------------------------@MyAnnotationclass Person &#123;&#125;class Student extends Person &#123;&#125;-------------------------------------public class InheritedTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 注意此处：Student 子类上根本没有 @MyAnnotation，但实际打印的结果中却有，说明注解被自动继承了下来 Class&lt;?&gt; c = Class.forName("cn.yan.annotation.Student"); Annotation[] an = c.getAnnotations(); for (Annotation a : an) &#123; System.out.println(a); &#125; &#125;&#125;------------------------------------输出结果：@cn.yan.annotation.MyAnnotation(value=Hello) 参考博客Java 元注解import static 和 import 的区别]]></content>
  </entry>
  <entry>
    <title><![CDATA[泛型入门]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%B3%9B%E5%9E%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[泛型入门 认识泛型泛型「generic」是在 JDK1.5 之后增加的新功能。由外部指定类对象中具体的操作类型。泛型，即「参数化类型」，把变量类型、方法返回值类型、参数类型等的类型也当成一种参数进行传递。泛型只在编译阶段有效。 泛型作用泛型在编译时检查设置内容的类型与指定的泛型类型是否一致，不一致则在编译时报错，起到了更好的保护数据安全性的作用。 泛型示例1234567891011121314151617public class GenericTest&lt;K, V&gt; &#123; private K key; private V value; public GenericTest(K k, V v) &#123; this.key = k; this.value = v; &#125; public K genericTest1(K k) &#123; return k; &#125; public V genericTest2(V v) &#123; return v; &#125;&#125; 泛型的安全警告在泛型应用中，如果在声明类对象的时候没有指定好其内部的泛型数据类型，则编译时系统会给出 「unchecked」即未经检查或不安全的操作的警告。对于没有指定泛型类型的，其本质是由系统自动将其类型设置为 Object。 匹配任意类型的通配符「?」泛型操作中，在进行引用传递的时候泛型类型必须匹配才可以传递，否则是无法传递的。如果使用「?」意味着可以接收任意的泛型对象，但是其内容却无法直接使用 &lt;?&gt; 修饰的泛型对象进行修改。即使用 &lt;?&gt; 只能接收，不能修改。 受限泛型在受限泛型中，可以将 extends 看成是小于等于「=&lt;」，将 super 看成是大于等于「&gt;=」。 泛型与子类继承的限制一个类的子类可以通过对象多态性，为其父类实例化，但是在泛型操作中，子类的泛型类型是无法使用父类的泛型类型接受。例如：Test&lt;String&gt; 不能使用 Test&lt;Object&gt; 接收。 泛型接口实现的两种方式1234567891011121314151617181920// 泛型接口定义public interface Info&lt;T&gt; &#123; T getValue();&#125;-----------------------------// 实现泛型接口方式 1：在子类的定义上也声明泛型类型public class InfoImpl&lt;T&gt; implements Info&lt;T&gt; &#123; @Override public T getValue() &#123; return null; &#125;&#125;----------------------------// 实现泛型接口方式 2：如果实现接口的子类不想使用泛型声明，则在实现接口的时候直接指定好其具体的操作类型public class InfoImpl implements Info&lt;String&gt;&#123; @Override public String getValue() &#123; return null; &#125;&#125; 泛型方法注意：区别一个方式是不是泛型方法，就看其方法上有没有泛型声明，即 &lt;T&gt; 这样的标识符，表明这个方法是泛型方法，在方法上声明了方法中即将要使用的泛型类型。只要在方法中定义了泛型操作，则可以传递任意的数据类型。 泛型的嵌套12345678910111213141516171819public class Info&lt;K, V&gt; &#123; private K key; private V value;&#125;------------------------------public class Person&lt;S&gt; &#123; private S info; public Person(S info) &#123; this.info = info; &#125;&#125;------------------------------public class Test &#123; public static void main(String[] args) &#123; Info&lt;Integer, String&gt; info = new Info&lt;Integer, String&gt;(); Person&lt;Info&lt;Integer, String&gt;&gt; person = new Person&lt;Info&lt;Integer, String&gt;&gt;(info); &#125;&#125; 参考博客Java 泛型详解Effective Java 泛型]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 注解之自定义注解]]></title>
    <url>%2F2018%2F08%2F03%2FJava%E6%B3%A8%E8%A7%A3%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 注解之自定义注解 自定义 Annotation 格式123[public] @interface Annotation名称 &#123; 数据类型 方法名称();&#125; 自定义 Annotation 示例 示例 1：简单的 Annotation123456// 自定义 Annotation，可以直接在程序中使用「@Annotation 名称」的格式public @interface MyAnnotation &#123;&#125;// 使用自定义 Annotation@MyAnnotationpublic class Test &#123;&#125; 示例 2：接收 1 个参数的 Annotation123456789101112public @interface MyAnnotation &#123; // 向 Annotation 中设置内容，使用变量接受参数 // 接受设置的内容，注意这里 value 是「变量名」，不是「方法名」！ String value();&#125;// 使用时必须清楚的指明变量的内容// @MyAnnotation("Hello")// 或者使用明确的标记，表示内容赋值给哪个变量@MyAnnotation(value = "Hello")public class Test &#123;&#125; 示例 3：接收 2 个参数的 Annotation123456789public @interface MyAnnotation &#123; // 同时设置多个参数 String key(); String value();&#125;// 使用时必须明确的指明变量名，注意变量名 key、value 不能省略@MyAnnotation(key = "Hello", value = "World")public class Test &#123;&#125; 示例 4：变量类型为数组的 Annotation12345678910public @interface MyAnnotation &#123; // 设置变量类型为数组 String[] list();&#125;// 与 @SuppressWarning 类似，其传参有三种形式：// @MyAnnotation(value = &#123;"Hello", "World"&#125;) 或// @MyAnnotation(&#123;"Hello", "World"&#125;) 或@MyAnnotation("Hello")public class Test &#123;&#125; 示例 5：为 Annotation 中的变量设置默认值 12345678public @interface MyAnnotation &#123; String key() default "Hello"; String value() default "World";&#125;// 由于此 Annotation 设置了默认值，所以使用的时候可以不指定参数值@MyAnnotation()public class Test &#123;&#125; 示例 6：为 Annotation 固定其变量取值范围1234567891011public enum AnnotationEnum &#123; RED, GREEN, BLUE;&#125;public @interface MyAnnotation &#123; AnnotationEnum color() default AnnotationEnum.RED;&#125;// 注意：变量名除 「value」外，其他的都需要明确的指出来@MyAnnotationNonoParam(color = AnnotationEnum.GREEN)public class Test &#123;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 注解之入门]]></title>
    <url>%2F2018%2F08%2F02%2FJava%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java 注解之入门 Java 注解 AnnotationJava 注解 Annotation 是在 JDK1.5 时引入的新特性，这种特性被称为元数据特性，在 JDK1.5 之后称为「注释」，即：以注释的方式加入一些程序的信息「通过注释可以完成一些代码的其他功能」。一个注解就是一个类。 Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。 java.lang.annotation.Annotation 接口是所有的 Annotation 都必须实现的接口。 系统内建 Annotation在 JDK1.5 之后，系统中已经建立了三个内建的 Annotation 类型，用户直接使用即可。 @Override: 覆写的 Annotation，表示「方法」覆写的正确性。@Deprecated：不赞成使用的 Annotation，表示不建议使用的操作。@SuppressWarnings：压制安全警告的 Annotation。 No. Annotation Java 中的声明 1 @Override @Target(value=METHOD)@Retention(value=SOURCE)public @interface Override {} 2 @Deprecated @Documented@Retention(value=RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {} 3 @SuppressWarnings @Target(value={TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(value=SOURCE)public @interface SuppressWarnings {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String[] value();} @Override 示例1234567891011121314class Person &#123; public String getInfo() &#123; return "This is a Person."; &#125;&#125;class Student extends Person &#123; // 使用 @Override 保证方法能够被正确覆写 @Override // 此处可能存在某种失误，如：将方法名写错 public String getInfo() &#123; return "This is a Student."; &#125;&#125; @Deprecated 示例123456789101112131415public class Test &#123; public static void main(String[] args) &#123; Person person = new Person(); // 编译时系统会给出安全的警告信息 person.getInfo(); &#125;&#125;class Person &#123; // 声明不建议使用的操作 @Deprecated public String getInfo() &#123; return "This is a Person."; &#125;&#125; @SuppressWarnings 示例123456789101112131415161718192021222324252627public class Test &#123; // 压制「一个」警告信息 // @SuppressWarnings("unchecked") // 同时压制多个警告信息——以数组的形式出现 // @SuppressWarnings(&#123;"unchecked", "deprecation"&#125;) // 由于该注解使用变量名为 value，类型为 String[] 接收传参，使用时可以明确指出用哪个变量接收传参 @SuppressWarnings(value = &#123;"unchecked", "deprecation"&#125;) public static void main(String[] args) &#123; Demo demo = new Demo(); demo.setT("Hello"); &#125;&#125;@Deprecatedclass Demo&lt;T&gt; &#123; private T t; public T getT() &#123; return t; &#125; public void setT(T t) &#123; this.t = t; &#125;&#125; 反射与 Annotation一个 Annotation 如果要想让其变得有意义，则必须结合反射机制取得 Annotation 设置的全部内容。Annotation 在实际开发中，不管如何使用，其最终肯定是结合反射机制，即可以通过 Annotation 设置一些内容到元素上，以完成特定的功能。注意：能通过反射取得的 Annotation 其 Retention 必须是 RUNTIME 范围的。 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default "Hello";&#125;-----------------------------------------------------------public class Bean &#123; // 注意：反射只能获取到 Rentention 是 RUNTIME 范围的 Annotation @SuppressWarnings("uncheck") @Deprecated @Override @MyAnnotation public String toString() &#123; return "Hello World"; &#125;&#125;-----------------------------------------------------------用法1：public class GetAnnotation &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class&lt;?&gt; c = Class.forName("cn.yan.annotation.Bean"); Method m = c.getMethod("toString"); Annotation[] a = m.getAnnotations(); for (Annotation annotation : a) &#123; System.out.println(annotation); &#125; &#125;&#125;--------------------------------------------------------------输出结果：@java.lang.Deprecated()@cn.yan.annotation.MyAnnotation(value=Hello)--------------------------------------------------------------用法2：public class GetAnnotation &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class&lt;?&gt; c = Class.forName("cn.yan.annotation.Bean"); Method m = c.getMethod("toString"); // 判断方法上是否存在指定的 Annotation if (m.isAnnotationPresent(MyAnnotation.class)) &#123; // 获取指定的 Annotation MyAnnotation my = m.getAnnotation(MyAnnotation.class); String value = my.value(); System.out.println(value); &#125; &#125;&#125;--------------------------------------------------------------输出结果：Hello 参考博客深入浅出 Java 注解深入理解 Java 注解类型]]></content>
  </entry>
  <entry>
    <title><![CDATA[必知的写作排版指南]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%BF%85%E7%9F%A5%E7%9A%84%E5%86%99%E4%BD%9C%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[必知的写作排版指南 1、空格汉字和英文、数字、符号之间都必须加一个空格。 中英文之间加空格 正例：我感觉自己 very 帅。反例：我感觉自己very帅。 汉字与数字之间加空格 正例：我永远都是 18 岁。反例：我永远都是18岁。 数字与单位之间加空格 正例：我有一只身高 120 cm 的猫。反例：我有一只身高 120cm 的猫。 全是英文的句子中，标点符号与单词之间需要加空格。 正例：Where there is a will, there is a way.反例：Where there is a will,there is a way. 全角标点与其他字符之间不加空格 正例：有志者，事竟成。反例：有志者， 事竟成。 中文与链接之间增加空格 正例：我觉得 知乎 这个网站很赞。反例：我觉得知乎这个网站很赞。 括号、引号前后加空格，中间内容无空格 示例 1：5.04 ounces (143 grams)示例 2：Did you say “I love that” ? 2、标点什么是全角、半角？全角、半角主要是针对标点符号来说的，全角占两个字节，半角占一个字节。中文标点符号是全角，英文标点符号是半角。即：中文标点符号的宽度是英文标点符号宽度的 2 倍。 中文 排版中所有的标点都应该使用 全角中文标点符号 正例：有志者，事竟成。反例：有志者,事竟成. 英文 排版中所有的标点都应该使用 半角英文标点符号 正例：Where there is a will, there is a way.反例：Where there is a will，there is a way。 使用直角引号 正例：这个是「直角引号」的效果。反例：这个是“普通引号” 的效果。 引号再使用引号使用直角双引号 正例：在「直角引号里使用『引号』的情况」。反例：在“普通引号里使用‘引号’的情况”。 不重复使用标点符号 正例：德国队竟然输给了韩国队！反例：德国队竟然输给了韩国队！！！ 注：各种输入法怎样快速打出「直角引号」符号 3、其他 英文名字首字母尽量大写 Facebook 专有名词使用正确的大小写 GitHub 首行不要缩进，改用「空出一行」代替首行缩进 空行代替缩进来区分自然段 参考博客中文文案排版指北写给大家看的中文排版指南每个人都需要的中文排版指南各种输入法怎样快速打出「」符号]]></content>
  </entry>
  <entry>
    <title><![CDATA[Log4j 日志总结]]></title>
    <url>%2F2018%2F07%2F14%2FLog4j%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Log4j 日志总结 1.日志组件Loggers「记录器」：Logger 负责捕捉事件并将其发送给合适的 Appender。 Appenders「输出源」：也被称为 Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前， Appenders 使用 Layouts 来对事件进行格式化处理。 Layouts「布局」：也被称为 Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts 决定了数据在一条日志记录中的最终形式。 当 Logger 记录一个事件时，它将事件转发给适当的 Appender。然后 Appender 使用 Layout 来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。另外，Filters 可以让你进一步指定一个 Appender 是否可以应用在一条特定的日志记录上。在日志配置中，Filters 并不是必需的，但可以让你更灵活地控制日志消息的流动。 2.日志系统日志系统：日志的具体实现。Java 的常见的日志系统有 Log4j、jdk-jul「即：java.util.logging」、logback 等，这些日志系统各自独立，编程方式也不一致。如果你一个系统要用到多个「框架库」，而这些框架库又可能要用不同的「日志系统」，那么你一个系统中就得使用多套日志系统，那多套日志系统如何融合在一起是个很大的问题。 3.日志框架那么如何解决呢？进行抽象，抽象出一个接口层，对每个日志实现都适配或者转接，这样这些提供给别人的库都直接使用抽象层即可，不需要关注具体的日志实现。常见的日志抽象出来的框架有 Apache commons-logging 和 slf4j。抽象层可以让我们更加容易地改变项目现有的日志框架，或者集成那些使用了不同日志框架的项目。 4.日志故事这里有个故事：最新是开源社区提供了 commons-logging 抽象，被称为 JCL 日志框架「JCL，全称为”Jakarta Commons Logging”，也可称为”Apache Commons Logging”」，出色地完成了兼容主流的日志实现「log4j、JUL、simplelog」，基本一统江湖，就连顶顶大名的 spring 也是依赖了 JCL。 看起来事物确实是美好，但是美好的日子不长，接下来另一个优秀的日志框架 slf4j 的加入导致了更加混乱的场面。比较巧的是 slf4j 的作者(Ceki Gülcü)就是 log4j 的作者，他觉得 JCL 不够优秀，所以他要自己搞一套更优雅的出来，于是 slf4j 日志体系诞生了，并为 slf4j 实现了一个亲子 —— logback，确实更加优雅。 但是由于之前很多代码库已经使用 JCL，虽然出现 slf4j 和 JCL 之间的桥接转换，但是集成的时候问题依然多多，对很多新手来说确实会很懊恼，因为比单独的 log4j 时代“复杂”多了，可以关注下这个，抱怨声确实很多。到此本来应该完了，但是 Ceki Gülcü 觉得还是得回头拯救下自己的 “大阿哥” —— log4j，于是 log4j2 诞生了，同样 log4j2 也参与到了 slf4j 日志体系中。日志体系的江湖又将面临血雨腥风的混乱了。 5.Loggers 组件Loggers 组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度。12345FATAL 0 ERROR 3 WARN 4 INFO 6 DEBUG 7 Log4j 有一个规则：只输出级别不低于设定级别的日志信息，假设 Loggers 级别设定为INFO，则 INFO、WARN、ERROR 和 FATAL 级别的日志信息都会输出，而级别比 INFO 低的 DEBUG 则不会输出。 1234// 获取 Logger 对象import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Test.class); 6.Appenders 组件Appenders 为日志输出目的地，如控制台「Console」、文件「Files」等，还可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。Log4j 提供的 appenders 有以下几种：12345org.apache.log4j.ConsoleAppender「控制台」org.apache.log4j.FileAppender「文件」org.apache.log4j.DailyRollingFileAppender「每天产生一个日志文件」org.apache.log4j.RollingFileAppender「文件大小到达指定尺寸的时候产生一个新的文件」org.apache.log4j.WriterAppender「将日志信息以流格式发送到任意指定的地方」 配置模式：1234log4j.appender.appenderName = classNamelog4j.appender.appenderName.Option1 = value1......log4j.appender.appenderName.OptionN = valueN 7.Layouts 指定日志输出格式Layouts 指定日志输出格式。Layouts 提供四种日志输出样式：HTML样式、自由指定样式、包含日志级别与信息的样式、包含日志时间、线程、类别等信息的样式。 1234org.apache.log4j.HTMLLayout「以HTML表格形式布局」org.apache.log4j.PatternLayout「可以灵活地指定布局模式」org.apache.log4j.SimpleLayout「包含日志信息的级别和信息字符串」org.apache.log4j.TTCCLayout「包含日志产生的时间、线程、类别等等信息」 配置模式：1234log4j.appender.appenderName.layout = classNamelog4j.appender.appenderName.layout.Option1 = value1......log4j.appender.appenderName.layout.OptionN = valueN 8.配置详解在实际应用中，要使 Log4j 在系统中运行须事先设定配置文件。配置文件事实上也就是对 Logger、Appender 及 Layout 进行相应设定。Log4j 支持两种配置文件格式: 一种是 XML 格式的文件。 一种是 properties 属性文件。 下面以 properties 属性文件为例介绍 log4j.properties 的配置。 8.1 配置根记录器 Logger123log4j.rootLogger = [level], appenderName1, appenderName2, ...... # false：表示 Logger 不会在父 Logger 的 appender 里输出，默认为 true。log4j.additivity.org.apache = false; level：设定日志记录的最低级别，可设的值有 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL 或者自定义的级别，Log4j 建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO 级别，则应用程序中所有 DEBUG 级别的日志信息将不会被打印出来。 appendName：指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。1log4j.rootLogger＝INFO, A1, B2, C3 8.2 配置输出目的地 appender12# appenderName：自定义 appderName，在 log4j.rootLogger 设置中使用。log4j.appender.appenderName = className className 可以设如下值：12345678910111213141516171819202122232425262728293031# ConsoleAppender 选项# Threshold = WARN：指定日志信息的最低输出级别，默认为 DEBUG。# ImmediateFlush = true：表示所有消息都会被立即输出，设为 false 则不输出，默认值是 true。# Target = System.err：默认值是 System.out。org.apache.log4j.ConsoleAppender「控制台」# FileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false：true 表示消息增加到指定文件中，false 则将消息覆盖指定的文件内容，默认值是 true。# File = D:/logs/logging.log4j：指定消息输出到 D:/logs/logging.log4j 文件中。也可以使用相对路径。org.apache.log4j.FileAppender「文件」# DailyRollingFileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false「同上」# File = D:/logs/logging.log4j「同上」# encoding = UTF-8 指定输出内容所采用的字符集# DatePattern = '.'yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。org.apache.log4j.DailyRollingFileAppender「每天产生一个日志文件」# RollingFileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false「同上」# File = D:/logs/logging.log4j「同上」# MaxFileSize = 100KB：后缀可以是 KB, MB 或者 GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到 logging.log4j.1 文件中。org.apache.log4j.RollingFileAppender「文件大小到达指定尺寸的时候产生一个新的文件」org.apache.log4j.WriterAppender「将日志信息以流格式发送到任意指定的地方」 注意：配置消息输出路径的时候，可以使用相对路径，这里的相对路径的参照点为服务器的目录。如：log4j.appender.file.File = ../logs/info.log 该日志系统运行在 Tomcat 服务器上，所以其对应的绝对地址为：服务器 Tomcat 的绝对路径 + ../logs/info.log。 8.3 配置输出格式 Layout1log4j.appender.appenderName.layout = className className 可以设如下值： 12345678910# LocationInfo = true：输出 java 文件名称和行号，默认值是 false。# Title = My Logging： 默认值是 Log4J Log Messages。org.apache.log4j.HTMLLayout「以HTML表格形式布局」# ConversionPattern = %m%n：设定以怎样的格式显示消息。org.apache.log4j.PatternLayout「可以灵活地指定布局模式」org.apache.log4j.SimpleLayout「包含日志信息的级别和信息字符串」org.apache.log4j.TTCCLayout「包含日志产生的时间、线程、类别等等信息」 参考博客Java Log 日志log4j 详细介绍日志系统和日志框架Log4j.properties 配置详解-简书log4j.properties 配置详解-CSDN为什么 logger 要声明为 static final]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 代码块]]></title>
    <url>%2F2018%2F03%2F15%2FHexoNext%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Hexo Next 代码块 1、编辑主题配置文件_config.yml「注意是主题配置文件」此处用来设置代码块的背景色。1highlight_theme: night eighties 2、编辑站点配置文件_config.yml「注意亲测会报错」：在网上 Google 的答案中要求将 auto_detect 设置为 true，但是我设置以后使用 hexo generate 生成静态代码的时候会报错 TypeError: Cannot set property ‘lastIndex’ of undefined 所以最后还是乖乖设置成了 false ，对实际效果也没有任何影响，对于该配置需谨慎使用。 「注意是站点配置文件」auto_detect 主要用来支持代码自动检测。12345highlight: enable: true line_number: true auto_detect: false tab_replace: 3、编辑 Markdown 文章注意：「```」之后需要指定你代码块中所使用的开发语言，也可以不指定，即让系统自动识别你代码块中的开发语言是哪个，系统可能会识别失败或错误，所以最好还是指定。注意：符号「```」,是 Esc 下面那个，不是单引号「’’’」。 效果图：]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法笔记]]></title>
    <url>%2F2018%2F02%2F02%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Markdown 语法笔记 1.标题方式一：使用两个或两个以上 = 或 - 标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 方式二：使用 #，表示 1-6 级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 2.段落段落的前后要有空行。在段内强制换行的方式是使用两个或两个以上空格加上回车「注：引用中换行省略回车」。 3.区块引用在段落的每行或者只在第一行使用符号 &gt;，还可使用多个嵌套引用。 > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.代码区块Hexo Next 代码块 5.强调在强调内容两侧分别加上 * 或者 _。 *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 6.列表使用 *、+、- 标记无序列表。注意：标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行。 * 第一项- 第三项+ 第二项 效果： 第一项 第三项 第二项 有序列表的标记方式是将上述的符号换成数字，并辅以「.」。 1. 第一项2. 第二项3. 第三项 效果： 第一项 第二项 第三项 7.分割线分割线最常使用就是三个或以上「*」，还可以使用「-」或 「_」。 ***---___ 效果： 8.链接链接可以由两种形式生成：行内式和参考式。 行内式 [行内式展示内容](https://github.com/ “行内式鼠标悬浮展示内容”) 效果： 行内式展示内容 参考式 [参考式展示内容 1][1][参考式展示内容 2][2][1]:https://github.com/ “参考式鼠标悬浮展示内容 1”[2]:https://github.com/ “参考式鼠标悬浮展示内容 2” 效果： 参考式展示内容 1参考式展示内容 2 9.图片添加图片的形式和链接相似，只需在链接的基础上前方加一个「！」,也分为行内式和参考式。 ![图片的替代文字](/upload_image/1.jpg “图片标题”) 效果： 10.反斜杠「\」相当于反转义作用。使符号成为普通符号。即显示符号本身。 11.符号「`」起到标记作用。即加个阴影背景。 `ctrl + a` 效果： ctrl + a 12.尖括号在 Markdown 中「尖括号」会被默认为 HTML 语句，这将导致尖括号本身及尖括号中的内容都不会被显示。所以就必须得使用转义字符才能够表示出「尖括号」。使用 &amp;lt; 代替 &lt;，使用 &amp;gt; 代替 &gt;。 &amp;lt;&amp;lt;西游记&amp;gt;&amp;gt; 效果： &lt;&lt;西游记&gt;&gt; 13.键盘键 &lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt; 效果： Ctrl+[ and Ctrl+] 14.删除线 ~~删除线~~ 效果： 删除线 15.反引号一个反引号需要引用代码时，如果引用的语句只有一段，不分行，可以用「反引号」将代码包起来，它们会解释成 &lt;code&gt;标签。 两个反引号如果代码的「内容中」有反引号，请用两个反引号包裹，与前后两个反引号之间加空格。代码中的&amp;、&lt;、&gt;符号都会自动转义。 三个反引号如果引用的语句为多行，可以将三个反引号```置于这段代码的首行和末行。 16.其它「表格」列表的使用(非traditonal markdown)用 | 表示表格纵向边界，表头和表内容用 - 隔开，并可用 : 进行对齐设置，两边都有 : 则表示居中，若不加 : 则默认左对齐。 一个普通标题 一个普通标题 一个普通标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 总结Markdown 只是帮助我们排版的工具，重要的还是内容，它是一篇文章的灵魂。好看的皮囊千篇一律，有趣的灵魂万里挑一。Markdown 就是赋予你灵魂一个好看的皮囊，但如果你没有有趣的灵魂，其他的全是扯淡。所以 Markdown 看一遍就行了，大致了解，然后动手写，不会的去查然后调整一下就好了，适应一段时间你就完全脱离了。使用 Markdown 的最高境界永远都是：笔下是语法，心中格式化。你达到了吗？ 参考博客Markdown 基本语法Markdown 入门参考Markdown 语法精讲Markdown 语法介绍]]></content>
  </entry>
</search>
