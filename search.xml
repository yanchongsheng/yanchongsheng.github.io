<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[求实英语(七)]]></title>
    <url>%2F2019%2F03%2F29%2FEnglish-2019-03-29-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[求实英语(七) —— 祈使句 练习题1、她胆子小，别吓唬她！ 2、递给我那本书，我该学习了。 3、别不好意思，再虚心点儿！ 4、在你走之前，先到我这儿来一下！ 5、别这么看着我！我很紧张。 6、呆在这儿！哪儿也别去！ 7、做个好孩子，别跟 Tom 学！ 8、不要放弃你的事业！ 9、别嫌弃你妈妈，她为你不容易。 10、好好做人，当个人民的好律师。 11、少说多干！ 12、别犹豫了！快走吧！ 13、这道菜看着挺好，吃着会怎么样？ 14、那个男孩子咋一看倒是挺潇洒。 15、为什么这首歌听起来像京戏？ 16、你不像你哥哥，至少长得不像。 17、看上去他一本正经，实际上他什么也不是。 18、那块布料手感怎么样？ 参考答案 Don’t frighten her! She is shy. Pass me that book! It’s time for me to study. Don’t by shy! Be more modest! Come to me before you go! Don’t look at me in this way! I am very nervous. Be here! Don’t go anywhere! Be a good child! Don’t do anything like Tom! Don’t quit your cause! Don’t dislike your mother! She is not easy for you. Behave yourself! Be a competent lawyer for the people. Speak less and do more! Don’t hesitate! Hurry up to go! This dish looks nice, how does it taste? That boy looks handsome at first glance. Why does the song sound like Beijing opera? You are not like your brother, and you don’t look like him at least. He looks serious , but he is nothing in fact. How does that cloth feel?]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(六)]]></title>
    <url>%2F2019%2F03%2F28%2FEnglish-2019-03-28-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[求实英语(六) —— 定语 练习题1、王芳手里的那本旧书太贵了。 2、桌子上边的纸箱里装满了碎玻璃。 3、树上的鸟儿成双对。 4、昨天的工作没完成，明天的计划又来了。 5、戴着眼镜的人是来自北京的教授。 6、他喜欢的收音机旧的都没法听了。 7、像 Tim 的那个男孩儿昨天来了吗？ 8、家里的电脑比这台容量大。 9、像这种带有更多插图的书都在阅览室里。 10、你告诉我的事儿对我而言非常重要。 11、现在还有带橡皮的铅笔吗？ 12、和我哥哥在一起的人是我姐夫。 13、你去过他提到的那个城市吗? 14、没有谁的季节是农民最苦的日子。 15、她脸上的泪水感动了那里的人。 参考答案 That old book in wangfang’s hand is very expensive. The paper box on the desk is full of broken glass. The birds in trees are in pairs. The work yesterday was not finished, and the plan tomorrow is coming. The person with glasses is the professor from Beijing. The radio he likes is too old to listen to. Did that boy like Tim come yesterday? The computer (at) home has more capacity than this one here. The book with more pictures like this are all in the reading-room. Sth. you told me is vey important for me. Are there any pencils with a rubber at present? The man with my brother is my brother-in-law. Have you been to that city he mentioned? The season without any water is the hardest days for the farmers. Tears on her face moved the people there.]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(五)]]></title>
    <url>%2F2019%2F03%2F27%2FEnglish-2019-03-27-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[求实英语(五) —— there be 练习题1、地上有水吗？那儿有多少水？ 2、办公室里有几台电脑？ 3、什么里面有邮票？ 4、Tom 的书包里有面包吗？ 5、这里不该有学生，他们这时候应该在教室里学习。 6、去年家里哪儿有旧书？ 7、什么在桌上？桌上有什么？ 8、明年我校将有 40 个班和 100 个老师。 9、那儿一定有餐厅吗？ 10、过去这个村庄前边有一条小河。 11、为什么二月份只有 28 天？ 12、从前有座山，山上有座庙。 13、哪儿有好老师我就到哪儿去学。 14、咱们学校什么时候有过实验室呀？ 15、只有不良的教育，没有不好的学生。 参考答案 Is there any water on the ground? How much water is there? How many computers are there in the office? what are there any stamps in? Is there any bread in Tom’s bag? Here shouldn’t be any students. They should be studying in the classroom now. Where were there any old books at home last year? What is on the desk? what is there on the desk? There will be 40 classes and 100 teachers in our school next year. Must there be any restaurants? There used to be a river in front of this village. Why are there only 28 days in Feb.? There was a hill long before, and there was a temple on it. I’ll go to study where there are some good teachers. When have there been any laboratories in our school? There is only a poor education, but there aren’t any poor students.]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(四)]]></title>
    <url>%2F2019%2F03%2F26%2FEnglish-2019-03-26-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[求实英语(四) —— 不定式 练习题1、一言难尽！（一句话说不清楚) 2、他昨天忘记带语文作业了。 3、你喜欢和谁在一起？谁喜欢和你在一起？ 4、谁要做这件荒唐的事儿？ 5、在家读书和写作是我今天的计划。 6、我还没决定要和谁一起去。 7、他们知道何时出发吗？ 8、什么时候出发无所谓，问题是去什么地方。 9、困难的是如何能准时到达那里。 10、听到要回家乡过年使她非常高兴。 11、和他在一起工作使我们情绪非常高涨。 12、天变凉了，睡在这儿太冷。 13、我决定当一名出色的律师。 14、难道你没发现她要生气？ 15、男人爱潇洒，女人爱漂亮。 参考答案 It is hard to say .(with one word) He forgot to bring his Chinese homework yesterday. Whom do you like to be with? Who likes to be with you? Who wants to do sth. fantastic? To read and write at home is my plan today. I haven’t decided yet whom to go with. Do they know when to set out? When to set out doesn’t matter, The question is where to go. What is hard is how to get there on time. It makes her very happy to hear to spend the New Year in her hometown. To work with him makes us in high spirits. The weather is getting cool, to sleep here is very cold. I decide to be an excellent lawyer. Don’t you find her to be angry? Men like to be handsome. Woman like to be pretty.]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法入门10]]></title>
    <url>%2F2018%2F12%2F05%2FAlgorithm-2018-12-05-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A810%2F</url>
    <content type="text"><![CDATA[排序——桶排序、计数排序、基数排序 1、桶排序（Bucket sort）桶排序，顾名思义，会用到「桶」，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java06]]></title>
    <url>%2F2018%2F12%2F04%2FJava-Java-Interview-2018-12-04-Java06%2F</url>
    <content type="text"><![CDATA[动态代理是基于什么原理？]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法入门09]]></title>
    <url>%2F2018%2F12%2F04%2FAlgorithm-2018-12-04-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A809%2F</url>
    <content type="text"><![CDATA[排序——快排、归并 1、归并排序和快速排序都用到了分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。 2、归并排序（Merge Sort）如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 归并排序不是原地排序算法、是稳定的排序算法；时间复杂度 O(nlogn)，空间复杂度 O(n)； 3、快速排序算法（Quicksort）如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。 快排是一种原地、不稳定的排序算法。时间复杂度 O(nlogn)，空间复杂度 O(1)；]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法入门08]]></title>
    <url>%2F2018%2F12%2F03%2FAlgorithm-2018-12-03-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A808%2F</url>
    <content type="text"><![CDATA[排序——冒泡、插入、选择 1、排序算法|排序算法|时间复杂度|是否基于比较||—|—|—||冒泡、插入、选择|O(n2)|是||快排、归并|O(nlogn)|是||桶、计数、基数|O(n)|否| 2、如何分析一个排序算法？（1）排序算法的执行效率：最好情况、最坏情况、平均情况时间复杂度；间复杂度的系数、常数 、低阶；比较次数和交换（或移动）次数；（2）排序算法的内存消耗（3）排序算法的稳定性 3、冒泡排序（Bubble Sort）冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。 冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。 4、插入排序（Insertion Sort）将数组中的数据分为两个区间，已排序区间和未排序区间。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。 5、选择排序（Selection Sort）选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java05]]></title>
    <url>%2F2018%2F12%2F03%2FJava-Java-Interview-2018-12-03-Java05%2F</url>
    <content type="text"><![CDATA[String、StringBuffer、StringBuilder有什么区别？ 由于 String 在 Java 世界中使用过于频繁，Java 为了避免在一个系统中产生大量的 String 对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过 new 方法创建的 String 对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给 String 对象引用赋值的情况。 举例:12345//通过直接量赋值方式，放入字符串常量池String str1 = &quot;123&quot;;//通过new方式赋值方式，不放入字符串常量池String str2 = new String(&quot;123&quot;); 注意：String 提供了 inter() 方法。调用该方法时，如果常量池中包括了一个等于此 String 对象的字符串（由 equals 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此池中对象的引用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java04]]></title>
    <url>%2F2018%2F11%2F30%2FJava-Java-Interview-2018-11-30-Java04%2F</url>
    <content type="text"><![CDATA[强引用、软引用、弱引用、幻象引用有什么区别？ 强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java03]]></title>
    <url>%2F2018%2F11%2F30%2FJava-Java-Interview-2018-11-30-Java03%2F</url>
    <content type="text"><![CDATA[谈谈final、finally、 finalize有什么不同？ 谈谈 final、finally、 finalize 有什么不同？final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。 finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。 finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。 参考博客Java 7 中的 Try-with-resources]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法入门07]]></title>
    <url>%2F2018%2F11%2F30%2FAlgorithm-2018-11-30-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A807%2F</url>
    <content type="text"><![CDATA[递归 1、去的过程叫「递」，回来的过程叫「归」。 2、基本上，所有的递归问题都可以用递推公式来表示。 3、递归需要满足三个条件 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 4、写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。 5、对于递归代码，试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 6、递归代码要警惕重复计算]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法入门06]]></title>
    <url>%2F2018%2F11%2F29%2FAlgorithm-2018-11-29-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A806%2F</url>
    <content type="text"><![CDATA[队列 1、队列跟栈一样，也是一种操作受限的线性表数据结构。 2、用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。 3、要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。 4、循环队列入队操作 队列为空：head == tail队列满了：(tail+1)%n=head 12345678public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; // 注意下一个 tail 的值 tail = (tail + 1) % n; return true;&#125;]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java02]]></title>
    <url>%2F2018%2F11%2F29%2FJava-Java-Interview-2018-11-29-Java02%2F</url>
    <content type="text"><![CDATA[Exception 和 Error 有什么区别？ 对比 Exception 和 Error在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。 Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。 不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误。 运行时异常与一般异常有什么区别？try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。 Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java01]]></title>
    <url>%2F2018%2F11%2F29%2FJava-Java-Interview-2018-11-29-Java01%2F</url>
    <content type="text"><![CDATA[谈谈你对 Java 平台的理解？ 1、谈谈你对 Java 平台的理解？可以从以下几个方面入手：Java/JVM 生态、基本语言特性、Java 类库、Java 虚拟机、工具。 2、「Java 是解释执行」，这句话正确吗？对于「Java 是解释执行」这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。『将字节码解释成机器码』 但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。『将字节码编译成机器码』 众所周知，我们通常把 Java 分为编译期和运行时。这里说的 Java 的编译和 C/C++ 是有着不同的意义的，Javac 的编译，编译 Java 源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码。 在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java00]]></title>
    <url>%2F2018%2F11%2F29%2FJava-Java-Interview-2018-11-29-Java00%2F</url>
    <content type="text"><![CDATA[体验 Java 的魅力 Java 学习的 5 大模块 Java 基础：我会围绕 Java 语言基本特性和机制，由点带面，让你构建牢固的 Java 技术工底。 Java 进阶：将围绕并发编程、Java 虚拟机等领域展开，助你攻坚大厂 Java 面试的核心阵地。 Java 应用开发扩展：从数据库编程、主流开源框架、分布式开发等，帮你掌握 Java 开发的十八般兵器。 Java 安全基础：让你理解常见的应用安全问题和处理方法，掌握如何写出符合大厂规范的安全代码。 Java 性能基础：你将掌握相关工具、方法论与基础实践。]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法入门05]]></title>
    <url>%2F2018%2F11%2F28%2FAlgorithm-2018-11-28-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A805%2F</url>
    <content type="text"><![CDATA[栈 1、栈是一种「操作受限」的线性表，只允许在一端插入和删除数据。 2、栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。 3、均摊时间复杂度一般都等于最好情况时间复杂度。动态扩容的顺序栈，需要重点掌握它的均摊时间复杂度分析方法。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket 入门]]></title>
    <url>%2F2018%2F11%2F28%2FOther-2018-11-28-WebSocket%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[WebSocket 入门 1、WebSocket 是一种网络通信协议。 2、为什么需要 WebSocket？ 因为通过它服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息。而 HTTP 协议的通信只能由客户端发起。 3、协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。eg：ws://example.com:80/some/path。 4、WebSocket 对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657简介： WebSocket 对象提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。构造函数： `WebSocket(url[, protocols])` 返回一个 WebSocket 对象属性： WebSocket.binaryType 使用二进制的数据类型连接 WebSocket.bufferedAmount 只读 未发送至服务器的字节数 WebSocket.extensions 只读 服务器选择的扩展 WebSocket.onclose 用于指定连接关闭后的回调函数 WebSocket.onerror 用于指定连接失败后的回调函数 WebSocket.onmessage 用于指定当从服务器接受到信息时的回调函数 WebSocket.onopen 用于指定连接成功后的回调函数 WebSocket.protocol 只读 服务器选择的下属协议 WebSocket.readyState 只读 当前的链接状态 WebSocket.url 只读 WebSocket 的绝对路径方法： WebSocket.close([code[, reason]]) 关闭当前链接 WebSocket.send(data) 向服务器发送数据示例： // Create WebSocket connection. const socket = new WebSocket(&apos;ws://localhost:8080&apos;); // Connection opened socket.addEventListener(&apos;open&apos;, function (event) &#123; socket.send(&apos;Hello Server!&apos;); &#125;); // Listen for messages socket.addEventListener(&apos;message&apos;, function (event) &#123; console.log(&apos;Message from server &apos;, event.data); &#125;); 5、客户端的简单示例123456789101112131415var ws = new WebSocket(&quot;wss://echo.WebSocket.org&quot;);ws.onopen = function(event) &#123; console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSocket!&quot;);&#125;ws.onmessage = function(event) &#123; console.log(&quot;Received Message: &quot; + event.data); ws.close();&#125;ws.onclose = function(event) &#123; console.log(Connection closed.)&#125; 6、WebSocket 客户端的 API (1) WebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。eg：var ws = new WebSocket(&#39;ws://localhost:8080&#39;); 执行语句之后，客户端就会与服务器进行连接。 (2) webSocket.readyState123456# readyState属性返回实例对象的当前状态，共有四种CONNECTING：值为0，表示正在连接。OPEN：值为1，表示连接成功，可以通信了。CLOSING：值为2，表示连接正在关闭。CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 (3) webSocket.onopen12345678910# 实例对象的 onopen 属性，用于指定连接成功后的回调函数ws.onopen = function () &#123; ws.send(&apos;Hello Server!&apos;);&#125;# 如果要指定多个回调函数，可以使用 addEventListener 方法ws.addEventListener(&apos;open&apos;, function fun1 (event) &#123; ws.send(&apos;Hello Server1!&apos;);&#125;, function fun2 (event) &#123; ws.send(&apos;Hello Server2!&apos;);&#125;); 参考博客WebSocket WebSocket 教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法入门04]]></title>
    <url>%2F2018%2F11%2F20%2FAlgorithm-2018-11-20-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A804%2F</url>
    <content type="text"><![CDATA[链表 1、常见的缓存淘汰策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。 2、不管是「指针」还是「引用」，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。 3、指针：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。 在编写链表代码的时候，我们经常会有这样的代码：p-&gt;next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。 4、哨兵：解决「边界问题」的，不直接参与业务逻辑。如果引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。也把这种有哨兵结点的链表叫带头链表。哨兵结点是不存储数据的。 如何表示一个空链表？head=null 表示链表中没有结点了。其中 head 表示头结点指针，指向链表中的第一个结点。 5、123456char* 是声明一个字符类型的指针# 声明一个指针 c，这个指针指向的内存地址上只能存放字符类型的值# 在 char* c = &quot;Hello World&quot;; 中，&quot;Hello World&quot; 是长度为 12 的字符『数组』常量，其最后一个元素是&apos;\0&apos;，而这句代码执行的结果是将 c 指向了 &quot;Hello World&quot; 的第一个字符 &apos;H&apos;，c 后面的连续内存依次存放 &apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos; &apos;,&apos;W&apos;,&apos;o&apos;,&apos;r&apos;,&apos;l&apos;,&apos;d&apos;,&apos;\0&apos;char* c = &quot;Hello World&quot;; 6、重点留意边界条件处理1234567如果链表为空时，代码是否能正常工作？如果链表只包含一个结点时，代码是否能正常工作？如果链表只包含两个结点时，代码是否能正常工作？代码逻辑在处理头结点和尾结点的时候，是否能正常工作？ 7、常见链表操作123456789单链表反转链表中环的检测两个有序的链表合并删除链表倒数第 n 个结点求链表的中间结点]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础03]]></title>
    <url>%2F2018%2F11%2F15%2FAlgorithm-2018-11-15-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%8003%2F</url>
    <content type="text"><![CDATA[数组 什么是数组？数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 线性表（Linear List）: 线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。 连续的内存空间和相同类型的数据 : 正是因为这两个限制，它才有了一个堪称「杀手锏」的特性：「随机访问」。计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。 一般使用数组而不用容器的情况1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList &gt; array。 我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础02]]></title>
    <url>%2F2018%2F11%2F13%2FAlgorithm-2018-11-13-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%8002%2F</url>
    <content type="text"><![CDATA[复杂度分析（下） 最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）。 最好、最坏情况时间复杂度为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。 在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。 平均情况时间复杂度概率论中的加权平均值，也叫作期望值，平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。 均摊时间复杂度摊还分析法（或者叫平摊分析法），通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。 均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。如果你遇到了，知道是怎么回事儿就行了。 应用场景：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础01]]></title>
    <url>%2F2018%2F11%2F09%2FAlgorithm-2018-11-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[复杂度分析（上） 大 O 复杂度表示法T(n) = O(f(n))，T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。 当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。 时间复查度分析 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度实例分析常量阶 O(1) &lt; 对数阶 O(logn) &lt; 线性阶 O(n) &lt; 线性对数阶 O(nlogn) &lt; 平方阶 O(n^2) &lt; 立方阶 O(n^3) &lt; k 次方阶 O(n^k) &lt; 指数阶 O(2^n) &lt; 阶乘阶 O(n!) &lt; O(n^n) 一般时间复杂度到了 2^n (指数阶) 及更大的时间复杂度，这样的算法我们基本上不会用了，太不实用了。平方阶 (n^2) 的算法是勉强能用，而 nlogn 及更小的时间复杂度算法那就是非常高效的算法了啊。 在对数阶时间复杂度的表示方法里，我们忽略对数的「底」，统一表示为 O(logn)。 空间复杂度分析空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。 小结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(十七)]]></title>
    <url>%2F2018%2F11%2F06%2FLinux-2018-11-06-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%83%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(十七) —— 备份与恢复 备份概述1、Linux 系统常见需要备份的数据/root/目录、/home/目录、/var/spool/mail/目录、/etc/目录、其他目录。 2、备份策略 完全备份：就是指把所有需要备份的数据全部备份，当然完全备份可以备份整块硬盘，整个分区或某个具体的目录。 增量备份：即每次备份的都是基于上一次备份新增的数据。节省空间，但恢复的时候比较费劲。 差异备份：每次备份都是基于第一次的完全备份。属于折中的办法。 dump 和 restore 命令Linux 中常见的增量备份工具 dump 和 恢复工具 restore。 1、dump 命令12345678910111213141516171819202122232425262728格式： dump [选项] 备份之后的文件名 原文件或目录选项： -level 就是我们说的 0-9 十个备份级别，0 表示完全备份，1 表示第一次增量备份，依次类推 -f 文件名 指定备份之后的文件名 -u 备份成功之后，把备份时间记录在 /etc/dumpdates 文件 -v 显示备份过程中更多的输出信息 -j 调用 bzlib 库压缩备份文件，其实就是把备份文件压缩为 .bz2 格式 -W 显示允许被 dump 的分区的备份等级及备份时间举例： 1、备份分区 # 先执行一次完全备份，并压缩和更新备份时间 dump -0uj -f /root/boot.bak.bz2 /boot/ # 查看备份时间文件 cat /etc/dumpdates # 修改 /boot 分区 cp install.log /boot/ # 增量备份 /boot 分区，并压缩 dump -1uj -f /root/boot.bak1.bz2 /boot/ # 查询分区的设备时间及备份级别 dump -W 2、备份文件或目录 # 完全备份 /etc 目录，注意目录和文件只能使用 0 级别进行完全备份，而不再支持增量备份 # 注意：dump 命令只有备份分区的时候才可以使用增量备份 dump -0j -f /root/etc.dump.bz2 /etc 注意：CentOS 7.0 之后开始选择 XFS 作为默认的文件系统。dump 命令只能针对 ext 文件系统使用，而要对 xfs 文件系统进行增量备份，则需要使用 xfsdump 命令。 2、restore 命令 restore 命令主要用于还原 dump 命令增量备份后的文件。 1234567891011格式： restore [模式选项] [选项]模式选项：restore 命令常用的模式有以下四种，这四个模式不能混用。 -C 比较备份数据和实际数据的变化 -i 进入交互模式，手工选择需要恢复的文件 -t 查看模式，用于查看备份文件中拥有哪些数据 -r 还原模式，用于数据还原选项： -f 指定备份文件的文件名]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(十六)]]></title>
    <url>%2F2018%2F11%2F05%2FLinux-2018-11-05-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(十三) —— Linux 启动管理 CentOS 启动管理系统运行级别1、运行级别 2、运行级别命令12345# 查看当前运行级别runlevel# 改变运行级别init 运行级别 3、系统默认运行级别12345678910# 设置系统开机后直接进入哪个运行级别vim /etc/inittab写入如下内容：（注意最后的冒号不能少）id:3:initdefault:# CentOS7 设置系统默认运行级别# To view current default target, run:systemctl get-default# To set a default target, run:systemctl set-default TARGET.target 系统启动过程1、Linux 启动流程图 当按下开机键以后，主板上的 BIOS 芯片就会进行自检，自检完成后它会加载 MBR（即主引导记录，它里面保存着启动引导程序。在 Linux 中启动引导程序是 grub ，grub 保存在 MBR 中，grub 是系统启动主要的引导程序） 。紧接着判断式单系统还是多系统，单系统直接启动，多系统让用户选择要启动哪个系统，最终都会加载需要启动的操作系统的内核（这里的内核是一个压缩的内核），然后启动就会往下一步走。内核解压并进行自检，如果是 Linux，Linux 一般信任的是 Linux 内核自检，会把内核的自检过程记录在 dmesg。内核加载之后，就需要由内核去加载驱动（注意：只要内核安装完成，所有的驱动都装在内核当中，内核会根据硬件自动判断需要哪个驱动并进行加载，这点不同于 Windows。注意，内核中只保留了常见的驱动，把不常见的驱动作为函数模块，即把驱动写成一个程序，保存在硬盘里，一般放在 /lib 目录下，当需要的时候内核直接去该目录下去读取，这样保证了内核不会太大）。 2、注意：boot 这个分区不是由内核直接加载的，而是由启动引导程序事前就已经读取出来的，即启动引导程序默认是可以识别 boot 分区的。initramfs 内存文件系统，其作用是可以通过启动引导程序加载到内存中，然后加载启动过程中所需的内核模块，比如 USB、SATA、SCSI 硬盘的驱动和 LVM、RAID 文件系统的驱动。可以在 /boot 目录下看到该文件。 3、打开 initramfs 文件操作步骤1234# 查看文件类型file initramfs*.img# 提取文件cpio -ivcdu &lt; initramfs*.img]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(十五)]]></title>
    <url>%2F2018%2F11%2F04%2FLinux-2018-11-04-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%94%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(十五) —— 日志管理 日志管理简介1、日志服务在 CentOS 6.x 中日志服务已经由 rsyslogd 取代了原先的 syslogd 服务。rsyslogd 日志服务更加先进，功能更多。 1234567891011# 查看服务是否启动ps aux | grep rsyslogd# 启动日志服务systemctl restart rsyslog.service# 查看服务是否是自启动systemctl list-unit-files | grep rsyslog.service# 设置日志服务自启动systemctl enable rsyslog.service 2、常见日志的作用 除了系统默认的日志之外，采用 RPM 方式安装的系统服务也会默认把日志记录在 /var/log 目录中（源码包安装的服务日志是在源码包指定目录中）。不过这些日志不是由 rsyslogd 服务来记录的和管理的，而是各个服务使用自己的日志管理文档来记录自身日志。只要通过 RPM 包的方式安装对应的服务，就会产生对应的日志。 rsyslogd 日志服务1、日志文件格式基本日志格式包含以下四列： 事件产生的时间发生事件的服务器的主机名产生事件的服务名或程序名事件的具体信息 2、/etc/rsyslog.conf 配置文件 rsyslogd 服务记录哪些日志，到底记录什么样的日志，是由 /etc/rsyslog.conf 这个配置文件决定的。该日志的固定格式为：服务名称[连接符号]日志等级 日志记录位置。1234# 服务名称 authpriv，连接符号「.」，日志等级 *，日志记录位置 /var/log/secure# authpriv 表示认证相关的服务，「.」代表大于等于后面日志等级，* 所有日志等级# 即所有认证相关服务的日志不管它是什么等级，全都记录在 /var/log/secure 这个日志中authpriv.* /var/log/secure 注意：上图中从上到下为从低等级到高等级。等级越高，记录的内容越小（因为发生的可能比较小），优先级越高，危害越大。 lp0 表示打印机的意思。 日志轮替1、日志轮替包含以下两点： 日志需要切割：例如将大日志按天分成小日志。日志需要轮换：例如只记录 30 天的日志，前第 31 天以前的就会被删掉。 2、日志文件的命名规则 3、logrotate.conf 配置文件 4、把 apache 日志加入轮替123456vim /etc/logrotate.conf/usr/local/apache/logs/access_log &#123; daily create rotate 30&#125; 注意：RPM 包安装的，日志都不需要进行手工去轮替，系统都会默认去轮替；需要做的只有源码包安装的日志。一般情况下所有的源码包安装的日志都需要做手工配置轮替。 5、logrotate 命令1234567格式： logrotate [选项] 配置文件名选项： 如果此命令没有选项，则会安装配置文件中的条件进行日志轮替 -v 显示日志轮替过程 -f 强制进行日志轮替。不管日志轮替的条件是否已经符号，强制配置文件中多有的日志进行轮替]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(十四)]]></title>
    <url>%2F2018%2F11%2F03%2FLinux-2018-11-03-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(十四) —— Linux 系统管理 进程管理进程查看1、进程简介进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。 注意：命令也是一个进程，因为命令其实是一个功能，但是命令的进程存留的时间超级短，可能很难看到。要运行一个程序至少产生一个进程。 2、进程管理的作用 判断服务器健康状态查看系统中所有进程杀死进程 注意：进程管理最主要的工作是判断服务器的健康状态，而不是杀死进程，就算是不需要的进程也应该尝试正确终止，而不是杀死进程，杀进程是无法正常终止才采用的方式。 3、查看系统中所有进程12345# 方式一：使用 BSD 操作系统格式ps aux# 方式二：使用 Linux 标准命令格式ps -le 第一种采用的是 Unix 格式，注意选项前面并没有「-」。aux：a 表示查看所有前台进程，x 表示查看所有后台进程，u 显示进程是由哪个用户产生的。-le：l 显示进程详细信息，e 显示系统所有进程。 绝大多数的系统进程的 TTY 显示的都是 「?」，证明这个进程不是由终端调用的，而是由内核直接产生的。按住 Alt + F1~F6 能够切换 6 个本地字符终端，如果按装了图形界面可以使用 Ctrl + Alt + F7 切换到图形终端。 4、查看系统健康状态123456789101112格式： top [选项]选项： -d 秒数 指定 top 命令每隔几秒钟更新，默认是 3 秒 在 top 命令的交互模式当中可以执行的命令： ? 或 h 显示交互模式的帮助 P 以 cpu 使用率排序，默认就是此项 M 以内存的使用率排序 N 以 PID 排序 q 退出 top 相当于 Windows 的任务管理器，默认以 cpu 的占用率进行排序。该命令最主要的是看头 5 行。 主要看上图中的三个指标：Tasks 的 load average、Cpu 的 id、Mem 的 free。 (1) 第一行信息为任务队列信息 内容 说明 17:01:55 系统当前时间 up 10 days, 6:02 系统的运行时间，本机已经运行 10 天 6 小时 2 分钟 1 users 当前登陆了一个用户 load average: 0.00, 0.01, 0.05 系统在之前 1 分钟，5 分钟，15 分钟的平均负载。一般认为小于 1 时，负载较小；如果大于 1，系统已经超出负荷。 (2) 第二行为进程信息 内容 说明 Tasks: 119 total 系统中的进程总数 1 running 正在运行的进程数 118 sleeping 睡眠的进程 0 stopped 正在停止的进程 0 zombie 僵尸进程。如果不是 0，需要手工检查僵尸进程 僵尸进程指：这个进程正在终止，但是还没有终止完全。 (3) 第三行为 CPU 信息 内容 说明 %Cpu(s): 0.0 us 用户模式占用的 CPU 百分比 0.0 sy 系统模式占用的 CPU 百分比 0.0 ni 改变过优先级的用户进程占用的 CPU 百分比 100.0 id 空闲 CPU 的 CPU 百分比 0.0 wa 等待输入/输出的进程的占用 CPU 百分比 0.0 hi 硬中断请求服务占用的 CPU 百分比 0.0 si 软中断请求服务占用的 CPU 百分比 0.0 st st（steal time）虚拟时间百分比。就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比 (4) 第四行为物理内存信息 内容 说明 KiB Mem : 1012400 total 物理内存的总量，单位 KB 279524 free 空闲的物理内存数量 196900 used 已经使用的物理内存数量 535976 buff/cache 作为缓冲/缓存的内存数量 (5) 第五行为交换分区（swap）信息 内容 说明 KiB Swap: 1888252 total 交换分区（虚拟内存）的总大小 1888252 free 空闲交换分区的大小 0 used 已经使用的交换分区的大小 574856 avail Mem 作为缓存的交换分区的大小 注意：top 命令以及 Windows 的任务管理器，本身是非常耗费资源的，看一看就行，没事不要总打开。top 命令本身比较消耗资源。 5、查看进程树123456格式： pstree [选项]选项： -p 显示进程的 PID -u 显示进程的所属用户 终止进程1、kill 命令123456789# 查看可用的进程信号kill -l# 重启进程，22345 表示进程 ID 即 PID# 注意 kill 后面跟的一定是 PID 号而不能是进程名kill -1 22345# 强制杀死进程kill -9 22368 最常用的进程信号：1（重启）、9（强制终止）、15（正常终止，默认为此项） 2、killall 命令1234567格式： # 按照进程名杀死进程 killall [选项][信号] 进程名选项： -i 交互式，询问是否要杀死某个进程 -I 忽略进程名的大小写 3、pkill 命令123456789101112格式： # 按照进程名终止进程 pkill [选项][信号] 进程名选项： -t 终端号 按照终端号踢出用户举例： # 按照终端号踢出用户 # 用 w 命令查询本机已经登录的用户 # 强制杀死从 pst/1 虚拟终端登录的进程 pkill -t -9 pst/1 pkill 和 killall 其实非常类似，都是根据进程名杀死进程，区别就是 pkill 支持 -t 选项，即根据终端号踢出用户。 工作管理1、把进程放入后台12345# 方式一：使用 &amp; ，&amp; 表示放入后台继续运行tar -zxf etc.tar.gz /etc &amp;# 方式二：使用 ctrl + z 快捷键，表示放入后天暂停运行# 在 top 命令执行的过程中，使用 ctrl + z 快捷键 2、查看后台的工作123格式： # 选项 -l 显示工作的 PID jobs [-l] 注：[数字]表示工作号，表示第几个放入的。「+」号代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作。「-」号代表倒数第二个放入后台的工作。在不指定工作号的情况下，默认第一个恢复「+」，其次「-」。 3、将后台暂停的工作恢复到前台执行12345格式： fg %工作号参数： %工作号 %号可以省略，但是注意工作号和 PID 的区别 4、把后台暂停的工作恢复到后台执行1bg %工作号 注：后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行。 系统资源查看1、vmstat 命令监控系统资源123456格式： vmstat [刷新延时 刷新次数]举例： # 监听 3 次系统资源，每次间隔 1 秒钟 vmstat 1 3 2、dmesg 开机时内核检测信息，dmesg 是一个重要的信息查看命令，可以通过它判断系统的硬件信息，如：查看 CPU 的信息 dmesg | grep CPU。 3、free 命令查看内存使用状态123456格式： free [选项]选项： -b 以字节为单位；-k 以 KB 为单位，默认项 -m 以 MB 为单位；-G 以 GB 为单位 4、缓存和缓冲的区别简单来说缓存（cache）是用来加速数据从硬盘中「读取」的，而缓冲（buffer）是用来加速数据「写入」硬盘的。 由于内存的运行速度比硬盘快，而且快的多。缓冲是为了避免频繁的对硬盘进行写操作，是将要写入的内容积累到一定数量然后一次性写入硬盘。 5、查看 CPU 信息：cat /proc/cpuinfo。注意 /proc 目录是内存的挂载点，一旦断电这个目录里面的内容就会消失，即每次开机都系统都会检测 cpu 并写入该文件。 6、uptime 命令：显示系统的启动时间和平均负载，也就是 top 命令的第一行。w 命令也可以看到这个数据。 7、查看系统与内核相关的信息1234567格式： uname [选项]选项： -a 查看系统所有相关信息 -r 查看内核版本 -S 查看内核名称 8、判断当前系统的位数：file /bin/ls file 命令是查看文件类型的命令，只要使用 file 命令查询一个系统的外部命令的文件类型，注意不能是 Shell 的内部命令，会附带的显示操作系统位数。 9、查询当前 Linux 系统的发行版本：lsb_release -a 10、列出进程打开或使用的文件信息1234567格式： lsof [选项]选项： -c 字符串：只列出以字符串开头的进程打开的文件 -u 用户名：只列出某个用户的进程打开的文件 -p pid ：列出某个 PID 进程打开的文件 系统定时任务1、crond 服务管理与访问控制（cron 计划任务，d 表示 deamon 守护进程）12345# crond 启动命令systemctl restart crond.service# 设置 crond 开机自启动systemctl enable crond.service 2、用户的 crontab 设置12345678910111213格式： crontab [选项]选项： -e 编辑 crontab 定时任务 -l 查询 crontab 任务 -r 删除当前用户所有的 crontab 任务举例： */5 * * * * /bin/echo &quot;11&quot; &gt;&gt; /tmp/test 5 5 * * 2 /sbin/shutdown -r now 0 5 1,10,15 * * /root/sh/autobak.sh 执行命令 crontab -e 进入 crontab 编辑界面。会打开 vim 编辑你的工作。格式：* * * * * 执行的任务，注意：在 crontab 中 % 是有特殊含义的，为了能够格式化日期，必须加转义符，否则定义的时间是无法正确执行 date=$(date +\%y\%m\%d)。 crontab 编辑格式中五个「*」的含义： 项目 含义 范围 第一个 * 一小时当中的第几个分钟 0-59 第二个 * 一天当中的第几个小时 0-24 第三个 * 一个月当中的第几个天 1-31 第四个 * 一年当中的第几个月 1-12 第五个 * 一周当中的第几天 0-7（0 和 7 都代表星期日） crond 定时任务特殊符号解释： 特殊符号 含义 * 代表任何时间。比如第一个 * 就表示一小时中每分钟都执行一次的意思 , 代表不连续的时间。比如 0 8,12,16 * * * 命令，就代表在每天的 8 点 0 分，12 点 0 分， 16 点 0 分都执行一次命令 - 代表连续的时间范围。比如 0 5 * * 1-6 命令，代表在周一到周六的凌晨 5 点 0 分执行命令 */n 代表每隔多久执行一次。比如 */10 * * * * 命令，代表每隔 10 分钟就执行一遍命令 crond 定时任务示例解释： 时间 含义 45 22 * * * 命令 在每天的 22 点 45 分执行命令 0 17 * * 1 命令 在每周 1 的 17 点 0 分执行命令 0 5 1,15 * * 命令 在每个月的 1 号和 15 号 5 点 0 分执行命令 40 4 * * 1-5 命令 每周 1 到周 5 的 4 点 40 分执行命令 */10 4 * * * 命令 每天 4 点，每隔 10 分钟执行一次命令 0 0 1,15 * 1 命令 每月 1 号和 15 号，每周 1 的 0 点 0 分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱 如果写的是「*」代表任意时间，如果写的是具体的值，代表指定的时间。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(十三)]]></title>
    <url>%2F2018%2F11%2F02%2FLinux-2018-11-02-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(十三) —— Linux 服务管理 服务简介与分类1、服务的分类注意：因为 Linux 操作系统都是使用 RPM 安装的，所以把 RPM 包安装的服务称为默认服务。 独立的服务：Linux 当中绝大多数的服务都是独立的，服务直接就在内存里，当有用户访问，该服务就会直接响应用户，好处是服务的访问响应速度更快，坏处是独立的服务越多，消耗的服务器内存资源越多。 Xinetd 服务本身就是独立的，它就在内存中，它本身没有任何功能，它唯一的功能就是在它之后还有一系列被它管理的服务。比如 rsync 是 Linux 中网络备份服务，要访问它（rsync）不能直接找到它，因为它（rsync）没在内存里，先找 xinetd，再通过 xinetd 找到它，好处是 xinetd 之后的服务不占用内存，坏处是响应速度相对慢。 2、启动与自启动 服务启动：就是在当前系统中让服务运行，并提供功能。 服务自启动：自启动是指让服务在系统开机或重启之后，随着系统的启动而自动启动服务。 3、查询已安装的服务是否开启自启动 RPM 包安装的服务：systemctl list-unit-files 查看服务自启动状态，可以看到所有 RPM 包安装的服务。 源码包安装的服务：查看服务安装位置，一般是 /usr/local/ 下。 注意 systemctl 是不能查看源码包安装的服务的。注意：它是服务自启动查看命令，不是服务是不是正在运行的查看命令。要想查看服务是否正在运行可以通过 ps aux 查看系统所有进程 或 netstat -tlun 查看所有端口服务的方式去查看。 4、RPM 包安装服务和源码包安装服务的区别就是安装位置的不同。源码包安装在指定位置，一般是 /usr/local/；RPM 包安装在默认位置中。 RPM 包安装服务的管理独立服务的管理1、RPM 包常见通用的默认安装位置（对于 CentOS 7.x 来说部分已过期）CentOS7 的服务 systemctl 脚本存放在：/usr/lib/systemd/，有系统（system）和用户（user）之分。是存放独立服务启动脚本的位置。 2、独立服务的启动12345格式： systemctl start|stop|restart|status 独立服务名举例： systemctl status crond.service 3、独立服务的自启动12345格式： systemctl enable/disable 独立服务名举例： systemctl enable crond.service 可以使用 ntsysv 命令管理自启动服务。ntsysv 相当于 setup 命令，想要启动，在其前面输入 * 号，不想启动输入空格。是 red hat 系列专有命令，可以管理独立的服务和基于 xinetd 服务。 基于 xinetd 服务的管理1、安装 xinetd 与 telnet123yum -y install xinetdyum -y install telnet-server 注意：基于 xinetd 管理的服务越来越少了。telnet 服务非常不安全，用它做远程管理已经被淘汰了，我们只是用它的客户端来测试一下端口是否能连接，不再用它来做远程管理。远程管理使用更加安全的 ssh 服务。telnet 服务器是非常不安全，用完之后最好删除。但是其客户端是系统默认安装的。 源码包安装服务的管理1、源码包安装服务的启动使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。 2、源码包服务的自启动 3、让源码包服务被服务管理命令识别 服务管理总结 常见服务的作用： 服务名称 功能简介 建议 crond 系统的定时任务，一般的 Linux 服务器都需要定时任务帮助系统维护 开启 gpm 在字符终端（tt1-tt6）中可以使用鼠标复制粘贴。就是这个服务的功能 开启 iptables 防火墙功能，Linux 中防火墙是内核支持功能。这是服务器的主要防护手段，必须开启 开启 sshd ssh 加密远程登录管理的服务。服务器的远程管理必须使用此服务 开启 syslog 日志的守护进程 开启 注意：服务开的越少越好，因为安全，而且占用的资源也比较少。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(十二)]]></title>
    <url>%2F2018%2F10%2F26%2FLinux-2018-10-26-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(十二) —— Shell 编程 基础正则表达式1、正则表达式与通配符正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、sed 等命令可以支持正则表达式。 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp 这些命令不支持正则表达式，所以只能使用 Shell 自己的通配符来进行匹配了。 注意：通配符和正则表达式这种区分，仅限于 Linux 的 Shell 当中。 注意：这里是基础正则表达式，还存在扩展正则表达式。 注意：「^」位于中括号里面表示取反，位于外面表示行首。 test.txt 内容如下，将适用于以下所有用到 test.txt 的地方： ID Name Gender Score 1 zhangsan male 86 2 lisi female 90 3 wangwu male 83 「*」示例： 12345678# 匹配所有内容，包括空白行（即 a 出现了 0 次），相当于列出整个文档grep &quot;a*&quot; test.txt# 匹配至少包含一个 a 的行grep &quot;aa*&quot; test.txt# 匹配至少包含两个 a 的行grep &quot;aaa*&quot; test.txt 「.」示例： 12345678# s..d 匹配在 s 和 d 之间一定有两个字符的所在行grep &quot;s..d&quot; test.txt# 匹配在 s 和 d 之间有任意字符，把「.*」当做一个整体看，表示除换行符外任意一个字符出现任意次grep &quot;s.*d&quot; test.txt# 匹配所有内容grep &quot;.*&quot; test.txt 「^」行首、「$」行尾示例： 12345678# 以 M 开头的行grep &quot;^M&quot; test.txt# 以 n 结尾的行grep &quot;n$&quot; test.txt# 匹配空白行grep -n &quot;^$&quot; test.txt 「[]」示例： 12345678910111213141516注意：中括号里面是不能匹配换行符的。# 匹配 s 和 i 之间，要么是 a、要么是 o。注意：一个中括号只匹配一个字符grep &quot;s[ao]id&quot; test.txt# 匹配任意一个数字grep &quot;[0-9]&quot; test.txt# 匹配以小写字母开头的行grep &quot;^[a-z]&quot; test.txt# 匹配不用小写字母开头的行grep &quot;^[^a-z]&quot; test.txt# 匹配不用字母开头的行grep &quot;^[^a-zA-Z]&quot; test.txt 「\」转义符示例 1234注意：「.」在正则里面表示任意一个字符，所以这里要加转义符。# 匹配使用「.」结尾的行grep &quot;\.$&quot; test.txt 其他示例 1234567891011# a 连续出现 3 次grep &quot;a\&#123;3\&#125;&quot; test.txt# 包含连续的 3 个数字的字符串所在行grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt# 匹配最少用连续三个数字开头的行grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt# 匹配在 s 和 i 之间，最少有一个 a，最多有三个 agrep &quot;sa\&#123;1,3\&#125;i&quot; test.txt 字符截取命令1、cut 字段提取命令「注意：cut 命令默认列之间的分隔符为 tab 键」123456789101112131415格式：cut [选项] 文件名选项： -f列号 提取第几列 -d分隔符 按照指定分隔符分割列举例： # 提取第二列 cut -f 2 test.txt # 提取第二、第三列，注意不是范围，是指定的列，中间以逗号分隔 cut -f 2,3 test.txt # 指定列之间的分隔符为「:」，默认为 tab 键 cut -d &quot;:&quot; -f 1,3 test.txt 注意：grep 命令表示在指定的文件中提取匹配的行，cut、awk 命令用来提取匹配的列。cut 命令中列之间的默认分割符为制表符即 tab 键。命令 grep -v [内容]，表示列出不包含指定的内容的行。grep 确认行，cut 确认列，利用这两个命令可以做一些操作，比如，获取所有普通用户的用户名：cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1。 cut 命令有一个局限就是「无法」识别空格（指识别起来超级麻烦扩展性还差）。对于空格的判断我们使用 awk 命令，但是因为 awk 比较复杂，所以能用 cut 的尽量不要用 awk，因为 cut 简单，但是存在局限性。 2、printf 命令1234567891011121314151617181920212223格式：printf &apos;输出类型输出格式&apos; 输出内容输出类型： %ns 输出字符串。n 是数字，指代输出几个字符 %ni 输出整数。n 是数字，指代输出几个数字 %m.nf 输出浮点数。m 和 n 是数字，指代输出的整数位数和小数位数。 eg：%8.2f 代表共输出 8 位数，其中 2 位是小数，6 位是整数输出格式： \a 输出警告音 \b 输出退格键，即 Backspace 键 \f 清除屏幕 \n 换行 \r 回车，即 Enter 键 \t 水平输出 Tab 键 \v 垂直输出 Tab 键举例： # 注意以下命令中是否加了单引号或双引号 printf %s 1 2 3 4 5 6 printf %s %s %s 1 2 3 4 5 6 printf &apos;%s %s %s&apos; 1 2 3 4 5 6 printf &apos;%s %s %s\n&apos; 1 2 3 4 5 6 printf 是格式化输出命令，类似于 echo 命令。注意：printf 后面不能直接加文件名，也不能接受管道符的内容。但是可以使用 printf &#39;%s&#39; $(cat 文件名) 的形式输出命令执行结果，需要注意的是 printf 不调整输出格式。 printf 命令没有 cat 和 echo 的自动格式化功能，为什么还要学习 printf 命令，是因为在 awk 命令中不能调用系统命令 cat 或者 echo，只能使用 printf。 在 awk 命令的输出中支持 print 和 printf 命令： print：print 会在每个输出之后自动加入一个换行符（Linux 默认没有 print 命令）。printf：printf 是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符。 注意：print 只能在 awk 中使用。printf 命令在 Linux 系统中直接使用的几率不大，主要是在 awk 命令中使用。 3、awk 命令，注意单引号1234567891011121314151617181920格式: awk &apos;条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ...&apos; 文件名条件： 一般使用关系表达式作为条件，如： x &gt; 10 x &lt;= 10动作： 格式化语句 流程控制语句举例： # $2 表示第 2 列，$4 表示第 4 列 awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt df -h | awk &apos;&#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&apos;典例：获取系统中根分区硬盘的使用率，可以用来报警，如果超过80则给管理员提示。 df -h | grep 只有根分区才存在的字符串 | awk &apos;&#123;printf $5&#125;&apos; | cut -d &quot;%&quot; -f 1 注意：awk 命令虽然是列提取命令，但是它处理数据的时候，是先读入一行数据，然后把这行数据所有的内容都复制给对应的变量，$1 代表第一列，依次类推，然后再判断条件是否符合，对满足条件的执行相应的动作。 注意：awk 默认是以空格或者制表符作为分割符的。 注意：BEGIN 必须大写。它位于大括号前，表示它是一个条件，只有满足了这个条件，其后的动作才会被执行。BEGIN 的作用是：在所有的数据读取之前，执行其后面相对应的动作。注意所有的动作都要用单引号括起来。 BEGIN 表示最先执行 BEGIN 条件后面的动作 12# 在进行真正的数据读取之前，即 awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt，打印「This is a transcript.」这句话awk &apos;BEGIN&#123;printf &quot;This is a transcript. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt FS 内置变量FS 的作用是指定分隔符的。注意：awk 命令在处理的时候是先读入第一行数据，然后再执行相应的动作。 12345# 输出结果中，第一行数据没有按照预期输出awk &apos;&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd# 改进：读取第一条数据之前，先把分隔符变成「:」awk &apos;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd END 表示最后执行 END 条件后面的动作 12# 表示在输出 &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125; 动作中的内容之后，输出 &#123;printf &quot;The end. \n&quot;&#125; 动作中的内容awk &apos;END&#123;printf &quot;The end. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt 关系运算符 12获取成绩大于 87 的用户名，grep -v Name 的作用是去掉标题行cat test.txt | grep -v Name | awk &apos;$4 &gt;= 87 &#123;printf $2 &quot;\n&quot;&#125;&apos; 4、sed 命令sed 是一种几乎包括在所有 Unix 平台（包括 Linux）的轻量级流编辑器。sed 主要是用来将数据进行选取、替换、删除、新增的命令。 sed 其实不是截取命令，其实是一个流的编辑器。相当于一个编辑器。既然已经学了 vim，为什么还有学习 sed 呢？因为 vim 命令只能修改文件，不能直接修改命令结果里的内容。要想使用 vim 修改命令的输出，则需要先把输出保存到文件当中，然后再用 vim 修改文件。sed 不光可以修改文件，因为其是一个流编辑器，所以可以从管道符接受数据来进行修改，即 sed 支持管道符操作。实际操作中主要用在对命令的结果进行操作，但是在 shell 编程中，sed 是一个重要的流数据处理编辑器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647格式： sed [选项] &apos;[动作]&apos; 文件名选项： -n 一般 sed 命令会把所有数据都输出到屏幕，如果加入此选项，则只会把经过 sed 命令处理的行输出到屏幕 -e 允许对输入数据应用多条 sed 命令编辑 -i 用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出，不光输出的数据会更改，源数据文件也会被更改。动作： a \: 追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用「\」代表数据未完结 c \: 行替换，用 c 后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用「\」代表数据未完结 i \: 插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用「\」代表数据未完结 d: 删除，删除指定的行 p: 打印，输出指定的行 s: 字符串替换，用一个字符串替换另外一个字符串。格式为「行范围/s/就字符串/新字符串/g」举例： # 查看文件的第二行，会输出全部内容 sed &apos;2p&apos; test.txt # 只显示经过 sed 命令处理的行 sed -n &apos;2p&apos; test.txt # 针对管道符结果操作 df -h | sed -n &apos;2p&apos; # 删除第二到第四行的数据，但不修改文件本身 sed &apos;2,4d&apos; test.txt # 在第二行后追加 hello sed &apos;2a hello&apos; test.txt # 在第二行前插入两行数据 sed &apos;2i hello \ world&apos; test.txt # 数据替换 sed &apos;2c No such person&apos; test.txt # 在第三行中，把 90 替换成 99 sed &apos;3s/90/99/g&apos; test.txt # sed 操作的数据直接写入文件 sed -i &apos;3s/90/99/g&apos; test.txt # 同时把 zhangsan 和 lisi 替换为空 sed -e &apos;s/zhangsan//g;s/lisi//g&apos; test.txt 字符处理命令1、排序命令 sort12345678910111213141516171819202122格式： sort [选项] 文件名选项： -f 忽略大小写 -n 以数值型进行排序，默认使用字符串型排序 -r 反向排序 -t 指定分割符，默认分隔符是制表符 -k n[,m] 按照指定的字段范围排序。从第 n 字段开始，m 字段结束（默认到行尾）举例： # 排序用户信息文件 sort /etc/passwd # 反向排序 sort -t /etc/passwd # 指定分隔符「:」。用第三字段开头，第三字段结尾排序，就是只用第三字段排序（类比数据库 order by 后面可以跟多个字段） sort -t &quot;:&quot; -k 3,3 /etc/passwd # -n 表示将提取的字段当成数字来对待 sort -n -t &quot;:&quot; -k 3,3 /etc/passwd 条件判断（即测试一个条件是否成立）1、按照文件类型进行判断（记住蓝色的就行，其它的了解） 2、两种判断格式123456789101112格式一: # 注意该命令执行后没有任何输出，要想知道该命令的输出结果，可以使用 $? 来获取结果，「echo $?」打印结果 # $? 的作用是判断上一条命令是否正确执行，正确执行返回 0，否则返回其他数字 test -e /root/install.log格式二: # 注意两端必须有空格 [ -e /root/install.log ]举例: # 第一个判断命令如果正确执行，则打印 yes，否则打印 no [ -d /root ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 这种判断主要用在 Shell 脚本当中，而在脚本当中最常用的判断格式是用中括号。 3、按照文件权限进行判断 举例：[ -w test.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 判断文件是否拥有写权限 注意：以上权限部分不区分所有者、所属组、其他人，只要该文件有这个权限，就为真。 4、两个文件之间进行比较（不常用） 5、两个整数之间比较（常用）-ne ： (not equal) 不相等-gt ： (greater than) 大于-lt ： (less than) 小于-ge ： (greater than or equal) 大于或等于-le ： (less than or equal)小于或等于 举例：[ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || &quot;no&quot; 判断 23 是否大于等于 22 6、字符串的判断（常用）注意：== 会把参数当成字符串 7、多重条件判断 流程控制if 语句1、单分支 if 条件语句1234567891011# 注意：中括号内两边都有空格，注意分号不能少if [ 条件判断式 ];then 程序fi或者if [ 条件判断式 ] then 程序fi 单分支条件语句注意点： if 语句使用 fi 结尾，和一般语言使用大括号结尾不同。[ 条件判断式 ] 就是使用 test 命令判断，所以中括号和条件判断式之间必须有空格。then 后面跟符合条件之后执行的程序，可以放在 [] 之后，用「;」分割。也可以换行写入，就不需要「;」了。 举例：判断分区使用率12345678910# 统计根分区使用率#!/bin/bash# 把根分区使用率作为变量赋值给 raterate=$(df -h | grep &quot;/dev/sda3&quot; | awk &apos;&#123;printf $5&#125;&apos; | cut -d &apos;%&apos; -f 1)if [ $rate -ge 80 ] then echo &quot;Warning! /dev/sda3 is full!&quot;fi 2、双分支 if 条件语句1234567if [ 条件判断式 ] then 条件成立时，执行的程序 else # 注意 else 后面没有 then 了 条件不成立时，执行的另一个程序fi 示例1：备份 mysql 数据库1234567891011121314151617181920212223#!/bin/bash# 同步系统时间。注意：必须联网才能同步系统时间ntpdate asia.pool.ntp.org &amp;&gt; /dev/null# 把当前系统时间按照「年月日」格式赋予变量 datedate=$(date +%y%m%d)# 统计 mysql 数据库的大小，并把大小赋予 size 变量size=$(du -sh /var/lib/mysql)if [-d /tmp/dbbak ] then echo "Date: $date!" &gt; /tmp/dbbak/dbinfo.txt echo "Data size: $size" &gt;&gt; /tmp/dbbak/dbinfo.txt cd /tmp/dbbak # 压缩的时候源文件可以写多个，中间用空格隔开就行 tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt; /dev/null rm -rf /tmp/dbbak/dbinfo.txt else mkdir /tmp/dbbak echo "Date: $date!" &gt; /tmp/dbbak/dbinfo.txt echo "Data size: $size" &gt;&gt; /tmp/dbbak/dbinfo.txt cd /tmp/dbbak tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt; /dev/null rm -rf /tmp/dbbak/dbinfo.txt 示例2：判断 apache 是否启动12345678910111213#!/bin/bash# 使用 nmap 命令扫描服务，并截取 apache 服务的状态，赋予变量 port# nmap 命令默认是没有装的# -sT 表示扫描指定服务器上开启的 tcp 端口port=$(nmap -sT 127.0.0.1 | grep tcp | grep http | awk '&#123;printf $2&#125;')if [ "$port" == "open" ] then echo "$(date) httpd is ok!" &gt;&gt; /tmp/autostart-acc.log else /etc/rc.d/init.d/httpd start &amp;&gt; /dev/null echo "$(date) restart httpd!" &gt;&gt; /tmp/autostart-err.logfi 如何判断系统中某个服务是否启动？此处已 apache 服务器为例。方式1：通过 ps aux | grep httpd 查找是否有 apache 的进程在运行。但是这种判断是有点问题的，比如有些情况下就算 apache 启动了，如果它死机了，服务是死掉的，但是进程还在却不能正常相应客户的请求。所以不是特别准确。 方式2：通过 netstat -tlun 判断端口，比如 80 端口，问题同上，不能确定你的 apache 是否能正常提供访问。它只能确定 apache 是启动的，而且不仅 apache 其他应用也可能会占用 80 端口。 方式3：最有效的办法是通过 nmap 命令，是一个远程扫描命令，是一个扫描工具，用它来扫描当前计算机，如果该工具能够正确连接 apache 的端口，它就会返回 apache 的状态是 open，证明 apache 是打开的而且是可访问的。推荐使用这个，比较准确一点。 3、多分支 if 条件语句1234567891011if [ 条件判断式1 ] then 当条件判断式 1 成立时，执行程序 1elif [ 条件判断式2 ] then 当条件判断式 2 成立时，执行程序 2......else # 注意没有 then 了 当所有条件都不成立时，最后执行此程序fi 举例：12345678910111213141516171819202122# 判断用户输入的是什么文件#!/bin/bash# 接受键盘的输入，并赋给变量 fileread -p &quot;Please input a filename: &quot; file# 判断 file 是否为空if [ -z &quot;$file&quot; ] then echo &quot;Error,please input a filename.&quot; exit 1elif [ ! -e &quot;$file&quot; ] then echo &quot;Your input is not a file.&quot; exit 2elif [ -f &quot;$file&quot; ] then echo &quot;$file is a regulare file.&quot;elif [ -d &quot;$file&quot; ] then echo &quot;$file is a director.&quot;else echo &quot;$file is an other file.&quot;fi 注意：对于 if else 中的报错程序，如果报错了一定要退出程序，否则程序还会继续向下执行。 case 语句多分支 case 条件语句：case 语句和 if…elif…else 语句一样都是多分支条件语句，不过和 if 多分支条件语句不通的是，case 语句只能判断一种条件关系，而 if 语句可以判断多种条件关系。 12345678910111213141516case $变量名 in &quot;值1&quot;) 如果变量的值等于值 1，则执行程序 1 # 表示程序段的结束，不能省略 ;; &quot;值2&quot;) 如果变量的值等于值 2，则执行程序 2 # 表示程序段的结束，不能省略 ;; ... 省略其他分支 ... # 注意 * 号是没有引号的，其他的是有引号的 *) 如果变量的值都不是以上的值，则执行此程序 ;;# 注意最后的 esac esac 举例：12345678910111213#!/bin/bashread -p &quot;Please choose yes/no: &quot; -t 30 chocase $cho in &quot;yes&quot;) echo &quot;Your choose is yes.&quot; ;; &quot;no&quot;) echo &quot;Your choose is no.&quot; ;; *) echo &quot;Your choose is error.&quot; ;;esac for 循环1、语法一12345# 值之间的分隔符为空格for 变量 in 值1 值2 值3 ... do 程序 done 注意：后面有几个值，for 循环执行几次，每次执行都会把值赋给变量。注意：in 后面的值不管是空格还是换行，只要是分开的，系统就把它当场一个内容即一个值。 举例：12345#!/bin/bashfor time in morning noon afternoon evening do echo &quot;This time is $time.&quot; done 这种循环很笨，但是还存在的理由：就是更加利于系统管理，因为 in 后面的值可以从内容中获取，即循环的次数可以不确定，比如下面的例子：123456789#!/bin/bash# 批量解压缩脚本cd /testls *.tar.gz &gt; ls.logfor i in $(cat ls.log) do tar -zxf $i &amp;&gt; /dev/null donerm -rf /test/ls.log 2、语法二1234for ((初始值;循环控制条件;变量变化)) do 程序 done 在 Linux 中，只有用双小括号括起来，才可以进行加减乘除这种数值运算。两种循环的区别：第一种循环不知道循环次数，第二种循环知道循环次数。 示例1：12345678#!/bin/bash# 从 1 加到 100s = 0for (( i=1;i&lt;=100;i=i+1 )) do s=$(( $s+$i )) doneecho &quot;The sum result is: + $s&quot; 示例2：1234567891011121314151617181920#!/bin/bash# 批量添加指定数量的用户read -p &quot;Please input username: &quot; -t 30 nameread -p &quot;Please input the number of users: &quot; -t 30 numberread -p &quot;Please input the password of users: &quot; -t 30 passwordif [ ! -z &quot;$name&quot; -a ! -z &quot;$number&quot; -a ! -z &quot;$password&quot; ] then # 判断 number 是否合法，即是否为纯数字 # 把以任意数字开头且以任意数字结尾的替换为空，即将纯数字替换为空 y = $(echo $number | sed &apos;s/^[0-9]*$//g&apos;) if [-z &quot;$y&quot;] then for (( i=1;i&lt;=$number;i=i+1 )) do /usr/sbin/useradd $name$i $&gt;/dev/null echo $password | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null done fifi while 循环1、while 循环是不定循环，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和 for 的固定循环不太一样了。注意：在 while 的执行语句中需要对其条件判断式不断改变，否则要是永远成立，则死循环了。 1234while [ 条件判断式 ] do 程序 done 举例：12345678910#!/bin/bash# 从 1 加到 100i=1s=0while [ $i -le 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) doneecho &quot;The sum is: $s&quot; 2、until 循环，和 while 循环相反，until 循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。 1234until [ 条件判断式 ] do 程序 done 举例：12345678910#!/bin/bash# 从 1 加到 100i=1s=0until [ $i -gt 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) doneecho &quot;The sum is: $s&quot; 注意：Shell 是脚本语言，脚本语言的好处就是所见即所得，即写完的所有脚本语言都不需要编译就可以直接运行，但是它不是不需要编译，而是在执行的同时进行编译，省略简化了编译过程，好处是编程更加简单，坏处是效率要更慢。Shell 语言不适合进行大量的数据运算，其最大的作用是帮助管理员减少重复操作。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(十一)]]></title>
    <url>%2F2018%2F10%2F25%2FLinux-2018-10-25-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(十一) —— Shell 基础 Shell 概述1、Shell 是什么？Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统程序，用户可以用 Shell 来启动、挂起、停止甚至编写一些程序。 Shell 还是一个功能相当强大的编程语言。Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。 2、Shell 的分类Bourne Shell：从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh。 C Shell：C Shell 主要在 BSD (Berkeley Software Distribution，是一个操作系统的名称，衍生自 Unix，被称为伯克利 Unix) 版的 Unix 系统中使用，其语法和 C 语言相类似而得名。 Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh、ksh、Bash、psh、zhs；C 家族主要包括：csh、tcsh。 Bash (Bourne Again Shell): Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。 3、Linux 支持的 Shell在 「/etc/shells」文件中保存着当前系统支持的 Shell。注意：只要是系统支持的 Shell，我们就可以通过输入对应的 Shell 名字来进行切换。 4、echo 输出命令echo 是反射、回声的意思。是用来输出的命令。格式：echo [选项][输出内容]；选项：-e，支持反斜杠控制的字符转换。eg：echo &#39;Hello World!&#39; 注意：感叹号在 Shell 中有特殊的作用，所以这里使用单引号。 5、Linux 中常见的转义符 eg：echo -e &quot;ab\bc&quot; 删除左侧字符；输出结果：ac；分析：\b 代表的是退格键。eg：echo -e &quot;a\tb\tc\nd\te\tf&quot; 制表符与换行符。eg: echo -e &quot;\e[1;31m abcd \e[0m&quot; 带颜色输出内容；输出结果：红色的 abcd；分析：31m=红色；「\e[1;」表示开启颜色输出，「\e[0m」 表示结束颜色输出。 6、第一个 Shell 脚本 1234#!/bin/Bash#The first program#Author: YanChongsheng E-mail: yanchongsheng@gmail.comecho -e "YanChongsheng is the most handsome man in China." 注意：「#!/bin/Bash」这句话不是注释，而是标称，标称以下内容是 Shell 脚本。在 Linux 中以 # 号开头的是注释。 7、脚本执行 方式一：赋予执行权限，直接运行 赋予权限：chmod 755 hello.sh 运行脚本：./hello.sh 方式二：通过 Bash 调用执行脚本：bash hello.sh 注意：使用 base 执行脚本的时候，脚本甚至可以没有执行权限。它的意思是通过这个 Shell 来解释这个 shell 脚本文件，所以只要里面的内容是正确的，连执行权限都可以不用给就可以执行，但是最习惯的执行方法还是第一种。 cat 命令给其加上选项 -A ：表示查看所有的文件内容，包括隐藏字符，例如回车符就属于文件中的隐藏字符。在 Linux 中，回车符识别为「$」号。但是 Windows 中的回车符是「^M$」，表示这个 shell 是在 windows 中编辑完成的，要想在 Linux 中执行，就需要进行转换，利用命令: dos2unix [文件名]。注意：如果 dos2unix 命令没有则需要安装：yum -y install dos2unix。 Bash 的基本功能1、历史命令1234格式：histor [选项][历史命令保存文件]选项： -c 清空历史命令 -w 把缓存中的历史命令写入历史命令保存文件「~./bash_histor」 注意：每次登陆之后所敲的命令都会放在 history 即内存中，并不会放入 ~/.bash_history 文件，而是等正常退出以后，才会将内存中的历史命令写入到 ~/.bash_history 文件中的。注意：-c 会清除内存中和文件中的所有的历史命令。 历史命令默认会保存 1000 条，可以在环境变量配置文件「/etc/profile」中进行修改 HISTSIZE=1000 注意：重新登录以后才会生效。如果超过 1000，则删除第 1 条命令，保存第 1001 条命令。 历史命令的调用： 使用上、下箭头调用以前的历史命令 使用「!n」调用第 n 条历史命令 使用「!!」执行上一条命令 使用「!字符」执行最后一条以该字符串开头的命令 2、命令别名：设定命令别名：alias 别名=’原命令’。注意：用命令行方式定义的别名它只会临时生效，一旦系统重启，这个别名就会消失。查询命令别名：alias 别名 3、命令执行顺序 第一顺位：执行用绝对路径或相对路径执行的命令。 第二顺位：执行别名。 第三顺位：执行 Bash 的内部命令。 第四顺位：执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令。 输出环境变量：echo $PATH 让别名永久生效：vim /root/.bashrc 注意：修改的是用户对应家目录下的「./bashrc」文件。rc 可以简单的理解为 user config 的简写，取 user 的最后一个字母 r 和 config 的第一个字母 c 组成 rc。 删除别名：unalias 别名 4、Bash 常用快捷键 5、标准输入输出 设备 设备文件名 文件描述符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/stdout 1 标准输出 显示器 /dev/stderr 2 标准错误输出 6、输出重定向 注意：不是所有的命令都可以使用输出重定向的，这个命令必须得有输出才可以。注意：错误输出中，2 和 大于号之间不能有空格。 注意：「/dev/null」是 Linux 中的一个特殊文件，可以把它当成垃圾箱，相当于不保存任何输出。 7、输入重定向「注意：输入重定向了解即可」123456格式：wc [选项][文件名]选项： -c 统计字节数 (byte) print the byte counts -m 统计字符数 (character) print the character counts -w 统计单词数 (word) -l 统计行数 (line) 注意：wc 可以统计键盘输入，输入的行数、单词数、字节数，输入完成之后按 ctrl + d，结束并进行统计。注意回车换行符也会被当成字节进行统计。 把文件作为命令的输入：命令&lt;文件。eg：wc &lt; anaconda-ks.cfg 8、多命令顺序执行 eg：ls; date; cd /user; pwdeg: 命令 &amp;&amp; echo yes || echo no 命令 dd 是磁盘或者说是数据复制的命令，但是它不是 cp，cp 命令只能复制文件，但是 dd 命令能复制特殊文件，也能复制分区甚至整个硬盘，不仅复制分区或硬盘的数据，还复制分区或硬盘的文件系统。dd 主要是用来进行磁盘复制。 9、管道符1格式：命令1 | 命令2 命令1 的正确输出作为命令2 的操作对象。 注意：命令1 必须正确输出，否则命令2 不会正常执行。 10、grep 命令，在文件中搜索符合条件的字符串123456格式：grep [选项] &quot;搜索内容&quot;选项： -i 忽略大小写 -n 输出行号 -v 反向查找 (注意：-v 查找的是不匹配的行，即反向查找) --color=auto 搜索出的关键字用颜色显示 通配符 Bash 中的特殊符号 注意：通配符是用来匹配文件名的，起码在 Linux 系统当中是用来匹配文件名的。 $ 和 $() 的区别是：$ 是用于调用变量的值；而 $() 是用来引用系统命令。 Bash 的变量1、变量设置规则 变量名称可以由字母、数字、下划线组成，但是不能以数字开头。 在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。 变量用等号连接值，等号左右两侧不能有空格。 变量的值如果有空格，需要使用单引号或双引号包括。 在变量的值中，可以使用「\」转义符。 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名” 或用 ${变量名} 包含。 如果是把命令的结果作为变量值赋值给变量，则需要使用反引号或 $() 包含命令。 环境变量名建议大写，便于区分。 环境变量名大写，目的是为了区分。因为环境变量会让 Linux 当中所有的 Shell 都能使用，Linux 的系统命令也是在所有的 Shell 中都能使用，但是系统命令都是小写，为了让系统命令和环境变量区分开，建议把环境变量都写成大写。 2、变量分类 用户自定义变量 环境变量：这种变量中主要保存的是和系统操作环境相关的数据。 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。 预定义变量：是 Bash 中已经定义好的变量，变量名不能自定义，变量作用也是固定的。 其实位置参数变量是预定义变量的一种，由于位置参数变量相对来说较多，所以我们习惯上将位置参数变量单独作为一个分类。所以这两种变量的限制是一样的，只能更改值。 3、本地变量用户自定义变量又称为本地变量。「$变量名」的作用是调用变量。123456789101112131415# 定义变量aa=123# 变量叠加aa=&quot;$aa&quot;456 # 结果：123456aa=$&#123;aa&#125;789 # 结果：123456789# 变量调用echo $name# 变量查看set# 变量删除unset name set 命令：表示查看系统的所有变量，包括系统的环境变量，以及系统变量，自定义的变量。总结：变量的定义、叠加、调用、查看、删除；变量的概念、变量的规则、变量的分类。 4、环境变量是什么？用户自定义变量只在当前 Shell 中生效。（使用命令行定义的）环境变量会在当前 Shell 和这个 Shell 的所有子 Shell 当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的 Shell 中生效。 5、设置环境变量1234567891011# 声明变量export 变量名=变量值# 查询变量env# 删除变量unset 变量名# 将已经定义好的本地变量变为环境变量export 变量名 注意：系统当前本身就是在一个 Shell 里面，我们可以直接输入 csh、或 bash 表示进入对应的 Shell，而系统本身的 shell 就是 csh 或者 bash 的父 Shell，这样就创建了一个子 Shell，当然子 Shell 里面还可以有子子 Shell。 如何查询和确定 Shell 呢？使用命令 pstree，它的作用是确定进程数。 6、系统常见环境变量PATH：系统查找命令的路径。12345# 输出 PATHecho $PATH# PATH 变量叠加PATH=&quot;$PATH&quot;:/root/sh PS1：定义系统提示符的变量 eg：PS1=[\u@\h \W]\$。注意习惯在 $ 最后加一个空格，要不然你的命令会紧挨着提示符 # 或者 $。这种写法只是临时生效。 注意：env 是专门用来查看当前系统的环境变量的。严格来说 PS1 并不是环境变量，因为 env 命令查看不到，必须使用 set 命令查看。虽然它不是环境变量，但是它是系统预留专门用作定义系统操作环境的一个变量。它是环境变量的一个子分支。 注意：Linux 以冒号为分割符号。 7、位置参数 位置参数变量最大的作用就是向程序中传递需要的值。它的好处是可以在命令执行的同时接受参数。 注意：位置参数变量的名称和作用都是固定的。我们能做的只是在里面传入不同的值。 注意：要想进行数值运算，必须加 $(()) 双小括号括起来，它才能进行数值计算，这是 Linux Shell 的标准格式。 注意：$# 不会计算命令本身，它计算的仅仅只是参数。 $* 和 $@ 的区别：$* 中的所有参数看成是一个整体。$@ 中的每个参数看成是独立的。 8、预定义变量 其实位置参数变量就是预定义变量当中的一个分类，其特点是不能改变变量名，变量的作用也是固定的。 $? 用来接收和判断上一条命令是否正确执行。注意：&amp;&amp; || 利用的就是 $? 来判断上一条命令是否正确执行的。 9、接受键盘输入，read 会把键盘输入的数据赋值给后面的变量中123456格式：read [选项] [变量名]选项： -p &quot;提示信息&quot;：在等待 read 输入时，输出提示信息 -t 秒数：read 命令会一直等待用户输入，使用此选项可以指定等待时间 -n 字符数：read 命令只接受指定的字符数，就会执行 -s：隐藏输入的数据，适用于机密信息的输入 注意：如果不加 -n 选项，read 命令在回车以后才会结束，如果加了 -n 选项，则字符数达到 -n 执行的数字，则自动结束 read 并执行。 Bash 的运算符注意：Linux 的 Shell 中变量的类型默认都是字符串型。 1、declare 声明变量类型12345678格式：declare [+/-][选项] 变量名选项： -：给变量设定类型属性 +：取消变量的类型属性 -i：将变量声明为整型（integer） -x：将变量声明为环境变量 -p：显示指定变量的被声明的类型 2、数值运算1234567891011121314aa=11bb=22# 方法1declare -i cc=$aa+$bb# 方法2# 利用 expr 或 let 数值运算工具。注意：「+」号左右两侧必须有空格。cc=$(expr $aa + $bb)# 方法3# $((运算式)) 或 $[运算式]cc=$(($aa+$bb))cc=$[$aa+$bb] 3、运算符 注意：此处数字越大，优先级越高。 4、变量测试与内容替换 主要作用：通过 x 的值来确定 y 的情况。这块内容了解即可，完全可以 if 语句来替代，只是系统提供的更简洁、高效一点，用到的时候查一下能看懂就行，不要可以去记忆。 环境变量配置文件1、source 命令123格式：source 配置文件或格式：. 配置文件 注意：source 命令的作用是让你的配置文件生效，即让系统重新读取一遍配置文件。（正常情况下配置文件生效需要重新登录一次，但是利用 source 命令可以直让配置文件生效）。注意：点「.」和配置文件之间有空格，点「.」其实就是 source 的缩写。 2、环境变量配置文件简介环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如 PATH、HISTSIZE、PS1、HOSTNAME 等默认环境变量。 系统中主要的 5 类环境变量配置文件： /etc/profile 的作用：USER 变量、LOGNAME 变量、MAIL 变量、PATH 变量、HOSTNAME 变量、HISTSIZE 变量、umask、调用 /etc/profile.d/*.sh 文件。 ~/.bash_profile 的作用：调用了 ~/.bashrc 文件、在 PATH 变量后面加入了 「:$HOME/bin」这个目录。 ~/.bashrc 的作用：定义默认别名、调用 /etc/bashrc。 /etc/bashrc 的作用：PS1 变量、umask、PATH 变量、调用 /etc/profile.d/*.sh 文件。 /etc/profile.d/*.sh 注意：只要是保存在 /etc 目录中的，表示对所有登录到该 Linux 系统的用户都生效。~/ 表示当前用户的家目录，「.」表示该文件是隐藏文件，这些配置文件针对的是当前用户。「~」表示家目录的意思。 3、环境变量配置文件作用 注意：环境变量默认赋值的时候分两种情况1.一种是用户通过输入用户名和密码的正常登陆。2.一种是用户通过命令切换到子 Shell 的登陆，这种情况是没有输入用户名密码过程的。这两种不同的登陆方法，它读取的配置文件是不一样的。 注意：环境变量配置文件它们之间是有优先级的。越后面读取的配置文件，其优先级越高，因为后面定义的变量会覆盖前面的变量。 需要输入用户名密码的正常登录情况配置文件的读取顺序：/etc/profile「 ——&gt; …… ——&gt; /etc/sysconfig/i18n (新版的 Linux 为 /etc/locale.conf) 这些都是 /etc/profile 文件中调用的子文件或子子文件」当完成 /etc/profile 的所有调用以后 /etc/profile 就会将它的调用传递给下一个环境变量配置文件即 ~./bash_profile，然后照着上图依次往下传递。 发现 /etc/profile 和 /etc/bashrc 中有很多内容是重复的，如 PATH、umask、PS1，注意这个不是单单只是重复。你会发现 /etc/bashrc 中重复定义变量的地方有这样的注释「We’re not a login shell」即该文件定义的是没有登录情况的 Shell 的环境变量。 4、注销时生效的环境变量配置文件~/.bash_logout 默认为空，可以在里面写一些退出登录时候的操作，比如清空历史命令等操作。 5、其他配置文件~/.bash_history 历史命令保存的地方。一般不要清空，但是有一种情况例外，比如你给某个服务设置密码，如 mysql，mysql 设置密码的时候使用的是明文（注意：是明文）系统命令，它会把密码记录在历史文件中，所以要清空明文密码记录。 6、Shell 登录信息1.本地终端欢迎信息：/etc/issue 注意：欢迎信息不要写 welcome 之类的，应该写的是警告信息。注意：针对的是本地登录。 2.远程 终端欢迎信息：/etc/issue.net注意：转义符在 /etc/issue.net 文件中不能使用，即本地终端的转义符在这里都不能使用，这里只能写纯文本信息。是否显示此欢迎信息由 ssh 的配置文件 /etc/ssh/sshd_config 决定，加入「Banner /etc/issue.net」行才能显示。（记得重启 ssh 服务）。重启 ssh 服务：service sshd restart 3.本地和远程登录后欢迎信息：/etc/motd不管是本地登录，还是远程登录，都可以显示此欢迎信息。但是，它是登录后的欢迎信息。刚才那两个文件是登录前的提示信息。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(十)]]></title>
    <url>%2F2018%2F10%2F24%2FLinux-2018-10-24-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(十) —— 文件系统管理 分区和文件系统1、分区类型 2、分区表示方法 3、分区的设备文件名其中，sd 表示硬盘的接口类型，a 代表第一块硬盘，1、2、3、4 代表 4 个主分区。注意：分区的设备文件名是固定的，我们只需要记下来，能看懂就行。注意：逻辑分区最少从 5 开始，1、2、3、4 这 4 个数字是留给主分区或扩展分区用的。 4、文件系统了解文件系统 ext、ext1、ext2、ext3、ext4。 小结：分区的表示方式，采用 /dev 下的 sd 代表 SATA 硬盘接口，hd 代表 IDE 硬盘的接口，a、b、c、d 代表第几块硬盘，1、2、3、4 代表主分区或扩展分区，5、6、7、8、… 代表逻辑分区。 文件系统常用命令1、文件系统查看命令 df123456789101112作用： df - report file system disk space usage格式： df [选项] [挂载点]选项： -a 显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs -h 使用习惯单位显示容量，如 KB、MB、GB 等 -T 显示文件系统类型 -m 以 MB 为单位显示容量 -k 以 KB 为单位显示容量。默认就是以 KB 为单位 2、统计目录或文件大小123456789101112131415作用： du - estimate(估计) file space usage格式： du [选项] [目录或文件]选项： -a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量 -h 使用习惯单位显示磁盘占用量，如 KB、MB、GB 等 -s 统计总占用量，而不列出子目录和子文件的占用量举例： # 统计 /etc/ 目录大小 du /etc/ 输出结果：它会列出该目录下所有子目录各占用了多大空间，最后统计这个目录的总大小 注意：du 命令是用来统计目录或文件大小的，但是一般不用它来统计文件大小，因为通过「ls -l」命令就可以很清楚的看到文件的大小。但是 ls 命令在统计目录大小的时候，它只会统计该目录下一级子目录和子文件的文件名占用了多大空间，并不会统计该目录下子目录当中的数据或者文件当中的数据占用了多大空间。 所以你会看到 ls 命令在显示目录的大小的时候一般就只有几 KB，这也是 ls 命令的局限性所在。要想统计目录的大小就必须使用 du 命令。 3、du 命令和 df 命令的区别 df 命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）。 du 命令是面向文件的，只会计算文件后目录占用的空降。 Linux 系统要定期重启，来释放被进程或者已经删除的文件所占用的硬盘空间。要以 df 命令看到的剩余空间才是真正可以使用的空间。 4、文件系统修复命令 fsck123456格式： fsck [选项] 分区设备文件名选项： -a 不用显示用户提示，自动修复文件系统 -y 自动修复。和 -a 作用一致，不过有些文件系统只支持 -y 系统会自动执行该命令进行修复检测，一般不用该命令，除非真的需要。没事别用，否则有可能会造成系统崩溃。该命令了解即可。 5、显示磁盘状态命令 dumpe2fs注意：该命令只针对 ext 文件系统有效。12345格式： dumpe2fs 分区设备文件名举例： dumpe2fs /dev/sda3 | more 「| more」 分屏显示，即将很多内容，分成多段来显示。主要是用来查看超级块的信息的，可以看到分区中一个数据块的大小。注意：每个数据块中(常见的为 4kb)，只能保存一个文件中的数据。 在 Centos7 系统下使用 dumpe2fs 查看文件系统查不到对应的超级块，原因是 Centos7 默认安装的文件系统是 XFS 类型而不是 ext2/ext3/ext4。对于 XFS，使用 dumpe2fs 命令是找不到对应的超级块，可以使用 xfs_info 来查看分区信息。CentOS 7 查看磁盘状态 小结：du 只统计文件大小，df 不光统计文件大小，还要统计被系统占用的空间。所以用 du 看文件大小更准确，用 df 看剩余空间更准确。 6、查询与自动挂载123456# 查询系统中已经挂载的设备，-l 会显示卷标名称mount [-l]# 依据配置文件 /etc/fstab 的内容，自动挂载# 按照配置文件的需求，把所有的分区重新挂载一遍，a 即 allmount -a mount 是用来进行设备挂载的命令，Linux 中所有的可存储设备：包括硬盘、光盘、u盘、软盘、移动硬盘等，都必须挂载之后才能使用，只是硬盘的挂载是系统自动进行的，其他的就需要手工挂载了。 挂载：Linux 中每一个硬件都有一个设备文件名，也会有一个挂载点（空目录），挂载就是把设备文件名和挂载点联系起来。只有通过访问挂载点，来访问这个设备，即设备是不能直接访问的，得需要通过挂载点才能访问。 7、挂载命令格式123456789101112131415格式： mount [选项] 设备文件名 挂载点选项： -t 文件系统 加入文件系统类型来指定挂载的类型，如 ext3、ext4、iso9660 等文件系统 -L 卷标名 挂载指定卷标的分区，而不是安装设备文件名挂载。卷标：就相当于给你的分区起一个别名，意义不大，不写也无所谓 -o 特殊选项 可以指定挂载的额外选项举例： # 重新挂载 /home 分区，并使用 noexec 权限 mount -o remount,noexec /home # 测试，发现不能执行了 cd /home &amp;&amp; vim hello.sh &amp;&amp; chmod 755 hello.sh &amp;&amp; ./hello.sh # 最后记得改回去，要不会影响系统启动的 mount -o remount,exec /home 以下为 -o 的特殊选项： 注意：mount -o 的这些选项参数，针对的都是分区。-o 后面可以同时跟多个选项，选项之间以逗号分隔。 7、挂载示例（1）挂载光盘1234567# 建立挂载点mkdir /mnt/cdrom/# 挂载光盘mount -t iso9660 /dev/cdrom/ /mnt/cdrom/或mount /dev/sr0 /mnt/cdrom/ 只要是空目录都可以作为挂载点。注意光盘是只读的。 （2）卸载命令12345格式： umount 设备文件名或挂载点举例： umount /mnt/cdrom 用完光盘之后，必须手动卸载，否则光驱不会弹出来。注意：不要在光盘目录下卸载，否则会报设备正忙的错。 （3）挂载 U 盘12345# 查看 U 盘设备文件名fdisk -l# 挂载 U 盘mount -t vfat /dev/sdb1 /mnt/usb/ 注意：Linux 默认是不支持 NTFS 文件系统的。注意：U 盘的设备文件名不是固定的，因为 U 盘跟硬盘采用同样的命名规则，如果系统中只有一块硬盘，U 盘就会识别为 sdb，依次类推，如果系统中已经有两块硬盘，则 U 盘就会识别为 sdc。即它是需要自动识别的，不需要去分配，只要插入，它就会自动去识别。在插入 U 盘的时候，鼠标一定要点到虚拟机里面（VMware 中），否则它就不是 Linux 虚拟机识别 U 盘了，而是 Windows 去识别 U 盘了。Linux 中把 fat16 文件系统识别为 fat，fat32 文件系统识别为 vfat。注意：先卸载再拔出 U 盘。 8、Linux 挂载 NTFS 文件系统的硬件设备由于 Linux 本身不支持 NTFS 文件系统，所以需要利用第三方软件让 Linux 支持 NTFS 文件系统。123456781、下载 NTFS-3G 插件http://www.tuxera.com/community/ntfs-3g-download/2、安装 NTFS-3G 插件解压 &amp;&amp; 进入压缩目录 &amp;&amp; 「./configure」编译器准备。没有指定安装目录，安装到默认位置。 &amp;&amp; 编译 &amp;&amp; 安装3、插入 NTFS 文件系统的外设移动硬盘，插入硬盘的时候，鼠标要点进 VMware 虚拟机里面4、挂载mount -t ntfs-3g 分区设备文件名 挂载点 fdisk 分区Linux 中真正的手工分区命令 fdisk。要掌握如何利用 fdisk 命令给 Linux 新建一个新的分区。 1、添加新硬盘注意：添加硬盘的时候，必须先断电，否则虚拟机中硬件是无法添加和删除的，真实机也是这样的。 2、查看新硬盘使用「fdisk -l」命令查询一下新硬盘是否被识别了。该命令最主要的作用就是查询系统当中有多少可以被识别的硬件设备。 3、使用 fdisk 命令分区fdisk /dev/sdb 主要知道 d、l、m、n、p、q、w 的作用即可。 4、重新读取分区表信息，使得新添加的分区生效partprobe 5、格式化分区，注意扩展分区是不能格式化和写入数据的，但是逻辑分区可以mkfs -t ext4 /dev/sdb1 6、建立挂载点并挂载分区mkdir /disk1 &amp;&amp; mount /dev/sdb1 /disk1/ 注意：使用 fdisk -l 命令只能看到分区是否被正常分配，但是不能知道分区是否被 Linux 挂载，要想知道分区是否被挂载可以使用 mount 或 df 命令。 7、分区的自动挂载在 Linux 当中，如果使用命令来挂载，一旦重启命令操作的结果就会消失。要想永久生效，就要写入文件。自动挂载归根结底是要写入 /etc/fstab 文件。 第一个字段：最好使用 UUID。因为设备文件名有个问题，如果不小心把分区的顺序颠倒了，或者升级了系统内核，或者添加了新的硬盘，这种情况非常容易造成系统崩溃，但是系统是按照原先的顺序进行系统的启动和调用的。UUID 的作用相当于给每个分区起了一个唯一识别号，不管分区顺序如何变，分区的 UUID 号都是不会变的。可以使用「dumpe2fs -h 分区设备文件名」可以查看到分区的 UUID。 第四个字段：defaults 指分区自动挂载的时候使用默认权限，跟 mount 挂载的时候通过 -o 指定挂载权限是一回事。 第五个字段：注意这里的自动备份针对的是分区，即目录必须是分区才可以。自动备份到 lost+found 目录下。 第六个字段：一般我们新添加的分区，不应该等于 1，因为 1 是系统分配的，其优先级本应该最高，所以说我们分配的分区优先级应该比 2 大（数字越大，优先级越低）。注意：/etc/fstab 文件是重要的系统启动文件，修改的时候要特别小心，否则会把系统搞崩溃。 注意：当修改完 /etc/fstab 文件后不要着急重启，先执行「mount -a」命令，如果 /etc/fstab 文件中有错误，会有提示，不至于重启的时候系统崩溃。 该命令的作用是根据配置文件 /etc/fstab 的内容，自动挂载。 如果还是不小心把 /etc/fstab 文件中的内容写错了，是还有修复的机会的。重启系统，输入 root 用户的密码，这时候会进入到系统，但是却发现不能编辑 /etc/fstab 文件，因为分区在报错了之后，挂载的时候挂成了只读权限，所以任何文件都无法修改，这个时候只需要重新把根分区挂载成读写权限就可以了「mount -o remount,rw /」。注意：/etc/fstab 文件修复，只能修复这个文件的报错，但是如果你在这个文件中把根分区 / 写错了，则无法修复，系统会直接崩溃。 分配 swap 分区1、free 命令12# 查看内存与 swap 分区使用情况，选项 -h 人性化显示大小free cached(缓存)：是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程。buffer(缓冲)：是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程。 2、添加 swap 分区操作步骤123456789101112131415# 1、新建 swap 分区# 注意：把分区 ID 改为 82fdisk /dev/sdb# 2、格式化，注意分区设备名mkswap /dev/sdb6# 3、加入 swap 分区，注意分区设备名swapon /dev/sdb6# 取消 swap 分区swapoff /dev/sdb6# 4、swap 分区开机自动挂载vim /etc/fstab写入内容：/dev/sdb6 swap swap defaults 0 0]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(九)]]></title>
    <url>%2F2018%2F10%2F23%2FLinux-2018-10-23-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(九) —— 权限管理 ACL 权限ACL 权限简介与开启1、ACL 权限简介 ACL 权限就是专门用作解决身份（u、g、o）不足的问题。它跟 Windows 中的权限很类似，即 ACL 权限不再管以前存在的身份（u、g、o），而是针对某个用户或者组，添加相应的权限。 2、查看分区 ACL 权限是否开启123# dumpe2fs 命令是查询指定分区详细文件系统信息的命令# -h 选项：仅显示超级块中信息，而不显示磁盘块组的详细信息dumpe2fs -h /dev/sda3 命令：df -h 查看当前系统有哪些分区。df 命令是用来查看分区使用状况的，或者说占用空间容量的，但是它可以看到其对应的分区。/dev/shm 分区是一个假的分区。 注意：是否支持 ACL 权限，不是文件支持，也不是用户支持，而是文件所在的分区是否支持 ACL 权限。即 ACL 权限本身是用户对这个文件有没有相应的 rwx 权限，但是必须文件所在的分区支持才可以来分配。 注意查看默认挂载选项 default mount options，可以看到支持 acl。当前的 Linux 当中，所有的分区，默认挂载的时候都已经支持 ACL。 3、临时开启分区 ACL 权限12# 重新挂载根分区，并挂载加入 ACL 权限mount -o remount,acl / 4、永久开启分区 ACL 权限12345# 在权限位，一般是 defaults 后面加上 acl，分隔符为逗号，即「defaults,acl」vim /etc/fstab# 重新挂载文件系统或重启系统，使修改生效mount -o remount 注意：defaults 表示的是分区自动挂载时候的默认选项，Linux 中默认已经支持 ACL 选项了。如果某个分区不支持，可以直接在 defaults 后面加「,acl」然后保存重启。 ACL 权限是为了解决 u、g、o 三个身份不足的情况。ACL 权限的开启方法，了解即可，一般默认都开启了。 查看与设定 ACL 权限1、查看 ACL 命令1getfacl 文件名 注意：用户 shiting 和用户组 tgroup2 并不是 /project 目录的所有者和所属组，但它依然对该目录有相应的权限，这就是 ACL 权限。 2、设定 ACL 权限的命令12345678910格式： setfacl 选项 文件名选项： -m 设定 ACL 权限 -x 删除指定的 ACL 权限 -b 删除所有的 ACL 权限 -d 设定默认 ACL 权限 -k 删除默认 ACL 权限 -R 递归设定 ACL 权限 3、给用户设定 ACL 权限1234567891011# 示例命令mkdir /projectuseradd student1useradd student2useradd shitinggroupadd tgroupgpasswd -a student1 tgroupgpasswd -a student2 tgroupchown root:tgroup /projectchmod 770 /projectsetfacl -m u:shiting:rx /project 注意：给用户 shiting 赋予 r-x 权限，使用「u:用户名:权限」的格式。注意：权限的后面多了一个「+」号，就表示设置 ACL 权限成功了。要想看具体的 ACL 权限，就要使用前面讲的 getfacl 命令。 4、给用户组设定 ACL 权限123groupadd tgroup2# 为组 tgroup2 分配 ACL 权限。使用「g:组名:权限」的格式setfacl -m g:tgroup2:rwx /project 最大有效权限与删除 ACL 权限1、最大有效权限 maskmask 是用来指定最大有效权限的。如果我给用户赋予了 ACL 权限，是需要和 mask 的权限「相与」才能得到用户的真正权限。 注意：mask 不会影响所有者的权限，但是会影响 ACL 和所属组的权限。 2、修改最大有效权限12# 设定 mask 权限为 r-x，使用「m:权限」的格式setfacl -m m:rx 文件名 3、删除 ACL 权限12345678# 删除指定用户的 ACL 权限setfacl -x u:用户名 文件名# 删除指定用户组的 ACL 权限setfacl -x g:组名 文件名# 会删除文件的所有的 ACL 权限，包括 masksetfacl -b 文件名 默认 ACL 权限和递归 ACL 权限1、递归 ACL 权限递归是父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。 12# 注意：-R 的位置不能放到 -m 那里，只能放到如下所示的位置setfacl -m u:用户名:权限 -R 文件名 2、默认 ACL 权限默认 ACL 权限的作用是如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。 123# 格式：setfacl -m d:u:用户名:权限 文件名# 加 -R 选项，表示其子目录递归拥有默认权限setfacl -m d:u:shiting:rx -R /project 注意：递归权限针对的是目录下的子文件，如果赋予文件 ACL 权限，文件是不可能有子文件的，它会报错。默认权限指的是这个目录当中新出现的文件或者目录遵守 ACL 权限，如果给文件赋予 ACL 权限，它虽然不报错，但是没有作用，因为不能在文件中创建子文件。所以这两个权限都只能赋予目录。 文件特殊权限SetUID1、SetUID 的功能(1) 只有可以执行的二进制程序才能设定 SetUID 权限(2) 命令执行者要对该程序拥有执行权限即 x(3) 命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主）(4) SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效 举例： passwd 命令拥有 SetUID 权限，所以普通用户可以修改自己的密码。cat 命令没有 SetUID 权限，所以普通用户不能查看 /etc/shadow 文件内容。 注意：上图中出现了「s」，SetUID 指的就是在该文件的所有者权限范围内拥有「s」权限；而 SetGID 指的就是在该文件的所属组权限范围内拥有「s」权限；而 Sticky BIT 指的就是在该文件的其他人权限范围内拥有「s」权限。它们都是将对应执行权限位的 x 替换为 s。 2、设定 SetUID 的方法123# 4 代表 SetUID方法一：chmod 4755 文件名方法二：chmod u+s 文件名 注意：出现了大写的 S，跟 chmod 4755 设定出来的小写的 s 效果不一样。大写的 S 其实是报错了，证明这个权限不能运行，因为用户必须对这个文件拥有执行权限，SetUID 才有作用，这个文件的权限原来是 644，在 644 的基础之上加了一个 s，任何人对这个文件都没有执行权限，所以系统用大写的 S 报警，提示用户这种 SetUID 值不能正确执行。 3、取消 SetUID 的方法12方法一：chmod 755 文件名方法二：chmod u-s 文件名 4、危险的 SetUID（1）关键目录应严格控制写权限。比如「/」「/usr」等。（2）用户的密码设置要严格遵守密码三原则。（3）对系统中默认应该具有 SetUID 权限的文件做个列表，定时检查有没有列表之外的文件被设置了 SetUID 权限。 SetGID1、SetGID 针对文件的作用(1) 只有可执行的二进制程序才能设置 SetGID 权限(2) 命令执行者要对该程序拥有执行权限即 x(3) 命令执行在执行程序的时候，组身份升级为该程序文件的属组(4) SetGID 权限只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效 举例：locate 文件搜索命令，它跟 find 命令相比，之所以执行速度更快，是因为 locate 命令搜索的是 /var/lib/mlocate/mlocate.db 这个数据库，该数据库中会记录当前系统中所有文件的文件名。会发现该数据的权限是 -rw-r—–，如果普通用户去搜索这个数据库文件按理应该是没有权限的，但是 locate 命令有 SetGID 权限。即普通用户虽然对数据库文件没有权限，但是普通用户是通过 locate 命令去搜索数据库文件的，而 locate 命令是拥有 SetGID 权限的，当任意一个普通用户执行 locate 命令的时候，其身份组就会切换为 locate 命令的组即 slocate，而数据库文件的所属组就是 slocate，并且所属组拥有读权限，所以普通用户利用 locate 命令的 SetGID 权限就可以读取数据库文件了。 2、SetGID 针对目录的作用(1) 普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录(2) 普通用户在此目录中的有效组会变成此目录的属组(3) 若普通用户对此目录拥有 w 权限时，新建的文件的默认属组是这个目录的属组 注意：只有 SetGID 可以既针对二进制文件，也可以针对目录。 举例：12345678# root 用户执行命令mkdir /tmp/dtestchmod 2777 /tmp/dtest# 切换为普通用户su - youcaicd /tmp/dtest/# 注意：在 /tmp/dtest 目录下新建文件的所属组是 root，即 dtest 目录的所属组，不再是当前用户的缺省组了touch /tmp/dtest/ftest 注意：对目录设置 SetGID 实际操作意义不大，了解即可。 3、设定 SetGID1232 代表 SetGID方法一：chmod 2755 文件名方法二：chmod g+s 文件名 4、取消 SetGID12方法一：chmod 755 文件名方法二：chmod g-s 文件名 系统利用了 SetUID 和 SetGID 这些权限来完成一些必须给普通用户分配权限的工作。 Sticky BIT1、Sticky BIT 粘着位作用(1) 粘着位目前只对目录有效。(2) 普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录拥有写入权限。(3) 如果没有粘着位，因为普通用户拥有 w 权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。 举例：注意：/tmp/ 目录的其他人权限位中的「t」表示粘着位权限。 2、设置粘着位12方法一：chmod 1755 目录名方法二：chmod o+t 目录名 3、取消粘着位12方法一：chmod 755 目录名方法二：chmod o-t 目录名 注意：Stichy BIT 针对的是删除的限制，对读和修改没有限制。注意：特殊权限位虽然可以给 7，但是一般不这样做，因为操作的对象不同，有的是目录，有的是文件，所以不可能同时生效，所以这样做是没有意义的。注意：要定时检查系统中赋予 SetUID 和 SetGID 的权限的文件，如果有，要确认是否是多出来的，否则会造成非常大的隐患。 小结：SetUID 只能针对二进制文件，用 4 表示，权限为字母为 s。SetGID 既可以针对二进制文件，也可以针对目录，用 2 表示，权限为字母为 s。Stichy BIT 只能针对目录，用 1 表示，权限为字母为 t。 文件系统属性 chattr 权限1、chattr 命令格式12345678910简介： change file attributes on a Linux file system（ch「change」 attr「attributes」)格式： # + 增加权限；- 删除权限；= 等于某权限 chattr [+-=] [选项] 文件或目录名选项： i 如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置 i 属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。 a 如果对文件设置 a 属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除。 注意：i 属性赋予文件，表示该文件是只读的。chattr 针对 root 用户也生效。要想恢复，则先去掉 i 属性。这也是 chattr 的好处，保护数据内容，而且对 root 用户也有效。 其实 a 是 append 追加的意思。如果对文件设置了 a 属性，则不能使用 vim 的方式对文件修改，只能使用 echo [内容] &gt;&gt; [文件]的追加方式进行数据的写入。 2、查看文件系统属性123456格式： lsattr 选项 文件名选项： -a 显示所有文件和目录 -d 若目标是目录，仅列出目录本身的属性，而不是子文件的 e 属性：代表这个文件是在 ext 文件系统中创建的，e 属性是 ext 文件系统默认的，而且也不能取消。 系统命令 sudo 权限1、sudo 权限 root 把本来只能超级用户执行的命令赋予普通用户执行。sudo 的操作对象是系统命令。 2、sudo 使用123# 通过编辑 /etc/sudoers 文件来给普通用户授权# visudo 命令实际修改的是 /etc/sudoers 文件visudo 等价于 vim /etc/sudoers 注意：上图中的授权格式中有三个 ALL，这三个 ALL 分别代表的是： 第一个 ALL：它定义的并不是允许哪一个 IP 地址或网络访问我这台本机，而是定义的是允许哪一个用户执行某一条命令在哪一台计算机上。即它定义的是执行命令的计算机的 IP 地址或网段。第二个 ALL：表示我可以使用什么身份。可以不写，默认为 ALL，表示把用户当成什么身份来对待。第三个 ALL：代表任意命令。 3、示例：授权 test 用户可以重启服务器123vim /etc/sudoers# 添加如下内容，注意命令要写绝对路径，可以通过 whereis 查找命令绝对路径test ALL = /sbin/shutdown -r now 4、示例：普通用户执行 sudo 赋予的命令12345# 查看可用的 sudo 命令sudo -l# 普通用户执行 sudo 赋予的命令sudo /sbin/shutdown -r now 注意：普通用户是可以使用 vim 的，但是普通用户自己用 vim 的时候是局限在自己的权限范围之内的。如果用 sudo 的方式把 root 用户的 vim 赋给普通用户，那么普通用户在执行 vim 命令的时候他的身份会自动切换成为 root，这是极其危险的。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(八)]]></title>
    <url>%2F2018%2F10%2F22%2FLinux-2018-10-22-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(八) —— 用户和用户组管理 用户配置文件1、用户信息文件 /etc/passwd 详解在 Linux 中主要是通过用户配置文件来查看和修改用户信息。注意：在操作 passwd 文件的时候备份。可以使用 man 5 passwd 查看配置文件的帮助文档。 第 1 个字段：用户名称。 第 2 个字段：密码标志。x 表示这个用户是有密码的。注意 x 是不能省略的，如果省略了，则用户登录的时候，系统是不会去 shadow 文件中去搜索用户的真正密码的，它会认为这个用户压根就没有密码，可以直接登录。没有密码的登录只允许本地登录，不允许远程登录，因为 ssh 协议本身就禁止的。 第 3 个字段：UID（用户 ID）。注意：系统中默认有很多伪用户，但是这些伪用户不能删，一旦删除系统就会崩溃，因为系统有很多服务会调用这些伪用户。这些伪用户是专门用来给系统当中，启动服务、启动命令的时候来调用的。总之这些用户都是系统用户，这些用户不能登录，其次不能删除。 0: 超级用户，注意系统是通过 UID 为 0 来识别是否为超级管理员的，不是通过用户名是否为 root 识别1-499: 系统用户（伪用户）500-65535: 普通用户 第 4 个字段：GID（用户初始组 ID）。 初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组。初始组的特点：每一个用户都必须有且仅有一个初始组。初始组不能选，但是可以改，一旦改变，以前的初始组就会被放弃，因为只能有一个初始组存在。附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。 第 5 个字段：用户说明。 第 6 个字段：家目录。 普通用户：/home/用户名/超级用户：/root/ 第 7 个字段：登录之后的 Shell。 Shell 就是 Linux 的命令解释器。在 /etc/passwd 当中，除了标准 Shell 是 /bin/bash 之外，还可以写如 /sbin/nologin。简单来说：就是你在 Linux 中输入一个命令，eg：ll，实际上中间要通过命令解释器将 ll 命令解释成内核可以识别的符号然后传输给内核，内核再作出应答显示在命令操作窗口，这样的一个过程。对命令的解释就是 Shell 来执行的。默认即标准 Shell 是 /bin/bash，Linux 中 Shell 可以有多个，默认为 /bin/bash，理论上可以更改。 2、影子文件 /etc/shadow 详解注意：/etc/shadow 文件的默认权限为 000，该文件很重要，保存了加密以后的用户密码。 第 1 个字段：用户名。第 2 个字段：加密密码。注意：如果密码位是「!!」或「*」代表没有密码，不能登录。第 3 个字段：密码最后一次修改日期。使用 1970.01.01 作为标准时间，每过一天时间戳加 1。第 4 个字段：两次密码的修改间隔时间（和第 3 字段相比）。第 5 个字段：密码有效期（和第 3 字段相比）。第 6 个字段：密码修改到期前的警告天数（和第 5 字段相比）。第 7 个字段：密码过期后的宽限天数（和第 5 字段相比）。0 代表密码过期后立即失效。-1 则表示密码永远不会失效。第 8 个字段：账号失效时间。要用时间戳表示。不管前面怎么设置，到时间了直接密码失效。第 9 个字段：保留。 时间戳换算方法：123456# 把时间戳换算为日期date -d &quot;1970-01-01 16666 days&quot;# 把日期换算为时间戳# $() 用来引用系统命令，date --date=&quot;2018/10/01&quot; +%s 将指定日期换算成秒（以 1970.01.01 作为标准时间）echo $(($(date --date=&quot;2018/10/01&quot; +%s)/86400+1)) 3、组信息文件 /etc/group 第 1 个字段：组名。第 2 个字段：组密码标志。第 3 个字段：GID。第 4 个字段：组中附加用户。 4、组密码文件 /etc/gshadow 第 1 个字段：组名。第 2 个字段：组密码。第 3 个字段：组管理员用户名。第 4 个字段：组中附加用户。 组密码的作用：只有管理员可以将用户加入到其他的用户组，但是 root 太忙了，这时候可以给组选一个管理员，给这个组设置一个密码，只要这个管理员知道密码，就可以把其他人拉到这个组里面来。或者把用户从这个组里面删掉。不推荐使用组密码，安全性差。 用户管理相关文件1、用户的家目录 普通用户：/home/用户名/，所有者和所属组都是此用户，权限 700。超级用户：/root，所有者和所属组都是 root 用户，权限是 550。 注意：用户的家目录是添加用户的时候自动生成的，可以在添加的时候不让它自动生成，手动创建，但是所有者、所属组以及权限都需要手动去调整。将普通用户变为超级管理员，修改 /etc/passwd 文件，将用户的 UID 改为 0，但是用户的家目录不会改变成 root，还是原来的家目录，只是它的权限是超级用户的权限了。 2、用户的邮箱用户邮箱目录：/var/spool/mail/用户名/。注意：/var 目录是 Linux 中可变数据的保存位置。 3、用户模板目录 /etc/skel/注意：添加一个用户会默认修改 7 个位置的文件，分别是：/etc/passwd/、/etc/shadow/、/etc/group/、/etc/gshadow/、家目录、邮箱目录、用户模板目录。模板文件 /etc/skel 里面有隐藏文件，新添加的用户，系统会默认将里面的文件拷贝到其所在的家目录下的。所以，添加一个用户实际会默认修改 6 个位置的文件，因为模板只是从其里面拷贝用的，不会修改。 用户管理命令1、用户添加命令 useradd1234567891011121314151617useradd 命令格式： useradd [选项] 用户名选项： -u UID 手工指定用户的 UID 号 -d 家目录 手工指定用户的家目录 -c 用户说明 手工指定用户的说明。如果输入的内容之间有空格，要加双引号 -g 组名 手工指定用户的初始组 -G 组名 指定用户的附加组。可以同时指定多个附加组，中间以逗号分隔 -s shell 手工指定用户的登录 Shell。默认是 /bin/shell举例： # 添加默认用户，注意有 6 个位置的文件会被修改外加 1 个位置的文件被复制 useradd test # 指定选项添加用户 useradd -u 666 -d /home/test -c &quot;test add user&quot; -g test -G root,bin -s /bin/bash test 用户默认值文件：/etc/default/useradd 用户默认值文件：/etc/login.defs 注意：密码最小长度为 5 位的那条记录已经不生效了，因为其定义的密码强度过于简单，现在采用的是 PAM 验证生效即默认最少 8 位。 2、修改用户密码 passwd123456789101112131415161718192021222324passwd 命令格式： passwd [选项] 用户名选项： -S 查询用户密码的密码状态。仅 root 用户可用。 -l 暂时锁定用户。仅 root 用户可用。 -u 解锁用户。仅 root 用户可用。 --stdin 可以通过管道符输出的数据作为用户的密码 (stdin 标准输入)。举例： # 查看密码状态 passwd -S test 输出结果为： test PS 2018-04-11 0 99999 7 -1 (密码已设置，使用 SHA512 算法。) 解析输出结果：用户名(test) 密码状态(PS 密码已设置、LK 密码已锁定) 密码设定时间(2018-04-11) 密码修改间隔时间(0) 密码有效期(99999) 警告时间(7) 密码不失效(-1) # 锁定用户 passwd -l test # 解锁用户 passwd -u test # 使用字符串作为用户的密码 # 注意：使用 --stdin 每个用户的密码都是使用明文的方式保存下来的，所以要提醒每个用户登录以后要修改密码 echo &quot;123&quot; | passwd --stdin test passwd 直接回车，表示给当前用户设置密码。 新建的用户如果没有设置密码是不能远程登录的，但是可以在本地无密码登录。普通用户修改密码只能使用 passwd，后面是不能加用户名的，只有超级用户可以。 3、修改用户信息 usermod12345678910111213141516171819202122usermod 即 user modify 修改用户的意思命令格式： usermod [选项] 用户名选项： -u UID 修改用户的 UID 号 -c 用户说明 修改用户的说明信息 -G 组名 修改用户的附加组 -L 临时锁定用户（Lock） -U 解锁用户锁定（Unlock）举例： # 修改用户说明 usermod -c &quot;test user&quot; test # 把 test 用户加入 root 组 usermod -G root test # 锁定解锁用户 usermod -L test usermod -U test 4、修改用户密码状态 chage注意：是 chage 不是 change，没有 n 。 12345678910111213141516命令格式： chage [选项] 用户名选项： -l 列出用户的详细密码状态 -d 日期 修改密码最后一次更改日期（shadow 3 字段） -m 天数 修改两次密码修改间隔（shadow 4 字段） -M 天数 修改密码有效期（shadow 5 字段） -W 天数 修改密码过期前警告天数（shadow 6 字段） -I 天数 修改密码过期后宽限天数（shadow 7 字段） -E 日期 修改账号失效时间（shadow 8 字段）举例： # 该命令把密码修改日期归 0 了（shadow 3 字段），这样用户一登录就要修改密码。 # 即用户从来没有修改过密码，即第一次密码时间为 1971-01-01，所以你一登录系统就会要求你更改密码。即把用户的密码修改时间归零。 chage -d 0 test 5、删除用户 userdel1234567891011121314命令格式： userdel [选项] 用户名选项： -r 删除用户的同时删除用户家目录举例： # 手动删除用户 vim /etc/passwd vim /etc/shadow vim /etc/group vim /etc/gshadow rm -rf /var/spool/mail/lamp rm -rf /home/用户名 查看用户 ID：1id 用户名 切换用户身份 su:1234567891011121314151617命令格式： su [选项] 用户名选项： - 选项只使用「-」代表连带用户的环境变量一起切换 -c 命令 仅执行一次命令，而不切换用户身份举例： # 切换成 root # 命令 env 用来查看用户环境变量（环境变量就是这个用户当前所操作的环境） # 注意：su 命令切换的时候中间的减号一定不能省略，而且减号前后都有空格 # 从普通用户切换超级用户或其他普通用户需要输入密码，从超级用户切换普通用户不需要输入密码 su - root # 不切换成 root，但是执行 useradd 命令添加 user1 用户 # 没有切换用户，用 -c 选项表示暂时性的调用 root 身份去执行一条 root 用户才能执行的命令 su - root -c &quot;useradd user1&quot; 用户组管理命令1、添加用户组12345格式： groupadd [选项] 组名选项： -g GID 指定组 ID 2、修改用户组12345678910格式： groupmod [选项] 组名选项： -g GID 修改组 ID -n 新组名 修改组名举例： # 把组名 group1 修改为 group2 groupmod -n group2 group1 3、删除用户组12格式： groupdel 组名 对于组的删除：如果这个组里面是某个用户的初始组，则这个组不能删。要想删除这个组首先要删除用户。如果某个组里面没有初始用户，附加用户有没有都可以删除，里面的用户会自动被清空。 4、把用户添加入组或从组中删除用户12345678910格式： gpasswd [选项] 组名选项： -a 用户名 把用户加入组 -d 用户名 把用户从组中删除示例： gpasswd -a 用户名 用户组 gpasswd -d 用户名 用户组 Linux 本地无密码登录方法：将 /etc/passwd/ 文件中对应用户的密码标志位置为空，即去掉 x。然后在本地直接输入用户名就可以登录了。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(七)]]></title>
    <url>%2F2018%2F10%2F18%2FLinux-2018-10-18-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(七) —— 软件包管理 RPM 包管理之 rpm 命令管理1、Linux 软件包分类 源码包 （脚本安装包） 二进制包（RPM 包、系统默认包） Linux 是 C 语言写的，这里指的源码包绝大多数都是 C 语言写的。源码包和二进制包最大的区别就是：源码包是直接开发完的源代码给你，而二进制包它是将经过编译以后的包给你，看不到源代码了。编译的时间会比较慢。在 Centos 中我们把二进制包称为 RPM（red hat package manage）包。 2、RPM 包命名规则 15 指的是在这个版本上发布了 15 次。el6.centos 指 rpm 包的这个版本可以在 RHEL6 和 Centos 这两个 Linux 版本上安装。noarch 表示任何硬件平台都可以安装。有的包没有写适合哪个 Linux 平台，则适合所有的 Linux 平台。 注意区分包名和包全名： 包全名：操作的包是没有安装的软件包时，使用包全名。而且要注意路径。上图的包全名为「httpd-2.2.15-15.el6.centos.1.i686.rpm」。一般是安装和升级的时候使用包全名，因为安装和升级的时候这些包都没有安装，操作的是未安装的包所以使用包全名。包名：操作已经安装的软件包时，使用包名。是搜索 /var/lib/rpm 中的数据库。上图中的包名为「httpd」。一般查询、卸载这些命令操作的对象都是包名。 3、RPM 包依赖性 解决环形依赖：用一条命令把软件包 a、b、c 同时安装，就会解决环形依赖。 软件包库依赖(即模块依赖)：库依赖有个特征，只要是用「.so.数字」结尾，这种包都是库依赖，这个库依赖的不是单独独立的包，它是某一个软件安装包里面的某一个软件。即只要你找到了这个软件所在的包，然后将其所在的包安装，那么这个软件就会随着包的安装而自动安装，就会解决依赖性问题。通过 www.rpmfind.net 查找某个软件属于哪个依赖包。 4、RPM 包的安装、升级、卸载12345678910111213141516171819202122rpm 命令简介： 命令所在路径：/bin/rpm；作用：RPM 包管理器格式： rpm [选项] [包名/包全名]选项： -i 安装，install -v 显示详细信息，verbose -h 显示安装进度，hash -U 升级，upgrade -e 卸载，erase --nodeps 不检测依赖性，「no/deps」# 安装 RPM 包，注意包全名rpm -ivh 包全名# 升级 RPM 包，注意包全名rpm -Uvh 包全名# 卸载 RPM 包，注意包名rpm -e 包名 注意：安装和卸载用 yum 更为简单，因为它会自动就解决依赖性。但是查询只能通过 rpm，因为 yum 没有 rpm 查询强大，使用 yum 查不了 rpm 那么多的信息，即 rpm 的查询是一个非常常用的功能，不管是通过 rpm 安装还是 yum 安装都可以通过 rpm 命令的查询方式来进行查询。 5、RPM 包的查询 (1)查询包是否安装，-q 查询（query）1234rpm -q 包名# 查询所有已经安装的 RPM 包rpm -qa 注意：这里查询是从 Linux 后台系统数据库中取数据，所以不需要路径，任何位置都可以直接执行相应的命令。 (2)查询软件包详细信息，-i 查询软件包信息（information），-p 查询未安装包信息（package）12345# 查询已安装包信息rpm -qi 包名# 查询未安装包信息rpm -qip 包全名 (3)查询包中文件安装位置，-l 列表（list），-p 查询未安装包信息（package）12345# 查询已安装包文件安装位置rpm -ql 包名# 查询未安装包文件安装位置rpm -qlp 包全名 注意：软件包中文件的安装位置，一个软件包中不止有一个文件，所以使用 list，文件的安装位置（默认安装位置）是固定的，是在生产这个包的时候就已经决定了这个文件装在哪里是合理的，rpm 包可以手动指定安装位置，但是手动指定安装位置会带来一系列的问题，比如：服务管理命令找不到 rpm 的一些功能服务，很多服务其搜索的位置都是默认的，从而会带来一些问题。所以最好采用默认安装位置。 (4)查询系统文件属于哪个 RPM 包，-f 指定要查询的系统文件名（file）1rpm -qf 系统文件名 注意：这个系统文件必须是通过包装出来的，才能通过文件反查包。 (5)查询软件包的依赖性，-R 查询软件包依赖性（requires），-p 查询未安装包信息（package）1rpm -qR 包名 6、RPM 包校验123456# 选项 -V 作用：校验指定 RPM 包中的文件（verify）rpm -V 已安装的包名举例： # 如果结果没有任何输出，则表示没有任何改变；只有改变的情况才会有输出 rpm -V httpd 什么是校验？RPM 包安装之后，先把它的特征记录下来，然后当我需要的时候把现在的文件和原先的文件进行比较，查看文件之间的变化，从而判断现在的文件是否做了修改。我们使用校验是为了判断我们的系统文件是否被人进行了更改。 如上图所示，如果有字母则表示其对应的项做了修改，如果用点表示，则表示其对应项没有修改，c 是标称文件的类型，c 表示 config 即配置文件的意思。 7、从 RPM 包中提取文件，即从 RPM 包中提取指定的某个或某些文件，主要是用来做修复的，如日常工作中不小心把某个文件给误删除了，这时候可能并不需要重新安装整个包，只需要把对应的文件提取出去并放到相应位置即可修复。12345rpm2cpio 包全名 | cpio -idv .文件在包中的绝对路径# rpm2cpio 命令的作用：将 rpm 包转换为 cpio 格式的文件# cpio 是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件 rpm2cpio，由于 2 的英文发音 two 和 to 很像，所在 Linux 命令中经常用 2 表示从什么到什么的意思，此处表示从 rmp 格式转换为 cpio 格式。所有的 rmp 包都是 rpm 包格式的，只有把它转换成 cpio 格式的，才可以通过 cpio 命令把这个包中指定的文件提取出来。「\」在 Linux 表示一条命令没有输入完换行下面接着来。 1234567891011121314151617181920简介： cpio 命令格式： cpio [选项] &lt; [文件|设备]选项： -i copy-in 模式，还原 -d 还原时自动新建目录 -v 显示还原过程举例： # 查询 ls 命令属于哪个软件包 rpm -qf /bin/ls # 造成 ls 命令误删假象 mv /bin/ls /tmp # 提取 rpm 包中 ls 命令到当前目录的 /bin/ls 下 rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls # 把 ls 命令复制到 /bin 目录，修复丢失文件 cp /root/bin/ls /bin/ RPM 包管理之 yum 在线管理注意：yum 是一个命令，管理的是 RPM 包，在红帽系列的 Linux 中认为 yum 是一个售后服务，所以有的是收费的。 1、IP 地址配置12345# 启动网卡vim /etc/sysconfig/network-scripts/ifcfg-eth0 将 ONBOOT 的值改为 yes# 重启网络服务service network restart 注意：有 IP 和子网掩码就可以在局域网内使用；如果要想访问互联网，Ip、子网掩码、DNS、网关缺一不可。 2、网络 yum 源在 /etc/yum.repos.d/ 这个目录中，只要是以 .repo 结尾的，都是合法的 yum 源。默认是 Base 生效即网络 yum 源生效。 3、常用 yum 命令(1) 查询12345678# 查询对应 yum 源中所有可用软件包列表yum list# 统计对应 yum 源中有多少个软件包yum list | wc -l# 搜索服务器上所有和关键字相关的包yum search 关键字 注意：前面讲解的包名和包全名，只对 rpm 手工管理命令生效，即其使用范围仅限 rpm 手工管理范围。在 yum 中没有包名和包全名之分，只有包名。 (2) 安装12# install 安装，-y 自动回答 yesyum -y install 包名 gcc 是 c 语言的编译器，在源码包安装的时候，必须有 gcc 存在，源码包才可以正常安装。 (3) 升级12# update 升级，-y 自动回答 yesyum -y update 包名 注意：这个升级命令如果没有指定包名，只写了「yum -y update」，它的意思是升级所有的软件包，包括 Linux 内核都会升级，Linux 内核升级完成之后，是需要在本地做一定的配置，你的内核才可以正常使用，才可以启动，如果你是在远程执行的这条命令，你就会发现你的服务器怎么也开不了机了，永远也无法连接，这个时候，这条命令会导致服务器直接崩溃，所以升级命令慎重使用！！！ (4) 卸载12# remove 卸载，-y 自动回答 yesyum -y remove 包名 注意：在使用 yum 卸载的时候，它会自动把依赖这个包的包全部卸载掉，有可能会造成系统崩溃。Linux 安装原则：安装的时候最小化安装，不安装多余软件。使用什么软件就安装什么软件，手工装，尽量不卸载，尤其是 yum 卸载，尽量不要多用。这个命令不建议使用！！！ 4、yum 软件组管理命令12345678# 列出所有可用的软件组列表yum grouplist# 安装指定软件组，组名可以由 grouplist 查询出来yum groupinstall 软件组名# 卸载指定软件组yum groupremove 软件组名 注意：如果软件包组名之间有空格，要用双引号括起来，使用的时候要使用英文组名，中文组名是不会被识别的。 5、光盘 yum 源搭建12345678910111、挂载光盘mount /dev/cdrom /mnt/cdrom2、让网络 yum 源失效，即停用所有的网络 yum 源。取巧办法是将 /etc/yum.repos.d/ 文件夹下所有以 .repo 结尾的网络 yum 源改名cd /etc/yum.repos.d/mv CentOS-Base.repo CentOS-Base.repo.bakmv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bakmv CentOs-Vault.repo CentOs-Vault.repo.bak3、修改光盘 yum 源，配置光盘地址，enabled 设置为 1 表示开启光盘 yum 源vim CentOS-Media.repo 注意：系统在检测是否为有效 yum 源的时候是通过 .repo 这个后缀的，我们为了不打开一个个去修改，即将配置文件中的 yum 源容器的 enabled 全部设置为 0，所以此处选择了修改文件名的方式，这个简单粗暴省力。 光盘 yum 优点：本地不需要网络，下载更快；缺点：版本不能升级，即版本是固定的，需要连接光盘；注意：file 后面有三个 ///，前两个是固定格式「file://」最后一个代表根目录。对于多余的光盘地址，建议注释掉，虽然不影响使用，但是每次系统都会提示你多余的光盘地址找不的的信息。注意：指定 baseurl 为自己的光盘挂载地址。 注意：绝大多 Linux 的配置文件对注释都是有严格要求的，不光 # 前面不能加缩进，有一些配置文件甚至在 # 后面都不能加空格。如下所示：这种缩进的就会报错！！！ 源码包管理1、rpm 包和源码包的区别 安装之前的区别：概念上的区别安装之后的区别：安装位置不同 2、RPM 包默认安装位置 3、源码包安装位置源码包的安装位置是要手工指定的，一般是「/usr/local/软件名」。/usr 目录是 Unix 系统资源目录，有一个 local 目录，本地的意思，是系统专门为我们准备安装外来应用的地方。我们在目录下创建一个对应软件名进行安装即可。 4、安装位置不同带来的影响(1)RPM 包安装的服务可以使用系统服务管理命令（service）来管理，例如 RPM 包安装的 apache 的启动方法是：/etc/rc.d/init.d/httpd start 或 service httpd start。Linux 要想启动一个可执行文件（服务），都应该是利用绝对路径启动的。service 是 red hat 特有的，service 命令会自动的去 /etc/rc.d/init.d/ 下去寻找，找到了就执行，找不到就报错。类似 service 这种系统服务都会去默认的安装目录下去寻找，主要是 rmp 默认安装的位置，所以可以使用，但是源码包不行，只能是绝对路径启动。 (2)而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：/usr/local/apache2/bin/apachectl start。 小结：rpm 包和源码包由于安装的位置不同，所以带来了服务的管理方法不同。 5、源码包安装方法（1）安装准备 安装 C 语言编译器 （2）安装注意事项 源代码保存位置：/usr/local/src软件安装位置：/usr/local如何确定安装过程是否报错？(1) echo $? 查看上条命令执行结果 (2) 安装过程停止，并且出现 error、warning 或 no 的提示 （3）源码包安装过程 下载源码包解压缩下载的源码包进入解压缩目录 （4）进入解压缩以后的安装目录，注意以下两个文件 INSTALL 安装说明，注意名字大写。README 使用说明，注意名字大写。 在 Linux 当中，任何一个源码包都有 INSTALL、README 类似的文件，碰到陌生的源代码的时候，需要先查看说明，再安装或使用源码包。 （5）软件配置与检查 可以使用「./configure –help」查看该源码包可用的配置项的帮助信息，会发现源码包安装会有很多的安装配置选项。此处我们只定义安装的目录为 ./configure --prefix=/usr/local/apache2，源码包的安装路径选项在安装的时候是一定要定义的，其他选项可以不定义。configure 配置的意思，即在安装源码包之前，把源代码中需要的配置都先配置好，为随后的检查、编译、安装做好准备。注意：Makefile 文件是要等到 ./configure 这条命令执行之后才会生成，里面包含软件的各种配置，是用来安装软件的。 （6）编译、安装 如果前面都通过的话，则执行命令 make 表示编译，如果没有报错的话，则执行 make install 表示安装。到此源码安装就完成了。至于软件安装完成以后如何启动的问题，可以参看源码包中的 INSTALL 等文档的说明。 注意：在执行 ./configure 和 make 命令的时候不会向 /usr/local 里面写入任何数据。如果在执行 make 的时候报错，则可以使用 make clean 清空编译的数据，这样可以达到完全清空。make install 才会向真正的目录写入数据。 6、源码包的卸载不需要卸载命令，直接删除安装目录即可。不会遗留任何垃圾文件。 7、在 Linux 中，如果已经安装了 rpm 包的 httpd，可以再安装源码包的 httpd，因为安装位置不同，所以可以安装，但是没必要同时安装两个相同的软件。 推荐阅读Bash 快捷建Linux 上安装源码包centos 软件包管理之 rpm 的使用Linux 下 /usr 和 /var 的含义和内容]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(六)]]></title>
    <url>%2F2018%2F09%2F25%2FLinux-2018-09-25-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(六) —— Vim 编辑器 Vim 简介 Vim 在早期的 Linux 版本中又叫 Vi（visual interface），Vim 是 Vi 的升级版。Vim 是一个功能强大的全屏幕文本编辑器，是 Linux/Unix 上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。Vim 没有菜单，只有命令。 Vim 有三种工作模式。可以使用 vim 加上任何一个已经存在或者你想创建的文件名就可以进入 Vim 默认的命令模式。vi 和 vim 都是命令，两个的效果一模一样，一个是早期的，一个是 Vi 的增强版（全名 Vi improved 简称 Vim） 。Vim 命令默认进入的是命令模式，在该模式下，你敲的任何一个字符系统都会当成命令来处理。要想进入文本的插入模式，你需要输入插入命令，比较常用的有 i、a、o 就会进入到插入模式，要想退出插入模式，则可以使用 Esc 键，表示退出插入模式，但是此时进入到的是命令模式，此时你输入的任何内容都会被当成命令。在命令模式里面按「：」冒号就会进入到编辑模式，此时输入的就是编辑模式的命令了，即你输入的内容都会被当成是编辑模式的命令。比如设置行号命令：set number（简写：set nu）。编辑模式的命令执行完成以后它会自动的回到命令模式，所以冒号后面输入的内容才是编辑模式的命令。保存退出命令模式：「:wq」。 命令模式和编辑模式常用命令 注意：在使用小 a 的时候光标会自动往后跳一格，例如：we 光标现在在 w 上，按 a 以后光标自动跳到 e 上，然后在 e 的前面插入，实际上就是在 w 的后面插入。 注意：上图中前面有冒号的表示编辑模式命令，没有冒号的表示命令模式命令。 Linux 中的查找是严格区分大小写的，但是可以使用「:set ic」(注意冒号)设置不区分大小写；可以使用「:set noic」(注意冒号)设置区分大小写。「:%s 表示全局替换」「g 表示替换的时候不询问」「c 表示替换的时候要询问」 其他 Vim 常用操作12345678910111213141516J // 合并光标所在行及下一行为一行(在命令模式下)U // 撤销对当前行的所有操作/string // 向光标下搜索 string 字符串?string // 向光标上搜索 string 字符串N // 向上搜索前一个搜索动作yw // 复制从光标开始到词尾的字符nyw // 复制从光标开始的 n 个单词y^ // 复制从光标到行首的内容y$ // 复制从光标到行尾的内容f // 在当前行查找字符，fx 找到光标后第一个为 x 的字符，3fd 找到第三个为 d 的字符F // 同 f 反向查找:!命令 // 执行外部命令# 命令模式下移动光标h 向左、j 向下 、k 向上、l 向右空格键向右、Backspace 向左、Enter 移动到下一行首、- 移动到上一行首 总结：以下为 vim 必须掌握的常用命令：dd 剪切当前行，ndd 剪切当前行以下 n 行；x 删除光标所在处字符；yy 复制当前行，nyy 复制当前行以下 n 行；小写 p 粘贴在当前光标所在行的行下，大写 P 粘贴到行上；R 从光标所在处开始替换字符，按 Esc 结束；u 取消上一步操作！Ctrl+r 反向撤销；ZZ 保存退出的快捷键；当如果不知道自己处在什么模式时可以按 2 次 Esc 键即可回到命令模式。 Vim 使用技巧 「:r 文件名」可以导入一个文件的内容到当前 vim 编辑的文件之中。eg：「:r /etc/issue」导入的位置为刚才你光标所在的位置。 「:!命令」可以在不退出 vim 的情况下，执行系统响应的操作命令。eg：「:!which ls」 「:r!命令」将一个命令的执行结果导入到当前的 vim 文件里面。eg：「:r!date」 自定义快捷键「:map 快捷键 触发命令」。eg：「:map ^p I#」^p 表示 ctrl + p 的快捷键，该快捷键代表的命令是：跳到行首并进入插入模式，插入 # 号，然后退出。eg：「:map ^b 0x」表示用快捷键 ctrl + b 表示删除行首字母。^ 表示 ctrl 的意思，如：^c 就表示 ctrl + c。 注意：设置快捷键的方式是，使用 ctrl + v + 所需字母；或者先按 ctrl + v，再按 ctrl + 所需字母，效果是一样的。这种是构造 ctrl + 字母的快捷键的方法。 连续行注释：「n1,n2s/^/#/g」表示从 n1 行开始到 n2 行，每行的行首都增加 # 号，并且替换的时候不询问。 去掉连续行注释：「n1,n2s/^#//g」表示从 n1 行开始到 n2 行，每行的行首的 # 号都替换为空，并且替换的时候不询问。 如果注释符是「//」则需要转义：「:n1,n2s/^/\/\//g」表示从 n1 行开始到 n2 行，每行的行首都增加 // 号，并且替换的时候不询问。注意：「^」表示行首的意思。注意：在 Linux 中「\/」中「\」表示转义符的意思「/」它才是真正的符号。 替换命令：「:ab 旧内容 新内容」即「:ab a b」这个命令可以简单的理解为：当你输入 a，它会自动的帮你转换成 b。eg: 「:ab sb hello」 当前输入 sb 的时候，会自动的替换成 hello。 注意：以上定义的快捷键重启以后都不存在，要想永久生效，你需要将其定义在每个用户的宿主（家）目录中的配置文件里面。以 root 为例：vi /root/.vimrc (注意这个配置文件叫 .vimrc)这里面只能放一些编辑模式的命令，比如：设置行号、设置快捷键、ab 命令（前面可以没有冒号「:」）。 /root/.vimrc 文件中自定义永久有效的快捷键12345678# vim 自动设置行号set nu# ctrl + p 表示 I#&lt;Esc&gt;map ^p I#&lt;Esc&gt;# 设置 ab 命令ab sb hello 推荐阅读Vim速查表vim 使用技巧Vim 的使用方法增强 Vim 编辑器Vim 命令、操作、快捷键全集]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(三)]]></title>
    <url>%2F2018%2F09%2F21%2FEnglish-2018-09-21-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[求实英语(三) —— 过去时 1、你去年经常拜访他们吗？Did you ofter visit them last year? 2、三年前你对这种工作有多少经验？我的：How much experience did you have for this job three years ago?答案：How much experience in this kind of work did you have three years age? 3、我没及时告诉她，因为我病了。我的：I don’t tell her in time, because i was ill.答案：I din’t tell her in time, because i was ill. 4、我上周就认知他了，可他却一点儿也不了解我。我的：I knew him last week, but he don’t know me little.答案：I knwe him last wekk, but he didn’t know me at all. 5、昨天你和王先生在哪儿？where were you with Mr. Wang yesterday? 6、你见过那个新来的老板了吗？我的：Do you have seen the new boss?答案：Have you seen that new boss? 7、去年她像妈妈，可今年谁也不像。(此处 like 当介词)我的：She was like her mother last year, but she isn’t like anyone this year.答案：She was like her mother last year, but she is like no noe this year. 8、 谁问有关我学习的事儿来着？我的：Who was asked me about my study？答案：Who has asked something about my study? 9、爸爸昨晚没有责怪我。Our father did’t scold me last night. 10、昨天你在哪儿听到的那个消息？我是从报纸上看到的。where did you hear that news yesterday？I read it from the paper. 11、我的电脑又出毛病了。我的：My computer has broken again.答案：Something was wrong again with my computer. 12、昨天我很紧张，你呢？I was very nervous yesterday, and how were you? 13、你们的值日生昨天擦黑板了吗？Did your students on duty clean the blackboard yesterday? 14、今天上午李先生出什么事了？我的：What did happend with Mr.Li this forenoon？答案：What happended to Mr. Li this morning? 15、由于贫穷他去年就辍学了，我们去看看他吧。我的：Because of poverty he droped out school last year, we are looking at him tomorrow.答案：He quit school last year because of being poor, Let’s go to see him tomorrow.]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐阅读]]></title>
    <url>%2F2018%2F09%2F20%2FPersonal-2018-09-20-%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[记录在工作学习个人认为优秀的博客 1、阮一峰的网络日志 2、廖雪峰的官方网站 3、Linux 命令大全 4、左耳朵耗子 5、GitBook]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(六)]]></title>
    <url>%2F2018%2F09%2F19%2FJava-Java-Basic-2018-09-19-Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Java 入门总结(六) —— 剖析日期和时间 1、关于时区英国格林尼治是 0 时区，北京是东八区，也就是说格林尼治凌晨 1 点，北京是早上 9 点。0 时区的时间也称为 GMT+0 时间，GMT 是格林尼治标准时间，北京的时间就是 GMT+8:00。 2、时刻和 Epoch Time(纪元时)所有计算机系统内部都用一个整数表示时刻，这个整数是距离格林尼治标准时间 1970年1月1日0时0分0秒 的毫秒数。格林尼治标准时间 1970年1月1日0时0分0秒 也被称为 Epoch Time (纪元时)。这个整数表示的是一个时刻，与时区无关，世界上各个地方都是同一个时刻。而对于 1970 年以前的时间则使用负数表示。 3、年历公历和农历都是年历。年历就是对一年有多少月，每月有多少天，甚至一天有多少小时的规则定义。 时刻是一个绝对时间，对时刻的解读，如年月日周时分秒等，则是相对的，与年历和时区相关。 Date：表示时刻，即绝对时间，与年月日无关。 Calendar：表示年历，Calendar 是一个抽象类，其中表示公历的子类是 GregorianCalendar。 DateFormat：表示格式化，能够将日期和时间与字符串进行相互转换，DateFormat 也是一个抽象类，其中最常用的子类是 SimpleDateFormat。 TimeZone: 表示时区。Locale: 表示国家和语言。 4、Date 表示时刻，内部主要是一个 long 类型的值 private transient long fastTime; 几乎所有的未过时的方法都是对该值进行操作的。 5、Calendar 类是日期和时间操作中的主要类，它表示与 TimeZone 和 Locale 相关的日历信息，可以进行各种相关的运算。 Calendar.MONTH：表示月，一月份是 0。Calendar.DAY_OF_MONTH：表示日，每月的第一天是 1。Calendar.DAY_OF_WEEK：表示星期几，周日是 1，周一是 2，周六是 7。 内部，Calendar 会将表示时刻的毫秒数，按照 TimeZone 和 Locale 对应的年历，计算各个日历字段的值，存放在 fields 数组中，Calendar.get 方法获取的就是 fields 数组中对应字段的值。 内部，根据字段设置或修改时间时，Calendar 会更新 fields 数组对应字段的值，但一般不会立即更新其他相关字段或内部的毫秒数的值，不过在获取时间或字段值的时候，Calendar 会重新计算并更新相关字段。 6、DateFormat 类主要在 Date 和字符串表示之间进行相互转换。 7、DateFormat/SimpleDateFormat 不是线程安全的，因为 DateFormat 内部使用了一个 Calendar 实例对象，多线程同时调用的时候，这个 Calendar 实例的状态可能就会紊乱。 8、总结：Date 表示时刻，与年月日无关，Calendar 表示日历，与时区和 Locale 相关，可进行各种运算，是日期时间操作的主要类，DateFormat/SimpleDateFormat 在 Date 和字符串之间进行相互转换。 9、Joda 的主要工作都是在毫秒和年月日等年历信息之间进行相互转换。 10、Joda-Time 中的主要类都被设计为了不可变类，不可变类有一个很大的优点，那就是简单、线程安全，所有看似的修改操作都是通过创建新对象来实现的。 参考博客Java编程的逻辑 —— 剖析日期和时间Java编程的逻辑 —— Joda-Time]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(七)]]></title>
    <url>%2F2018%2F09%2F19%2FJava-Java-Basic-2018-09-20-Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[Java 入门总结(七) —— 随机 1、Random 类的构造方法可以接受一个 long 类型的种子参数。种子决定了随机产生的序列，种子相同，产生的随机数序列就是相同的。 2、为什么要指定种子？指定种子是为了实现可重复的随机。 3、Random 产生的随机数不是真正的随机数，相反，它产生的随机数一般称之为伪随机数，真正的随机数比较难以产生，计算机程序中的随机数一般都是伪随机数。 4、伪随机数都是基于一个种子数的，然后每需要一个随机数，都是对当前种子进行一些数学运算，得到一个数，基于这个数得到需要的随机数和新的种子。 5、Random 类是线程安全的，也就是说，多个线程可以同时使用一个 Random 实例对象，不过，如果并发性很高，会产生竞争，这时，可以考虑使用多线程库中的 ThreadLocalRandom 类。 参考博客Java编程的逻辑 —— 随机]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(五)]]></title>
    <url>%2F2018%2F09%2F19%2FLinux-2018-09-19-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(五) —— Linux 常用命令 帮助命令1、帮助命令 man123456789101112简介： 英文原意 manual；命令所在路径：/usr/bin/man；作用：获得帮助信息格式： man [命令或配置文件]举例： # 查看命令的帮助信息 man ls # 查看配置文件的帮助信息 man services manual 英文意思手册，指南；使用 man 命令相当于调用了一个 less 的浏览方式。 如何看命令的帮助信息？1、知道命令是干什么用的，通过查看帮助信息的第一行即 NAME 行。2、知道命令的选项是干什么用的，通过「/+关键字」的方式可以快速定位到你要找的内容，通过 n 键向下继续查找。 如何查看配置文件的帮助信息？1、这个配置文件是干什么用的，通过查看帮助信息的第一行即 NAME 行；2、这个配置文件的格式是什么样的，在 Linux 中任何配置文件都是有规律的，即格式，可以在配置文件的帮助文档中查看到。 注意在使用 man 来查看配置文件帮助的时候，不可以写成「man + 配置文件绝对路径」！！！此时你得到的并不是帮助信息，而是配置文件的内容。查看配置文件帮助的时候只要使用「man + 配置文件名称」即可。通过查看第一行即 NAME 行，它会告诉你这个配置文件是一个什么样的文件。 man 命令的帮助类型：「1」表示命令的帮助，「5」表示配置文件的帮助。eg：如 passwd 既对应一个命令又对应一个配置文件，使用 man 会优先显示命令的帮助。要想查看配置文件的帮助，则 man 5 passwd 加一个数字 5 声明你要查看配置文件的帮助。 执行指令 man services 等查看配置文件帮助文档的时候出现「没有 services 的手册页条目」。解决办法：安装 man 帮助文档包。指令为：yum install man-pages。 「whatis + 命令名称」它可以直接读取到这个命令 NAME 部分的信息。 「apropos + 配置文件的名称」只想查看一个配置文件的简短信息。 命令 --help 只想查看命令的选项，不想看到其他的描述语言。 命令 info 即 infomation，也可以获得帮助信息，其作用跟 man 大同小异，只是在帮助信息的显示有所差别，包括方式上支持一些跳转。 2、帮助命令 help123456简介： 命令所在路径：Shell 内置命令；作用：获得 Shell 内置命令的帮助信息举例： # 查看 umask 命令的帮助信息 help umask Shell 其实就是一个命令解释器，找不到命令所在路径的命令都是 Shell 内置命令，eg：cd、umask。这些命令不能使用 man 来查看帮助，它会列出 Shell 所有的帮助信息。可以使用 help 来获取 Shell 内置命令的帮助信息。 3、Linux 中的命令大致可分为两类，内部命令和外部命令。内部命令：也称 Shell 内嵌命令；外部命令：存放在一个文件中，使用时需要去文件中查找，这些文件被定义在 $PATH 中。type 命令可以查看命令类型，以区别是内部命令还是外部命令，格式 type 命令名称。 用户管理命令1、用户管理命令 useradd12345简介： 命令所在路径：/usr/sbin/useradd；作用：添加新用户格式： useradd 用户名 useradd 命令只有 root 用户可以使用。 useradd 命令在添加的时候只是添加了用户的基本信息，例如家目录、相关的命令解释器的分配等，并没有给它设置一个验证密码。 2、用户管理命令 passwd12345简介： 命令所在路径：/usr/bin/passwd；作用：设置用户密码格式： passwd 用户名 注意：更改密码的时候只有管理员可以随意更改密码，普通用户必须要满足密码原则才可以更改密码成功。每个普通用户只能用 passwd 更改自己的密码，而管理员 root 可以用 passwd 更改任何人的密码。 3、用户管理命令 who12简介： 命令所在路径：/usr/bin/who；作用：查看登录用户信息 who 命令显示内容解释：登录用户名（一个用户可以多次登录）、登录的终端（tty 表示本地终端，即在 Linux 机器本身上登录，tty 又叫本地登录）（pts 表示远程终端，即远程登录）、登录时间、括号里的内容是登录的主机的 IP 地址，如果没有写就表示本机登录。 4、用户管理命令 w12简介： 命令所在路径：/usr/bin/w；作用：查看登录用户详细信息 w 命令的第一行信息解释：当前系统时间、系统连续运行多久、当前一共有几个用户登录、负载均衡指数（这个指数有 3 个数值，分别记录了过去的 1 分钟、5 分钟和 15 分钟，系统的一个负载情况，一般来讲系统的负载值主要指的就是 cup 和内存的负载情况）。IDLE 表示该用户登录过来已经空闲多久了；PCPU 指的是该用户当前登录过来执行的操作占用的 cpu 的时间（下面的数字指的是当前执行的命令占用的 cpu 时间，因为进程在执行的时候是排队依次执行，每个进程在一个 cpu 循环周期里面会分配一定的 cpu 时间，如果一个进程在 cpu 循环周期里多次，它就会占用多个 cpu 时间）；WHAT 指的是他当前执行了什么操作；JCPU 累计占用的 cpu 时间。 压缩解压命令1、压缩命令 gzip12345简介： 命令所在路径：/bin/gzip；作用：压缩文件；压缩后文件格式：.gz格式： gzip [文件] 解压命令 gunzip12345678简介： 命令所在路径：/bin/gunzip；作用：解压缩 .gz 的压缩文件格式： gunzip [选项] 压缩文件选项： -S 指定后缀以取代 .gz，suffix 注意：gzip 只能压缩文件，不能压缩目录。而且使用 gzip 压缩是不保留源文件的，使用 gunzip 解压缩也是不保留源文件的。解压缩命令：gunzip（即在 gzip 压缩命令中间加入 un）或者使用 gzip -d 命令，两种命令的效果是一样的。gzip 的压缩比约为 5:1。 2、压缩解压命令 tar1234567891011简介： 命令所在路径：/bin/tar；作用：打包目录；压缩后文件格式：.tar.gz格式：tar [选项] [压缩后文件名] [文件或目录] 选项： -c 打包，create -x 解包，extract -v 显示详细信息，verbose -f 指定文件名，file -z 打包的同时用 gzip 或 gunzip 压缩或解压 tar 本身的意思是打包，它可以把一个目录打包成一个文件，同时也可以在打包的同时做一个压缩。tar -cvzf 的压缩比约为 5:1。使用此组命令会保留源文件。 注意：在使用 tar 的压缩解压命令的时候，-f 后面一定要紧跟它要指定的文件，否则可能会报错。如果 -f 后面没有紧跟它要指定的文件，则 tar 命令的选项中不能加「-」，否则会报错 Cannot stat: No such file or directory。 3、压缩命令 zip12345678简介： 命令所在路径：/usr/bin/zip；作用：压缩文件或目录；压缩后文件格式：.zip格式： zip [选项] [压缩后文件名] [文件或目录]选项： -r 压缩目录 解压命令 unzip12345简介： 命令所在路径：/usr/bin/unzip；作用：解压 .zip 的压缩文件格式： unzip [压缩文件] 一般来讲，Linux 里面的压缩包的格式 windows 的压缩软件几乎都支持。但反过来就要看具体情况了。默认在使用的过程中，只有一种压缩格式 windows 和 Linux 双方都不需要再额外装什么软件都可以进行解压缩处理的就是 .zip 格式。使用 zip 命令：会保留源文件，可以压缩目录。 压缩比没有 gzip 那么可观，所以使用的会比较少。使用 unzip 命令进行解压缩的时候，不分压缩文件是目录还是文件，都可以进行解压缩。 4、压缩命令 bzip2123456789101112131415简介： 命令所在路径：/usr/bin/bzip2；作用：压缩文件；压缩后文件格式：.bz2格式： bzip2 [选项] [文件]选项： -k 产生压缩文件后保留原文件，keep举例： # 压缩 bzip2 -k test # 跟 tar 命令结合使用，采用 bzip2 的方式压缩 tar -cjf test.tar.bz2 test 这是一个 gzip 的升级版本。值得注意的是 bzip2 的压缩比是非常惊人的，一般往往用来压缩大的文件。还可以跟 tar 一起来使用：即用 tar 命令里的 z（z 表示 tar 命令中的压缩方式）替换为 j（j 表示 bzip2 的压缩方式）。注意 bzip2 只能处理文件，不能处理目录。 解压命令 bunzip2123456789101112131415简介： 命令所在路径：/usr/bin/bunzip2；作用：解压缩格式： bunzip2 [选项] [压缩文件]选项： -k 解压缩后保留原文件，keep举例： # 解压 bunzip2 -k test.bz2 # 跟 tar 命令结合使用，解压 bzip2 方式的压缩 tar -xjf test.tar.bz2 如果该目录下有跟解压后的文件同名的文件则该命令会拒绝解压缩，不会像其他命令询问你是否覆盖等。要想解压则必须先删除或更改同名文件。在解压缩 .tar.bz2 文件的时候同样适用 tar 命令，注意把 z 替换为 j 即可。 小结： .gz 类型的压缩文件 gzip 进行压缩 gunzip（或 gzip -d）进行解压缩。不能压缩目录，不能保留源文件。 .tar 类型的文件 可以生成打包文件 tar -cf 打包，-xf 解包，可以利用此命令进行压缩目录。 .tar.gz 类型的压缩文件 tar -zcf 打包并压缩，tar -zxf 解包并解压缩。 .zip 类型的压缩文件 zip 压缩文件 zip -r 压缩目录，unzip 解压缩文件或者目录（压缩比不是特别高，windows 和 Linux 通过格式）。 .bz2 类型的压缩文件 bzip2 进行压缩，bunzip2（或者是 bzip2 -d）进行解压缩。 .tar.bz2 类型的压缩文件 tar -cjf 生成压缩包，tar -xjf 进行解压缩。 网络命令1、网络命令 write12345简介： 命令所在路径：/usr/bin/write；作用：给用户发信息，以 Ctrl + D 保存 结束格式： write 用户名 注意：在 write 命令的输入界面，按退格键是不行的，需要按 Ctrl + 退格键或者按 Delete 键，表示退格的意思。内容输入结束后按回车，然后使用 Ctrl + D 保存并结束。特别注意的是只能给在线用户发送，如果用户不在线消息是发不出去的。 2、网络命令 wall12345简介： 英文原意 write all；命令所在路劲：/usr/bin/wall；作用：发广播信息格式： wall 消息 给当前所有在线用户发送信息。在使用该命令发送广播信息的时候，自己也会受到一条发的广播信息。本地终端也会收到广播信息。注意只有在线用户可以收到消息。 3、网络命令 ping12345678简介： 命令所在路径：/bin/ping；作用：测试网络连通性格式： ping [选项] IP地址选项： -c 指定发送次数 现在使用最多的远程探测命令，工作机制：给远程主机发送一个信息包，判断你是否存在即看看你是否回应我，只要你回应，就证明咱们两个之间网络是通的。注意在使用 ping 命令的时候，重点看 package loss 即丢包率这个属性。如果丢包率非常高，即使你 ping 通了，证明你的网状态其实也非常差 。 4、网络命令 ifconfig12345简介： 英文原意 interface configure；命令所在路径：/sbin/ifconfig；作用：查看和设置网卡信息格式： ifconfig 网卡名称 IP地址 Linux 系统中默认有两块网卡，eth0 代表的是本地的真实网卡，lo 回环网卡，用来本机通信和测试的，地址也是固定的，都是 127.0.0.1，不插网线甚至网卡驱动不安装，都可以 ping 通。 eth0:网卡接口名称；flags：标志位，UP 表示网卡启用激活状态； mtu：maximum transmission unit，网卡最大传输单元为 1500 字节； inet：IPv4 地址； netmask：子网掩码；broadcast：广播地址； inet6：IPv6 地址； ether(HWaddr)：以太网地址；txqueuelen 1000 (Ethernet)：以太网传输队列长度；网卡的硬件地址即我们所说的 MAC 地址，它是用十六进制表示的，48 位的地址，表示我的网卡的物理地址。MAC 地址是固化在网卡的只读存储器中的一个地址，位于网卡的芯片上，理论上来讲一般是不能改的。 RX packets 13245 bytes 1989908 (1.8 MiB)：此次网卡激活后接搜到的报文数量，总大小； RX errors：接收时错误的个数；dropped：丢包个数；overruns：溢出个数；frame：帧。 TX packets 162 bytes 18461 (18.0 KiB)：传输的报文数量，总大小； TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0：传输时错误、丢包、溢出、搬运、碰撞的个数。 5、网络命令 mail12345简介： 命令所在路径：/bin/mail；作用：查看发送电子邮件格式： mail [用户名] mail 命令比 write 命令有一个好处，就是不管对方在不在线，都可以给对方发送邮件。Linux 的纯字符界面也可以进行邮件的收发，它利用的并不是真正的搭建好的邮件服务器，而是如果是本机用户给本机用户发信，它利用的是本地的内存。 mail 命令编辑完邮件后点击 Ctrl + D 保存结束。使用 mail 命令直接按回车，用来接受邮件，N 表示 new，即这是新收到的邮件还未阅读。想看第几分信，邮件前面有一个序列号，输入序列号回车就能看到这份邮件的具体内容，使用 h 键可以回到刚才的邮件列表，发现 N 消失了，表示邮件已读，要想删除邮件则「d 邮件序列号」，再按 h 查看邮件发现没有邮件了，q 键退出。 学习 mail 命令主要是有的时候系统会给 root 发一些系统信息的邮件，当你在用 root 登录以后系统会提示你有新的邮件需要接受，这个时候就需要我们知道怎么样来收到系统发给你（root）的信息。系统给 root 发送的信息都是非常重要的，例如日志的统计信息、系统的报错信息，当我们发现 root 有这样的邮件的时候，千万不可以忽略它，应该仔细的查看它，因为这说明你对的系统当中可能出现了一些问题，有可能会影响到你的系统的安全。 6、网络命令 last12简介： 命令所在路径：/usr/bin/last；作用：列出目前与过去登入系统的用户信息 该命令会统计我的计算机的所有用户的登陆的时间信息，包括计算机重启时间也会被记录下来。这是一个重要的日志查询点，可以查看系统是否有异常登陆重启等信息。该命令是一个非常有效，非常重要，非常常用的日志查询命令，在服务器上可能会多次使用这样的命令。只想知道用户最后一次登陆的时间，不想知道所有的登陆信息，则可以使用另外一条命令：lastlog。last 统计的是只要有人登陆它就会记录，包括你多次登陆的信息。而 lastlog 会先把所有的用户都列出来，包括一些不能登陆的系统用户。 7、网络命令 lastlog123456简介： 命令所在路径：/usr/bin/lastlog；作用：检查某特定用户上次登录的时间举例： # -u 指的是用户的 UID，查看特定用户的最后一次登陆的时间 lastlog -u 500 8、网络命令 traceroute12简介： 命令所在路径：/bin/traceroute；作用：显示数据包到主机间的路径 作用：探测到达某一个指定网站（某一个主机）的路径。这条命令非常有用，可以事先探测好你访问某网站的路径，然后当你访问该网站出现问题的时候，可以对照然后得出哪里出现了问题。我们 traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了返回信息，所以我们得不到什么相关的数据包返回数据。 9、网络命令 netstat1234567891011121314151617181920212223简介： 命令所在路径：/bin/netstat；作用：显示网路相关信息格式： netstat [选项]选项： -t 查询 TCP 协议的网络信息 -u 查询 UDP 协议的网络信息 -l 查看监听的端口，listening -r 查看路由即查看网关，route -n 用 IP 地址和端口号显示查询结果，而不是用域名或服务的名称，这样更快，因为省略了解析过程，numeric -a all举例： # 查看本机监听的端口，即查询当前计算机下，我开了哪些计算机端口 netstat -tuln # 查看本机所有的网络连接 netstat -an # 查看本机路由表，即查询路由列表 netstat -rn net 网络的意思，stat 即 state 状态的意思，查询网络状态的命令。这条命令的用途在服务器上非常广泛的。TCP 是传输控制协议的简称；UDP 用户数据报协议的简称。一般情况下服务的端口号是固定的，我们可以通过判断本机开了哪些监听端口来判断我的计算机开启了哪些服务。注意：TCP 协议才可以直接接受访问，所以它有 listen，代表状态是监听的。而 UDP 是没有的，它可以直接发送，不监听即不顾你在不在线。访问服务的时候不管访问的是 22 还是访问其他的服务，你的发起端口即源端口是 1024 以上的随机端口，只有目标端口是固定的。 发现该命令的输出分了两大类，一类是上面的这些网络服务，除了有监听的协议之外，状态还出现了 ESTABLISHED 表示正在连接的。另一类就是下面的除了服务状态计算机中会有很多网络程序，它也会使用网络协议，使用网络端口，你可以看到这些程序所占用的端口，这个对我们意义不大。主要看到还是上面的信息。它跟 netstat -tlun最大的区别在于 netstat -tlun 只能查看监听，而它可以查看到正在连接的网络程序。 Destination 为 0.0.0.0 那行是当前计算机的默认路由列表，其实就是自己的网关。可以通过该命令查询当前计算机的网关。还可以通过 route -n 或 cat /etc/resolv.conf 查看当前计算机的网关。 10、网络命令 setup12简介： 命令所在路径：/usr/bin/setup；作用：配置网络 setup 是 redhat 开发的一个管理工具集合，它在其它的版本的 Linux 中不存在，这是 redhat 系类专有的。注意在配置完成后一点要重启网络服务：service network restart。使用 setup 配置的 IP 地址是永久生效的。该命令简单了解即可。 挂载命令 mount12345678简介： 命令所在路径：/bin/mount格式： mount [-t 文件系统] 设备文件名 挂载点举例： mount -t iso9660 /dev/sr0 /mnt/cdrom 该命令的作用是把我的设备连接到我给它分配的挂载点（可以理解为 windows 中的盘符，只是我们的挂载点是目录，而 windows 中的是 CDEF）。分区都是自动挂载的，只要安装了，分区了，每次启动不需要手动参与直接就可以挂载。但是 Linux 的 U 盘、光盘、移动硬盘等外接存储设备不能实现自动挂载，每次开机都只能手工来挂载。 挂载步骤： 先创建挂载点：mkdir /mnt/cdrom。 开始实现挂载：mount -t （-t 后面指定光盘的文件系统）iso9660（光盘的文件系统是固定的） /dev/sr0（设备文件名称，其来源是系统默认指定的，Linux 系统在 redhat centOS6.0 以上的系统中，设备文件名默认就叫 sr0，只要记住就可以了，不需要知道它是怎么来的，当然也可以写 cdrom，实际上就是一个软连接，通过命令：ll /dev/cdrom 可以查看到）。这条命令中其实 -t iso9660 是可以省略的，因为该命令的这个选项或者说分区的光盘的文件系统是默认的，系统就知道它就叫 iso 9660，不写也可以。 挂载其实就是找到这个硬件，给它分配一个设备文件名，再给它找一个盘符（即目录），把它的设备文件名和盘符连接起来，就是挂载。（挂载的本质：就是把设备文件名连接到挂载点上）。如果之前你的这个挂载点上做过挂载，那么你需要把它卸载以后再进行挂载：umonut /dev/sr0。正常挂载完，mount 命令是没有任何提示的，这里提示的作用是报错，它尝试把它挂成写权限，但是光驱是只读的，所以被迫挂成了只读的，光盘绝大多数都是只读的。（windows 是光盘符下访问，而 Linux 中的盘符是目录）挂载完成后通过 cd（即cd /mnt/cdrom）切换到盘符目录下去访问它的数据。（/dev/sr0 是一个文件，cd 命令是进不去的）。注意：必须要执行卸载命令，才可以弹出光盘。切记不可以在光盘挂载点下面卸载，因为系统会认为光盘正在使用，不允许卸载。你需要退出挂载点，直接 cd 即可返回到自己的宿主目录。在卸载的时候，因为 /dev/sr0 和 /mnt/cdrom 它们两个通过 mount 命令已经连接了，所以后面加其中任何一个都是可以的，但是只能跟一个，要是跟两个它就会卸载两遍，第二遍它就会报错。直接回车没有任何提示表示卸载成功，再回到 /mnt/cdrom 执行 ls 命令发现变成了空目录了。 关机重启命令1、shutdown 命令123456格式：shutdown [选项] 时间选项： -c 取消前一个关机命令，cancel -h 关机，halt -r 重启，reboot 除了 shutdown 命令之外还有其他命令可以实现关机或重启，只是早期的时候只有 shutdown 命令会在关机和重启之前正确的保存它正在启动的服务，尽管现在 Linux 中绝大多数的关机重启命令都已经实现了正确的关闭服务和保存数据，只是我们已经习惯了 shutdown 命令了。虽然其他命令也可以做到，但是 shutdown 命令更安全一点，我们更信任它。 2、其他关机命令12345678# 关机halt# 关机power off# 关机init 0 注意：poweroff 相当于直接断电，谨慎使用！！！ 3、其他重启命令12345# 重启reboot# 重启init 6 4、系统运行级别12345670 关机1 单用户2 不完全多用户，不含 NFS 服务3 完全多用户4 未分配5 图形界面6 重启 单用户类似于 windows 中的安全模式，其实就是启动最小的服务，其他多余的东西、附加的程序都不要，甚至连网都不要，只启动最核心的程序，进去是用来做修复的。只能是 root 登录进去，其他用户都不行，顾名思义即为单用户。运行级别 1 是没有图形界面的，不光 1 级别没有图形界面，1、2、3 这 3 个运行级别都是没有图形界面的，4 是没有使用的，即可以自己定义，5 是标准的图形界面。2、3 其实都是命令行，区别是：3 是完全的命令行，而 2 是不包含 NFS 服务的命令行，即它也是命令行只是不完整（2 级别也没有网络服务）。NFS 服务：（network file system）网络文件系统，使用 NFS 是实现两个 Linux 之间的文件共享或者是 Linux 和 Unix 之间的文件共享的服务。由于 NFS 用户验证的机制比较弱，即可能不是太安全，有它自己的安全隐患在里面，所以不太建议使用 NFS 来进行文件共享，当然使用它进行文件共享确实很简单方便。 12345678# 查看系统默认运行级别cat /etc/inittab# 修改系统默认运行级别，注意：id 最后是有冒号的「:」，千万不可以丢！！！id:3:initdefault:# 查看系统运行级别runlevel 注意：0 和 6 不能设为系统默认运行级别。在 Linux 中用 X11 代表图形界面，大写的 X 指的是 Xwindow，一般来讲，在 Linux 中看到类似于这样的表示（包括只有一个大写的 X）都表示 Linux 的一个图形环境的意思。 执行 runlevel 命令之后会有「N 3」这样的显示，3 表示当前运行的级别号，N 代表上一个运行级别，即进入 3 级别之前我在哪个级别（由于我们是开机之后直接进来的，所以是 N 表示 null 的意思）。 init 5 表示切换到运行级别 5 即图形界面，由于我没有装图形界面它不会执行，且远程工具上是不会报错的，但是在 Linux 本地上会有报错提示，它尝试去启动 5 级别，但是没有启动成功。但是系统以为你进去了，所以执行 runlevel 命令的时候会有显示 5 3。 5、退出登录命令 logout退出一个登录 Shell。注意：在使用完 Linux 后，一定要 logout！！！否则后果很严重！！！ 6、Linux 中的管道符利用 Linux 所提供的管道符「|」将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。 参考博客centOS 7 安装 man 中文版手册Linux 中的内部命令和外部命令Linux 网络属性配置命令]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(五)]]></title>
    <url>%2F2018%2F09%2F18%2FJava-Java-Basic-2018-09-18-Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[Java 入门总结(五) —— Arrays 类 1、Java 中的 Arrays 类中包含一些对数组操作的静态方法。 2、Arrays 的 toString 方法可以方便的输出一个数组的字符串形式。 3、数组排序之基本类型，对指定类型的数组按升序进行排序。sort 方法还可以指定排序范围 [fromIndex, toIndex)。 4、数组排序之对象类型，sort 还可以直接接受对象类型，但对象需要实现 Comparable 接口。 5、数组排序之自定义比较器，sort 还可以接受一个比较器作为参数。Comparator 就是比较器，它是一个接口，最主要的是 compare 这个方法，它比较两个对象，返回一个表示比较结果的值，-1 表示 o1 小于 o2，0 表示相等，1表示 o1 大于 o2。排序是通过比较来实现的，sort 方法在排序的过程中，需要对对象进行比较的时候，就调用比较器的 compare 方法。 6、需要注意的是 binarySearch 针对的必须是已排序数组，如果指定了 Comparator，需要和排序时指定的 Comparator 保持一致，另外，如果数组中有多个匹配的元素，则返回哪一个是不确定的。 7、在创建多维数组时，除了第一维的长度需要指定外，其他维的长度不需要指定，甚至，第一维中，每个元素的第二维的长度可以不一样。 8、多维数组到底是什么呢？其实，可以认为，多维数组只是一个假象，只有一维数组，只是数组中的每个元素还可以是一个数组，这样就形成二维数组，如果其中每个元素还都是一个数组，那就是三维数组。 9、Arrays 类的 sort 实现原理： 基本数据类型数据：双枢轴快速排序(Dual-Pivot Quicksort)；是一种对快速排序（不稳定）进行优化后的算法； 引用数据类型数据：TimSort；是一种对归并排序（稳定）进行优化后的算法； 它们之所以没有采用相同的排序算法，跟排序算法的稳定性有关。快速排序更快，但不稳定，而归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没有关系。但对于对象类型，相同只是比较结果一样，它们还是不同的对象，其他实例变量也不见得一样，稳定不稳定可能就很有关系了，所以采用归并排序。 10、Comparator 接口和 Comparable 接口？Comparable 接口和 Comparator 接口的比较 参考博客Java编程的逻辑 —— 剖析 Arrays]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(四)]]></title>
    <url>%2F2018%2F09%2F17%2FLinux-2018-09-17-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(四) —— Linux 常用命令 目录处理命令1、命令格式1234567命令格式： 命令 [-选项] [参数]说明： 1. 个别命令使用不遵循此格式 2. 当有多个选项时，可以写在一起 3. 简化选项与完整选项，eg：-a 等于 --all 关于选项：在大多数的命令中，选项前面会有一个小横杆，用来标记这是一个选项；选项的作用：使用命令的时候用来做不同的操作，使命令结果呈现不同的形式或者信息内容，就可以加上不同的选项来实现，即选项是用来调整命令功能的。我们使用的选项都是简化选项，完整选项需要两个「-」 来调用，选项的顺序一般都是可以调整的。[] 里的内容是选择性加入的。加了选项是调整功能，加了参数是指定操作对象。 2、目录处理命令 ls123456789101112简介： 英文原意 list；命令所在路径：/bin/ls；作用：显示目录文件格式： ls [选项] [文件或目录]选项： -a a 表示 all -l l 表示 long -d d 表示 directory，显示当前目录本身，而不显示目录下的数据 -h h 表示 human，人性化显示文件大小 -i i 表示 iNode，显示 i 结点号 在 Linux 中，以「.」开头的是隐藏文件。隐藏文件的初衷是为了告诉用户这是一个系统文件，没有特殊情况一般不要修改它。在 Linux 中要想把一个文件隐藏，则需要给它改名，改成以点开头的文件名即可隐藏。 3、ls -l 显示结果分析 x 表示执行权限，是 execute 的缩写；可执行文件 .exe 的缩写也来源于这个单词。 引用计数，代表这个文件曾经被引用或者调用过几次。这个引用计数对文件和目录来讲只在硬链接中才有作用。 文件大小默认单位是字节。可以使用 -h 选项来调整。 上图中的时间表示该文件最后被修改的时间；如果没有被修改过，则就是它的创建时间。需要注意的是 Linux 中没有创建时间这个概念，它只有文件的最后一次访问时间，文件的状态修改时间，文件的数据修改时间这三个时间。 i 节点，在 Linux 系统中每个文件或者目录都有它自己的一个唯一标识编号，系统靠这个 i 节点号搜索或者查找文件或者目录。 4、目录处理命令 mkdir123456789101112简介： 英文原意 make directories；命令所在路径：/bin/mkdir；作用：创建新目录格式： mkdir [选项] 目录名选项： -p p 表示 parents，如果新创建的目录的父目录不存在，则自动递归创建父目录举例： # 可同时创建多个目录，多个目录之间以空格进行分割 mkdir /tmp/test1 /tmp/test2 /tmp/test3 目录在 windows 中又称为文件夹。不要轻易在根目录下创建新的目录或者文件。可以在 /tmp 目录下进行练习，该目录是用来存放临时文件的。 5、目录处理命令 cd12345简介： 英文原意 change directory；命令所在路径：shell 内置命令；作用：切换目录格式： cd [目录] 「.」 表示当前目录，「..」表示当期目录的上一级目录。 注意：在 Dos 窗口下 cd.. 中间是可以不加空格的，但是在 Linux 中，中间必须有空格。 6、目录处理命令 pwd12345简介： 英文原意 print working directory；命令所在路径：/bin/pwd；作用：显示当前所在目录的绝对路径格式： pwd 7、目录处理命令 rmdir123456789简介： 英文原意 remove empty directories；命令所在路径：/bin/rmdir；作用：删除空目录格式： rmdir [空目录]举例： # 可同时删除多个空目录，多个空目录之间以空格进行分割 rmdir /tmp/test1 /tmp/test2 /tmp/test3 注意：rmdir 只能删除空的目录！！！要想使用 rmdir 删除目录，必须先把该目录下的所有子目录和文件都删除掉，才可以使用。实际操作中此命令用的并不是很多。 8、目录处理命令 cp12345678910111213简介： 英文原意 copy；命令所在路径：/bin/cp；作用：复制文件或目录格式： cp [选项] [原文件或目录] [目标目录]选项： -r 复制目录，copy directories recursively -p 保留文件属性，same as --preserve=mode,ownership,timestamps举例： # 将 /tmp 下 test1、test2、test3 目录一次性复制到 /root 下，并保持目录属性 cp -rp /tmp/test1 /tmp/test2 /tmp/test3 /root 在 cp 复制文件的时候是不需要加选项的；但是要复制目录的话要增加选项 -r；cp 可以同时复制多个文件或者目录。 当把一个文件或目录复制到另一个地方的时候，相当于在另一个地方创建了一个新的文件或目录，所以复制出来的文件或目录的最后更改时间就是当前时间。如果希望复制出来的文件或目录的最后更改时间跟源文件一样，则使用 -p 选项。 在 Linux 中，复制文件或者目录的同时，可以更改目录或者文件的名字。 9、目录处理命令 mv123456789101112简介： 英文原意 move；命令所在路径：/bin/mv；作用：剪切文件、改名格式： mv [原文件或目录] [目标目录]举例： # /tmp 下 test1、test2、test3 目录一次性剪切到 /root 目录 # 当一次剪切多个目录或文件的时候就不能改名了，改名操作只支持一次一个，不支持一次多个文件或目录进行改名 mv /tmp/test1 /tmp/test2 /tmp/test3 /root改名： mv 要改名的文件名 新的文件名 在 Linux 中剪切和改名是同一个命令。在执行复制剪切等命令的时候，如果你的位置是在当前目录的话，可以省略绝对路径，但是在不清楚当前目录的情况下要写绝对路径。mv 命令是不需要加 -r 选项的，直接使用 mv 可以同时剪切一个或多个目录或者文件的，而且在剪切的同时可以改名。 10、目录处理命令 rm12345678910111213简介： 英文原意 remove；命令所在路径：/bin/rm；作用：删除文件或目录格式： rm [选项] [文件或目录]选项： -r 删除目录，recursive -f 强制删除，force举例： # 同时删除目录 test1 test2 文件 h1.txt h2.txt rm -rf test1 test2 h1.txt h2.txt 注意：Linux 中是没有回收站这一说的，文件一旦删除，就没有了。 在删除文件的时候每次都会询问你是否删除，如果你不想有这个提示的话，则可以加 -f 选项。 小结：mkdir 创建一个新的目录，选项 -p 递归创建目录；cd 切换目录；pwd 查看当前的工作目录；rmdir 删除一个空目录；cp 复制文件 -r 复制目录 -p 复制的时候保持文件的属性；mv 剪切或者给一个文件改名；rm 删除文件 -r 删除目录 -f 删除目录或者文件的同时不希望询问确认。 文件处理命令1、文件处理命令 touch12345简介： 命令所在路径：/bin/touch；作用：创建空文件格式： touch [文件名] 注意：在 Linux 的命令里面，如果这个命令的参数没有详细的指定它的绝对路径，就表示要在当前目录下执行这个操作。要想在其他目录下执行这个操作，一定要指明它的绝对路径。 在 Linux 的文件命名里，除了「/」不能使用外，其它特殊符号都是合法的文件名，其后缀名是可以随便起的，这跟 windows 不一样。注意空格这个特殊符号，在 Linux 中并不建议将空格作为文件名组成部分，由于 Linux 系统把空格作为分隔符，要想使用空格作为文件名则必须用引号扩起来，这样虽然可以用空格作为文件名，但是对以后该文件的查找、修改、复制等操作造成麻烦，所以不建议这样使用。 2、文件处理命令 cat12345678简介： 命令所在路径：/bin/cat；作用：一次性显示整个文件内容格式： cat [选项] [文件名]选项： -n 显示行号，number cat 命令适合看简短的文件。cat 不适合浏览比较长的文件。cat 命令会一次性列出文件所有内容 3、文件处理命令 tac12345简介： 命令所在路径：/usr/bin/tac；作用：一次性显示整个文件内容（反向列示）格式： tac [选项] [文件名] 4、文件处理命令 more12345678910111213简介： 命令所在路径：/bin/more；作用：分页显示文件内容格式： more [文件名]快捷键： 空格或 f 翻页 Enter 换行 q 或 Q 退出举例： more /etc/services more 命令是一个常用的分页显示文件内容的命令。该命令不可以往上翻。 5、文件处理命令 less12345简介： 命令所在路径：/usr/bin/less；作用：分页显示文件内容（可向上翻页）格式： less [文件名] 使用 less 命令，不仅可以像 more 命令一样进行浏览，还可以往上翻，使用 PgUp 表示一页一页往上翻，使用向上的剪头表示一行一行往上翻。还可以进行搜索：直接在 less 的浏览状态里面按一个「/」+ 你要搜索的关键词，就会把行里所有包含这个关键词的进行反白显示，同时如果在你当前查看的页里没有你要得到的搜索的关键词所在行的信息，可以按 n 表示 next 接着往下找。 6、文件处理命令 head1234567891011简介： 命令所在路径：/usr/bin/head；作用：显示文件前面几行格式： head [选项] [文件名]选项： -n 指定行数举例： head -n 20 /etc/services 如果只想看文件的前几行，则可以使用此命令。如果不用 -n 指定要显示的行数，则默认显示的是前 10 行。 7、文件处理命令 tail123456789简介： 命令所在路径：/usr/bin/tail；作用：显示文件后面几行格式： tail [选项] [文件名]选项： -n 指定行数 -f 动态显示文件末尾内容 显示文件最后面几行内容，默认是 10 行。-f 动态显示文件末尾的内容。使用该命令以后它会显示文件最末尾的位置，但是它并没有回到命令行，如果这时你这个文件的内容进行了变化，在这个命令操作状态下它也会实时变化的。一般来说用的也不会太多，一般用来监控一些日志。 小结：touch 创建一个文件；cat 查看文件的内容（浏览一些短文件），-n 用来显示行号；tac 反向显示文件内容（反向显示并不支持 -n 这个选项）；more 分页显示文件内容（主要指一些长的文件，不可以向上翻）；less 分页显示文件内容（可以向上/下翻，使用 「/ + 要搜索的关键词」在浏览的过程中遍历整个的文件进行搜索，可以用 n 键查找下一个匹配的位置）；head 查看一个文件的前几行，-n 指定要查看前几行，默认为 10 行；tail 查看一个文件的最后几行，-n 指定要查看后几行，-f 动态显示文件最后的内容，默认为 10 行。 8、文件处理命令 ln123456789101112131415简介： 英文原意 link；命令所在路径：/bin/ln；作用：生成链接文件格式： ln [选项] [原文件] [目标文件]选项： -s 创建软链接，s 代表 symbolic，make symbolic links instead of hard links，即创建符号链接而不是硬链接举例： # 创建 /etc/issue 的软链接 /root/issue.soft ln -s /etc/issue /root/issue.soft # 创建文件 /etc/issue 的硬链接 /root/issue.hard ln /etc/issue /root/issue.hard 9、软链接特征类似 windows 快捷方式。作用：方便快捷的让你找到你最常使用的一些东西，便于规划，方便管理。 在 Linux 系统里面，它前面的 10 个文件权限的标识全部都是 lrwxrwxrwx，意味着所有的人都有全部的操作权限，每个用户在对这个软链接进行操作的时候，到底他能具有什么样的权限，是由这个文件对应的源文件的权限最终决定的。 软链接文件大小很小，因为它只是一个符号链接。 有一个箭头指向到它所对应的源文件（硬链接是没有箭头指向的）。 10、硬链接特征 拷贝「cp -p」+ 同步更新。cp -p 是拷贝文件并且保留文件的属性不变；同步更新即不管是修改原文件还是硬链接文件，两者的内容始终会自动保持一致，即同步更新。 通过 i 结点识别，硬链接的 i 节点与源文件的 i 节点一样。 不能跨分区。 不能针对目录使用。 软链接与硬链接的区别：硬链接就类似于拷贝，但是可以同步更新，源文件即使不在了，硬链接照样可以访问，因为是类似拷贝的。如果软链接源文件不在了，则它会报错找不到源文件。一个文件一定有一个 i 节点，但是一个 i 节点不一定只对应一个文件，硬链接就是一个特殊案例，一个 i 节点映射到了多个文件。注意硬链接在 Linux 中用的非常少！ 权限管理命令1、权限管理命令 chmod12345678910111213简介： 英文原意 change the permissions mode of a file；命令所在路径：/bin/chmod；作用：改变文件或目录权限格式： chmod [选项] [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [文件或目录] chmod [选项] [mode] [文件或目录]选项： -R 递归修改举例： # 可以同时做多个授权，中间用「,」逗号分隔 chmod u+rwx,g+rw,o=r test.txt 一个文件或目录的权限只有两个人可以更改：一个是该文件或目录的所有者，另一个就是管理员 root。 权限数字表示：r=4，w=2，x=1。 2、文件目录权限总结 注意：读写执行权限对目录的含义！！！要想删除一个文件，你必须有这个文件所在的目录的写权限。对于目录，r（查看目录内容）、x（进入目录）权限一般都是一起出现的。 3、权限管理命令 chown123456789简介： 英文原意 change file ownership；命令所在路径：/bin/chown；作用：改变文件或目录的所有者格式： chown [用户] [文件或目录]举例： # 改变文件 test.txt 的所有者为 root chown root test.txt 在 Linux 系统中，改变一个文件或者目录的所有者，只有管理员 root 可以做这样的操作。可以使用 useradd 命令来添加一个用户，使用 passwd 为该用户设置一个密码。 4、权限管理命令 chgrp123456789简介： 英文原意 change file group ownership；命令所在路径：/bin/chgrp；作用：改变文件或目录的所属组格式： chgrp [用户组] [文件或目录]举例： # 改变文件 test.txt 的所属组为 family chgrp family test.txt 在 Linux 系统中，改变一个文件或者目录的所属组，只有管理员 root 可以做这样的操作。 添加用户组命令：groupadd。 所有者：谁创建的文件谁就是文件的所有者；所属组：一个用户可以属于多个组，但是他总有个缺省组（缺省，即系统默认状态，意思与「默认」相同），每个用户创建文件的时候，它（该文件）的所属组就是该用户的缺省组，每个用户只能有一个缺省组。所以在创建一个文件的时候，它的所有者就是他自己即文件的创建者，它的所属组就是这个文件创建者的缺省组（了解即可）。 5、权限管理命令 umask12345678简介： 英文原意 the user file-creation mask（mask 掩码的意思）；命令所在路径：Shell 内置命令；作用：显示、设置文件的缺省权限格式： umask [-S]选项： -S 以 rwx 形式显示新建文件缺省权限（注意 S 大写） 在 Linux 权限管理有一个最基本的定义：缺省创建的文件是不能具有可执行权限的。所以在 Linux 系统中任何新建的文件都会把可执行权限去掉。这样做的目的是为了安全。注意只针对文件，对目录没有这样的限制。 直接执行 umask 命令会得到一个 4 位的数字：0022。第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认的权限 rwxr-xr-x。而 Linux 系统中任何新建的文件都会把可执行权限去掉，所以你新建的任何一个文件的权限就是：rw-r–r–。 要想更改缺省权限，则需要先写出你要更改权限的数字，eg：rwxr-xr– 即 754，然后用 777-754=023，最后 umask 023 将缺省创建的权限改为 rwxr-xr–。虽然缺省创建的权限是可以更改的，但是并不建议这样去做。 文件搜索命令注意：尽量减少搜索这个操作，因为搜索它会占用大量的系统资源。在服务器高峰期里面，是不建议用搜索这个命令的。原则：不要在服务器使用高峰期的时候使用 find 命令来进行查找；在查找的过程中搜索的范围越小越好；搜索的条件越精准越好。 1、文件搜索命令 find123456789101112131415161718192021222324252627282930313233343536373839404142简介： 命令所在路径：/bin/find；作用：文件搜索格式： find [搜索范围] [匹配条件]举例： # 在目录 /etc 中查找文件 init find /etc -name init # -iname 不区分大小写 find /etc -iname init # （注意数据块概念）在根目录下查找大于 100MB 的文件；+n 大于 # -n 小于，n 等于 find / -size +204800 # 在 /etc 下查找大于 80MB 且小于 100MB 的文件 # -a 两个条件同时满足，and # -o 两个条件满足任意一个即可，or find /etc -size +163840 -a -size -204800 # 在根目录下查找所有者为 root 的文件 find / -user root # 在根目录下查找所属组为 root 的文件 find / -group root # 在 /etc 下查找 5 分钟内被修改过属性的文件和目录 # -amin 访问时间 access；-cmin 文件属性 change；-mmin 文件内容 modify # +n 大于多长时间，-n 多长时间以内，n 等于 find /etc -cmin -5 # -type 根据文件类型查找 # f 文件；d 目录；l 软链接文件 find /etc -type f # -inum 根据 i 节点查找 find /etc -inum 12345 # 在当前目录中查找 iNode 为 666 的文件或目录并删除 find . -inum 666 -ok rm &#123;&#125; \; 注意利用 -name 搜索的话，它只会搜索文件名是 init的文件，而不像 windows 里面那样只要文件名包含 init 就都会被搜素到，可以理解为这是一种非常精准的搜索。要想像 windows 一样，可以做一个模糊的搜索即只要是包含 init 这 4 个连续的字母，就可以被搜素到，则：find /etc -name init，「」号表示通配符，意思是只要文件名里有 init 就会被搜索到。init 表示以 init 开头的；init??? 表示 init 以后有 3 个字符，问号匹配单个字符。Linux 中常用的两种通配符：* 号可以匹配任意字符，? 号可以匹配某个单个字符。 注意：在 Linux 系统中，一个数据块默认是 512 字节即 0.5kb；数据块是 Linux 系统中存储文件的最小单位。而 -size 的大小是用数据块换算的，所以 100MB 的文件所对应的就是 204800 个数据块。 123# 在 /etc 下查找 inittab 文件并显示其详细信息# 「-exec/-ok 命令 &#123;&#125; \;」对搜索结果执行操作find /etc -name inittab -exec ls -l &#123;&#125; \; 前面还是正常写 find 要执行的查找的命令，找到这个结果以后，可以使用 -exec/-ok 直接连接一个命令即对 find 查找的结果做一些操作，再加上固定格式「{} \;」。{} 表示的是 find 查找的结果，表示对 find 查找的结果做一个替换，因为 find 查找的结果可能有多个，所有使用 {} 表示。「\」表示转义符，「;」表示结束。注意：「;」分号，不要丢掉，而且「\」和「;」之间没有空格分隔！！！ -exec 和 -ok 的区别：-exec 直接执行，-ok 会一个个询问你是否执行（即会有询问确认环节）。 find -inum 使用场景，确定一个文件是否有硬链接。查看一个文件是否有硬链接：首先查看该文件的 i 节点，然后在整个它所在的分区里面（硬链接不能跨分区）做一个搜索，找 i 节点是你这个指定数字的文件，它就会把它的硬链接文件找到。 小结：find 命令 -name 根据文件名来查找；-iname 查找的时候不区分大小写；使用的通配符：* 匹配任意字符，? 匹配单个字符；-size 根据文件大小来查找，+ 大于多少，- 小于多少；-user 根据所有者来查找；-group 根据所属组来查找；-amin 根据访问时间来查找；-cmin 根据文件属性的更改查找；-mmin 根据文件内容更改来查找；-type 根据文件类型来查找，f 文件，d 目录，l 软链接；-inum 根据 i 节点来查找；-a 连接两个条件，表示两个条件都满足；-o 表示两个条件只有满足一个就可以；-exec 或者-ok 对搜索的结果直接进行操作，二者的区别只有一个就是 -ok 会询问确认，固定格式「{} \;」。 其他搜索命令1、文件搜索命令 locatecentos locate 命令安装12345678简介： 命令所在路径：/usr/bin/locate；作用：在文件资料库中查找文件格式： locate 文件名举例： locate inittab 该命令在查找的时候不像 find 来遍历你所搜索的范围，而是建立了一个文件资料库（该资料库会定期更新），它在找的时候不是在硬盘上找，而是在资料库里面找你有搜索的文件，所以速度很快。虽然使用 locate 命令查找的速度非常快，但是新建的文件使用该命令是找不到的，因为 locate 的文件资料库并没有更新。手动更新文件资料库命令：updatedb。 注意：/tmp 临时文件目录，并不在文件资料库所收录的文件范围之中，如果你要找的文件在 /tmp 目录下面，使用该命令是找不到的。如果希望 locate 命令在查找的时候不区分大小写，可以使用选项「-i」。 2、文件搜索命令 which12345简介： 命令所在路径：/usr/bin/which；作用：搜索命令所在目录及别名信息格式： which 命令 which 提供了一种快速查找一个命令所在的绝对路径的方法。除了可以找到命令所在的目录还可以找到该命令的别名，查看该命令本身是否有别名相关的信息。 实际上在 Linux 系统中，本身是没有询问确认的机制，之所以现在在 Linux 系统中有询问确认的选项，是因为它加了一个 -i 的选项，eg：在使用 rm 命令的时候，系统在找的时候找到的是一个别名而不是一个命令，它的别名等于「rm -i」，「-i」这个选项实际上就是一个询问确认的选项，所以这是别名的作用。 3、文件搜索命令 whereis12345简介： 命令所在路径：/usr/bin/whereis；作用：搜索命令所在目录及帮助文档路径格式： whereis [命令名称] whereis 除了可以找到命令所在的绝对路径，还可以找到这个命令它相关的帮助文档所在的位置，这个帮助文档就是 man 命令所展示的文件。 4、文件搜索命令 grep12345678910111213141516简介： 命令所在路径：/bin/grep；作用：在文件中搜寻字符匹配的行并输出，属于精确匹配格式： grep [选项] [指定字串] [文件]选项： -i 不分区大小写 -v 显示排除指定字串的行举例： # 列出在 /etc/issue 文件中包含 hello 字串的行，且忽略大小写 grep -i hello /etc/issue # 列出 /etc/issue 文件中所有不包含 Hello 字串的行 grep -v Hello /etc/issue 「-v #」表示把 # 号所在的行都去掉，不管 # 号在什么位置，只要该行有 # 号，就都去掉。这样做是不太合理的，可能 # 位于中间，前面是有有效代码的。所以要想把行首以 # 开始的注释行去掉，要在 # 前面加一个表示行首的「^」即「^#」。使用 grep 命令查找文件中除注释以外的内容：grep -v ^# 文件名，需要注意的是针对 Shell 脚本的首行 # 号，应该做特殊处理。 小结：locate 快速定位到一个文件所在的路径（文件资料库），updatedb 更新文件资料库（有个别目录下的文件并不被收录到文件资料库中 /tmp），-i 不区分大小写；which 或者 whereis 查找命令所在的绝对路径；grep 在文件内容中查找，-i 不区分大小写，-v 排除查找。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(三)]]></title>
    <url>%2F2018%2F09%2F12%2FLinux-2018-09-12-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(三) —— Linux 网络]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(二)]]></title>
    <url>%2F2018%2F09%2F12%2FEnglish-2018-09-12-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[求实英语(二) —— 主谓宾 1、他整天没地方去也没事儿干。He goes nowhere and has nothing to do every day. 2、她天天在哪儿吃午饭？Where does she have lunch every day? 3、你怎么不常和他们一块儿来？Why don’t you often come with them? 4、王芳有姐姐吗？Does WangFang have any sisters? 5、为什么他总听你的而不听我的？我不知道。Why does he always listen to you but doesn’t listen to me? I don’t know. 6、他了解你多少？你非常了解他吗？How much does he know you? Do you know him very well? 7、你们每周怎么去那儿?How do you get there every week? 8、李梅不知道那事儿，但我知道。LiMei doesn’t know that but me. 9、每天下班后，Tod 都载我回家。Tod picks me up home after work every day. 10、这些小狗都叫什么？它的名字是 TianTian,那只叫 LeLe。What are these dogs’ names? Its name is TianTian, that is called LeLe. 11、他准时上学并及时做作业。He goes to school on time and does his homework in time. 12、没人相信他，因为他经常撒谎。他太丢人了。Nobody believes him because he often tell lies. He is very shameful. 13、你妈把我的手表放什么里边了？what does your mother put my watch in? 14、我像他，但却不喜欢他。I am like hime, but I don’t like him. 15、你这么辛苦工作是为了什么？what do you work hard for? 注意事项on time 准时in time 及时]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求实英语(一)]]></title>
    <url>%2F2018%2F09%2F11%2FEnglish-2018-09-11-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[求实英语(一) —— 主系表 1、我姐姐在那儿吗？她和谁在一起呢？ 我的：Is my sister at there? whom is my sister with?答案：Is my sister there? whom is she with? 解析：there 在这里是名词，表示哪个地方的意思，所以不用 at。问句中用她来指代我姐姐。 2、我妈妈没在家，她和街坊出去了。 我的：My mother is not at home, she is with neighborhood out.答案：My mother is not at home, she is out with some neighbors. 解析：out 在 这里是形容词，表示外面的。 3、那本书怎么样？它在你的手里吗？ 我的：How is that book? Is it in your hand?答案： 4、这是给我的，那些是给谁的？ 我的：This is for me, whom are those for?答案： 5、Sam Sterm 根本就没在这儿，他每天在二楼办公。 我的：Sam Sterm is not here at all, he is at second floor everday.答案：Sam Sterm is not here at all, he is at work on the 2nd floor ever day. 解析：在工作用 at work 表示，在二楼用 at 2nd floor 表示，everday 是形容词每天的，而不是每天，这个是副词。 6、他是干什么的？他不是经理吗？ 我的：What is he? Is not he a manager?答案： 7、你的小狗在哪儿？它在什么里边？ 我的：Where is your dog? What is it in?答案： 8、这是谁的办公室？里边有人吗？哪间办公室是你的？ 我的：Whom is this office? Who is in the office? Which is your office?答案：Whose office is this? Is anyone in? Which office is yours? 9、我的电话出了毛病，手机在哪儿？ 我的：My phone is wrong, where is cell phone?答案：Something is wrong with my telephone,where is the cellphone? 10、电视开着呢，把它关上吧！ 我的：The TV is on, turn it off!答案： 11、我的备份没在你的电脑里吗？ 我的：Is not my copy in your computer?答案： 12、这是干什么用的？ 我的：What is this for?答案： 13、我的手机昨天就在这儿放着呢! 我的：My cellphone was right here yesterday!答案： 14、这个书包是谁的？那是谁的书包？我的在这儿！她的呢？ 我的：Whose bag is this? Whose bag is that? My bag is here! Where is her bag?答案：Whose is this bag? Whose bag is that? Mine is here! where is hers? 15、这本字典不像我的，但那本像。 我的：This dictionary is not like mine,bug that is like.答案：This dictionary is not like mine,bug that one is. 注意事项1、注意区分以下两种形式：Whose is this bag？这个包是谁的？ This bag is whose.Whose bag is this？这是谁的包？ This is whose bag. 2、区分 我、你、他 这些代词的各种形式： 主格 宾格 属格 属格(名词性) I me my mine you your your yours he him his his she her her hers it its its its they them their theirs 参考博客英语代词有哪些？]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java入门总结(四)]]></title>
    <url>%2F2018%2F09%2F10%2FJava-Java-Basic-2018-09-10-Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%9B%9B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(三)]]></title>
    <url>%2F2018%2F09%2F10%2FJava-Java-Basic-2018-09-10-Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Java 入门总结(三) —— NIO Buffer1、在 Java 中，已有的 IO 操作大部分都属于阻塞的操作。为了提升服务器操作的性能，在 JDK1.4 之后增加了 NIO，在整个 NIO 的操作中，基本上都是使用缓冲区完成的。 2、public abstract class Bufferextends Object 抽象类 Buffer 是一个用于特定基本类型数据的容器。 3、缓冲区是特定基本类型元素的线性有限序列。除内容外，缓冲区的基本属性还包括容量、限制和位置： 缓冲区的 容量(capacity) 是它所包含的元素的数量。缓冲区的容量不能为负并且不能更改。缓冲区的 限制(limit) 是第一个不应该读取或写入的元素的索引。缓冲区的限制不能为负，并且不能大于其容量。缓冲区的 位置(position) 是下一个要读取或写入的元素的索引。缓冲区的位置不能为负，并且不能大于其限制。 对于每个非 boolean 基本类型，此类都有一个子类与之对应。 4、标记、位置、限制和容量值遵守以下不变式： 0 &lt;= 标记 &lt;= 位置 &lt;= 限制 &lt;= 容量 。 5、清除、反转和重绕 clear() 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为容量大小，将位置设置为 0。flip() 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为当前位置，然后将位置设置为 0。rewind() 使缓冲区为重新读取已包含的数据做好准备：它使限制保持不变，将位置设置为 0。 6、直接 与 非直接缓冲区字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。 直接字节缓冲区可以通过调用此类的 allocateDirect 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 直接字节缓冲区还可以通过 mapping 将文件区域直接映射到内存中来创建。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。 Channel1、在 NIO 中，通道是一个可以用来读取和写入数据的一种形式。Channel 接口，用于 I/O 操作的连接。通道表示到实体的开放连接。 通道表示到实体，如硬件设备、文件、网络套接字或可以执行一个或多个不同 I/O 操作（如读取或写入）的程序组件的开放的连接。通道都是通过操作缓冲区来完成全部功能的。所有的内容都是先读或写到缓冲区之中，再通过缓冲区读或写入到通道中的，即程序不会直接操作通道。 2、Java NIO Channel 通道和流非常相似，主要有以下几点区别： 通道可以读也可以写，流一般来说是单向的（只能读或者写）。通道可以异步读写。通道总是基于缓冲区Buffer来读写。 3、什么是内存映射？将文件中的某个区域直接映射到内存中；对于较大的文件，这通常比调用普通的 read 或 write 方法更为高效。 在通道中还有一种方式成为内存映射。内存映射是速度最快的，MapperedByteBuffer，使用此种方式读取的内容是最快的，需要将一个输入的操作流绑定在内存映射上。 内存映射在读取的时候是最快的，但是如果执行的是写入操作则有可能是非常危险的，因为仅仅只是改变数组中的单个元素这样简单的操作就可能直接修改磁盘上的文件，因为修改数据与将数据保存在磁盘上是一样的。 文件锁在 Java NIO 中提供了文件锁的功能，这样当一个线程将文件锁定之后，其他线程是无法操作此文件的，要想进行文件的锁定操作，则要使用 FileLock 类完成，此类的对象需要依靠 FileChannel 进行实例化操作。 锁定方式： 共享锁：允许多个线程进行文件的读取操作。独占锁：只允许一个线程进行文件的读/写操作。 Selector推荐阅读Java NIO 浅析Java NIO Channel 通道]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(二)]]></title>
    <url>%2F2018%2F09%2F06%2FLinux-2018-09-06-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(二) —— Linux 系统安装 磁盘分区磁盘分区又叫系统分区，是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。从字面意思来讲，磁盘分区指的就是把大的硬盘按照我的需求划分成几个分区，不同类目录与文件可以存储进不同的分区。 分区类型 主分区：最多只能有 4 个。 扩展分区「是从主分区的 4 个分区之中拿出 1 个分区作为扩展分区」： 扩展分区最多只能有 1 个（注意：针对一块硬盘来讲，一个硬盘最多只能有一个扩展分区）。 主分区加扩展分区最多只能有 4 个。 扩展分区本身不能写入数据也不能格式化，唯一的作用就是用来包含逻辑分区。 逻辑分区「即扩展分区中的逻辑分区」：可以正确的写入数据和格式化。按照硬盘的限制，一块硬盘最多只能分 4 个分区，即 4 个主分区。这种限制不是 Linux 系统的限制而是硬盘本身的限制，只要硬盘结构不发生变化，这种限制会一直存在。 格式化硬盘正确分区以后还不能写入数据，硬盘还必须经过格式化以后才可以写入数据。 格式化 (高级格式化) 又称逻辑格式化，它是指根据用户选定的文件系统（如 fat16、fat32、NTFS、ext2、ext3、ext4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。 在 windows 中可以识别的文件系统有 fat16、fat32、NTFS，在 linux 中可以识别的文件系统有 ext2、ext3、ext4，centOS 默认使用的是 ext4。 硬盘的格式化最主要的目的就是为了在硬盘当中写入文件系统，写入文件系统最主要的工作就是按照文件系统的规则把硬盘分成等大小的数据块，然后建立 iNode 表，我们把表里的编号称为 i 节点号又名 iNode 号。 当在查找文件的时候，是通过 iNode 表找到 i 节点号来找到这个文件的条款，从而知道这个文件保存在哪几个数据块之中，从而找到这几个数据块拿出文件，拼凑成我们的文件。这个格子就叫做数据块，又名 block。 在 centos 当中，默认的文件系统是 ext4，它在进入格式化的时候，它需要把硬盘划分为一个又一个等大小的数据块，这个数据块默认的标准大小为 4kb。假如有一个数据是 10kb，需要占用 3 个格子，最后一个格子只放了 2kb 数据，剩余的 2kb 空闲空间是不能再被其它文件所占用的，这 3 个格子不一定在一块。windows 中有一个磁盘碎皮整理，它的原理就是将保存的同一个文件的格子尽量放到一起，这样更有利于数据的读取。 硬件设备文件名如果是 windows，在进行了分区、格式化之后，给分区分配盘符然后就可以直接使用了。但是 Linux 不行，Linux 在进行了分区、格式化，格式化完成之后，要想给分区分配盘符之前，还必须给每一个分区起一个设备文件名，或者说给每一个分区起一个硬件设备文件名。 在 Linux 中所有的硬件设备都是文件。 「/」表示 Linux 中的最高一级目录，也就是根目录。在根目录下有一个 dev 的一级子目录，在 dev 目录中放入的所有的文件都是硬件文件。我们将硬件文件名，称为硬件的设备文件名。 为什么 Linux 需要「硬件设备文件名」而 windows 不需要？在 windows 中，硬盘分区、格式化之后，然后可以直接分配盘符是因为我们可以在 windows 的图形界面中直接看到这个硬盘在哪（注意：一台机器可能有多个硬盘），所以可以直接分配盘符（windows 有完善的图形界面）。但是 Linux 最早出现的时候，是没有图形界面的，为了让系统知道我要给哪一个硬盘分配盘符，所以被迫需要给每一个硬盘或者硬件设备指定设备文件名。 硬件设备文件名是固定的，系统自动检测的，我们能看懂就行。 关于硬盘，我们现在主要使用的是 SATA 硬盘接口，IDE、SCSI 硬盘接口基本被淘汰了。 分区设备文件名硬盘有了「硬件设备文件名」，还要给分区也要分配文件名，这就是「分区设备文件名」。「分区设备文件名」是在硬盘「硬件设备文件名」之后，直接加分区号就可以了。即硬盘有设备文件名，分区也应该有设备文件名，区别是一个是硬件设备文件名，一个是分区设备文件名。 分区设备文件名：分区文件名是在硬盘文件名之后直接加分区号，1 表示这个硬盘当中的第一个分区，依次类推。注意分区号有主分区号和逻辑分区号。 逻辑分区是从 5 开始的，1234 只能给主分区或者扩展分区使用，即使一个硬盘中没有分够 4 个主分区，逻辑分区也不能占用 1234 这 4 个分区号，即不管如何分区 5 都表示逻辑分区的第一个分区。 挂载windows 中分配盘符的操作在 Linux 中叫做挂载，我们把给分区分配盘符的过程称为挂载，我们把盘符叫做挂载点。在 Linux 中是使用空的目录名称作为盘符，而不是使用 CDEF 作为盘符，理论上任何一个目录都可以作为盘符，实际上有些目录是不可以的。 对于 Linux 来讲有两个必须分区：根分区、swap 分区（交换分区，大小一般为内存的 2 倍，一般不超过 2GB）。这两个是必须分区，如果不分区，则 Linux 不能安装，只要有这两个分区，Linux 就可以正常使用。还有一个推荐分区，/boot（启动分区，大小一般为 200M)。 根分区用于存放剩余数据，swap 分区可以理解为虚拟内存，即当我真正的内存不够用的时候可以拿交换分区的硬盘空间来当内存来用，理论上讲 swap分 区应该是内存的两倍，但是最大不超过 2GB，因为虚拟内存到底不是真正的内存，如果给它给的再大，它也不能取代内存，当它达到 2GB 的时候，如果再给大，只会占用我们更多的硬盘空间，但是对我们的系统不会产生更多的影响，所以最大不超过 2GB。 Boot 分区是专门用来保存启动时候的数据，任何操作系统启动的时候都需要一些硬盘空间，如果不给 boot 分区，万一根分区写满了，系统可能就启动不了了，为了解决这个问题，一般都会给 boot 单独分区。Boot 分区 200MB 足够，不用太大，写完之后不再往 boot 分区写入任何数据，它永远都会有一定的空余空间，就算把根分区写满了，也不会影响 Linux 启动。 Linux 文件系统结构 从 Linux 系统上看，boot、home 都是根分区的子目录。但是从硬盘上来看，它们每一个目录都可以有自己独立的硬盘空间，即每一个目录都可以有自己独立的分区，而每个分区又对应某块硬盘空间，所以每个目录都可以有自己独立的硬盘空间。 挂载点就是分区的盘符，swap 分区即交换分区没有盘符，swap 分区不是给用户用的，是由 Linux 操作系统或者内核直接调用的，所以它根本不需要盘符，有了盘符反而不正确了。swap 对系统性能的影响极小，所以分的空间不用太大。 总结 分区：把大硬盘分为小的逻辑分区；格式化：格式化的目的是为了写入文件系统，当然在写入文件系统的时候会附带的把硬盘当中的数据清空；分区设备文件名：给每个分区定义设备文件名；挂载：给每个分区分配挂载点，这个挂载点必须是目录，而且必须是空的目录才可以进行挂载点分配。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 入门总结(一)]]></title>
    <url>%2F2018%2F09%2F06%2FLinux-2018-09-06-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Linux 入门总结(一) —— Linux 系统简介 Unix 发展史Unix 与 Linux 的关系就像是父子关系，Unix 是父亲，Linux 是儿子。肯.汤普森在 1969 年开发出了 Unix 系统。1971 年，肯.汤普森的同事丹尼斯.里奇发明了 C 语言，随后 Unix 系统绝大部分源代码用 C 语言重写，为提高 Unix 系统的可移植性打下基础。 Unix 主要发行版本 Linux 发展史Linux 系统诞生于 1991 年，由芬兰大学生李纳斯(Linux Torvalds) 和后来陆续加入的爱好者共同完成。Unix 和 Linux 的内核都是用 c 语言写的。Linux 是开源软件。 Linux 发行版和 Linux 内核的区别？内核版是 Linux 官方发布的，仅仅是单纯的内核。在拿到内核以后，每个产商可以加入自己的桌面、应用程序等再进行开发，称为发行版。Linux 内核官网：www.kernel.org。 Linux 主要发行版本Linux 主要分为两个系列：redhat 系列和 debian 系列。其本质是一样的，因为两者采用系统的内核。最主要的区别就是软件安装的方式不一样。Redhat 系列主要分为 HEL 和 federo 两个系列，其中 federo 是个人版，HEL 是企业版。对于 Linux 的企业版和个人版跟 windows 是不一样的，对于 windows 而言 windows7 是个人版，windows2008 是企业版，它们的区别是 windows7 可以看成是 windows2008 的一个阉割版，windows2008 才是完整的。但是 Linux 不同，个人版和企业版的区别在于，个人版是开发版，可能有的功能没有进行过测试，更像是一个实验体，而企业版是稳定版。 开源软件的特点 使用的自由：绝大多数开源软件免费（注意的是开源和免费并不是等同的，开源软件也可以出售，但是卖给你的是源代码，并不是编译之后的代码给你）。 研究自由：可以获得软件源代码（开放源代码带来的好处——安全，足够多的眼睛可以发现更多的问题，可以容易的看到大神级人物的代码风格和注释）。 散步及改良自由：可以自由传播、改良甚至销售。 Linux 的应用领域 基于 Linux 的企业服务器：企业服务器。 嵌入式应用：Android 平台就是一个典型的 Linux 嵌入式应用、智能家电如机顶盒、游戏机、数码相机等。 电影娱乐业：用于电影、图片的后期处理。 Linux 为什么选择命令行？Linux 选用命令行界面主要是考虑到系统的稳定性和安全性，如果装了图形界面，对系统资源的占用是比较庞大的，所以比较不好用。而 windows 考虑的是易用性，windows 系统主要考虑的是系统的易用性。 拓展1、www.netcraft.com 是一个典型的扫描和踩点网站。只要输入你要查询的网站，就可以获取网站后台服务器所采用的操作系统。该网站是一个全球著名的信息统计网站。从攻击的角度叫踩点，从防御的角度叫扫描。 2、www.top500.org 会统计全球范围内运算能力排在前 500 的服务器或者叫群组。]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十四)]]></title>
    <url>%2F2018%2F08%2F28%2FJava-Java-Thread-2018-08-28-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E5%8D%81%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十四) —— CompletionService 1、在异步任务程序中，一种常见的场景是，主线程提交多个异步任务，然后希望有任务完成就处理结果，并且按任务完成顺序逐个处理，对于这种场景，Java 并发包提供了一个方便的方法，使用 CompletionService，这是一个接口，它的实现类是 ExecutorCompletionService。 2、与 ExecutorService 一样，CompletionService 也可以提交异步任务，它的不同是，它可以按任务完成顺序获取结果，其具体定义为：1234567public interface CompletionService&lt;V&gt; &#123; Future&lt;V&gt; submit(Callable&lt;V&gt; task); Future&lt;V&gt; submit(Runnable task, V result); Future&lt;V&gt; take() throws InterruptedException; Future&lt;V&gt; poll(); Future&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException;&#125; submit 方法与 ExecutorService 是一样的，多了 take 和 poll 方法，它们都是获取下一个完成任务的结果，take() 会阻塞等待，poll() 会立即返回，如果没有已完成的任务，返回 null，带时间参数的 poll 方法会最多等待限定的时间。 2、CompletionService 的主要实现类是 ExecutorCompletionService，它依赖于一个 Executor 完成实际的任务提交，而自己主要负责结果的排队和处理。它的构造方法有两个：12public ExecutorCompletionService(Executor executor)public ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) 至少需要一个 Executor 参数，可以提供一个 BlockingQueue 参数，用作完成任务的队列，没有提供的话，ExecutorCompletionService 内部会创建一个 LinkedBlockingQueue。 3、ExecutorCompletionService 是怎么让结果有序处理的呢？因为它有一个额外的队列，每个任务完成之后，都会将代表结果的 Future 入队。在 FutureTask 中，任务完成后，不管是正常完成、异常结束、还是被取消，都会调用 finishCompletion 方法，而该方法会调用一个 done 方法 protected void done() { } 该方法的实现为空，但它是一个 protected 方法，子类可以重写该方法。ExecutorCompletionService 的内部类 QueueingFuture 中重写了该方法。 在 ExecutorCompletionService 中，提交的任务类型不是一般的 FutureTask，而是一个子类 QueueingFuture123456789101112131415161718192021public Future&lt;V&gt; submit(Callable&lt;V&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;V&gt; f = newTaskFor(task); // 注意 QueueingFuture executor.execute(new QueueingFuture(f)); return f;&#125;----------------------------// ExecutorCompletionService 类中的私有实例变量private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;private class QueueingFuture extends FutureTask&lt;Void&gt; &#123; QueueingFuture(RunnableFuture&lt;V&gt; task) &#123; super(task, null); this.task = task; &#125; // 子类重写了 done 方法，在任务完成时将结果加入到完成队列中 protected void done() &#123; completionQueue.add(task); &#125; private final Future&lt;V&gt; task;&#125;--------------------------- 而 ExecutorCompletionService 的 take/poll 方法就是从该队列获取结果：123public Future&lt;V&gt; take() throws InterruptedException &#123; return completionQueue.take();&#125; 4、AbstractExecutorService 的 invokeAny 的实现，就利用了 ExecutorCompletionService，它的基本思路是，提交任务后，通过 take 方法获取结果，获取到第一个有效结果后，取消所有其他任务。 5、CompletionService 它通过一个额外的结果队列，方便了对于多个异步任务结果的处理。 参考博客Java编程的逻辑 - 方便的 CompletionService]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程总结(十三)]]></title>
    <url>%2F2018%2F08%2F27%2FJava-Java-Thread-2018-08-27-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十三) —— 线程池 1、Java 并发包中的任务执行服务的主要实现机制是线程池。线程池，顾名思义，就是一个线程的池子，里面有若干线程，它们的目的就是执行提交给线程池的任务，执行完一个任务后不会退出，而是继续等待或执行新任务。线程池主要由两个概念组成，一个是任务队列，另一个是工作者线程，工作者线程主体就是一个循环，循环从队列中接受任务并执行，任务队列保存待执行的任务。 线程池的优点： 它可以重用线程，避免线程创建的开销。 在任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争，确保任务有序完成。 Java 并发包中线程池的实现类是 ThreadPoolExecutor，它继承自 AbstractExecutorService，实现了 ExecutorService。 2、ThreadPoolExecutor 构造方法中的参数解析12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 线程池的大小主要与四个参数有关： corePoolSize：线程池中核心线程个数。不过，这并不是说，一开始就创建这么多线程，刚创建一个线程池后，实际上并不会创建任何线程。一般情况下，有新任务到来的时候，如果当前线程个数小于 corePoolSiz，就会创建一个新线程来执行该任务，需要说明的是，即使其他线程现在也是空闲的，也会创建新线程。不过，如果线程个数大于等于 corePoolSiz，那就不会立即创建新线程了，它会先尝试排队，需要强调的是，它是「尝试」排队，而不是「阻塞等待」入队，如果队列满了或其他原因不能立即入队，它就不会排队，而是检查线程个数是否达到了 maximumPoolSize，如果没有，就会继续创建线程，直到线程数达到 maximumPoolSize。 maximumPoolSize：线程池中允许的最大线程数。 keepAliveTime：当实际线程数大于核心线程数时，此为终止前，多余的空闲线程，等待新任务的最长时间。keepAliveTime 的目的是为了释放多余的线程资源，它表示，当线程池中的线程个数大于 corePoolSize 时，额外空闲线程的存活时间，也就是说，一个非核心线程，在空闲等待新任务时，会有一个最长等待时间，即 keepAliveTime，如果到了时间还是没有新任务，就会被终止。如果该值为 0，表示所有线程都不会超时终止。 unit：keepAliveTime 参数的时间单位。 3、队列之线程参数「BlockingQueue workQueue」ThreadPoolExecutor 要求的队列类型是阻塞队列 BlockingQueue： LinkedBlockingQueue：基于链表的阻塞队列，可以指定最大长度，但默认是无界的。 ArrayBlockingQueue：基于数组的有界阻塞队列。 PriorityBlockingQueue：基于堆的无界阻塞优先级队列。 SynchronousQueue：没有实际存储空间的同步阻塞队列。 如果用的是无界队列，需要强调的是，线程个数最多只能达到 corePoolSize，到达 corePoolSize 后，新的任务总会排队，参数 maximumPoolSize 也就没有意义了。 对于 SynchronousQueue，它没有实际存储元素的空间，当尝试排队时，只有正好有空闲线程在等待接受任务时，才会入队成功，否则，总是会创建新线程，直到达到 maximumPoolSize。 4、任务拒绝策略之线程参数「RejectedExecutionHandler handler」如果队列有界，且 maximumPoolSize 有限，则当队列排满，线程个数也达到了 maximumPoolSize，这时，新任务来了，就会触发线程池的任务拒绝策略。默认情况下，提交任务的方法如 execute/submit/invokeAll 等会抛出异常，类型为 RejectedExecutionException。拒绝策略是可以自定义的，ThreadPoolExecutor 实现了四种处理方式： ThreadPoolExecutor.AbortPolicy：这就是默认的方式，抛出异常。 ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛异常，也不执行。 ThreadPoolExecutor.DiscardOldestPolicy：将等待时间最长的任务扔掉，然后自己排队。 ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，而不是交给线程池中的线程执行。 它们都是 ThreadPoolExecutor 的 public 静态内部类，都实现了 RejectedExecutionHandler 接口，RejectedExecutionHandler 接口定义为：123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 当线程池不能接受任务时，调用其拒绝策略的 rejectedExecution 方法。 ThreadPoolExecutor 中的拒绝策略可以在构造方法中进行指定，也可以通过如下方法进行指定：public void setRejectedExecutionHandler(RejectedExecutionHandler handler)。 默认的 RejectedExecutionHandler 是一个 AbortPolicy 实例 private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 而 AbortPolicy 的 rejectedExecution 实现就是抛出异常。 拒绝策略只有在队列有界，且 maximumPoolSize 有限的情况下才会触发。 如果队列无界，服务不了的任务总是会排队，请求处理队列可能会消耗非常大的内存，甚至引发内存不够的异常。如果队列有界但 maximumPoolSize 无限，可能会创建过多的线程，占满 CPU 和内存，使得任何任务都难以完成。 在任务量非常大的场景中，让拒绝策略有机会执行是保证系统稳定运行很重要的方面。 5、线程工厂之线程参数「ThreadFactory threadFactory」线程池还可以接受一个参数 ThreadFactory，它是一个接口，定义为：123public interface ThreadFactory &#123; Thread newThread(Runnable r);&#125; ThreadFactory 接口根据 Runnable 创建一个 Thread，ThreadPoolExecutor 的默认实现是 Executors 类中的静态内部类 DefaultThreadFactory，主要就是创建一个线程，给线程设置一个名称，设置 daemon 属性为 false，设置线程优先级为标准默认优先级，线程名称的格式为： pool-&lt;线程池编号&gt;-thread-&lt;线程编号&gt;。 6、关于核心线程的特殊配置线程个数小于等于 corePoolSize 时，我们称这些线程为核心线程，默认情况下： 核心线程不会预先创建，只有当有任务时才会创建。 核心线程不会因为空闲而被终止，keepAliveTime参数不适用于它。 ThreadPoolExecutor 有如下方法，可以改变这个默认行为：123456// 预先创建所有的核心线程public int prestartAllCoreThreads()// 创建一个核心线程，如果所有核心线程都已创建，返回 falsepublic boolean prestartCoreThread()// 如果参数为 true，则 keepAliveTime 参数也适用于核心线程public void allowCoreThreadTimeOut(boolean value) 7、工厂类 Executors类 Executors 提供了一些静态工厂方法，可以方便的创建一些预配置的线程池，主要方法有：12345678910111213141516171819202122// newSingleThreadExecutor 只使用一个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止，该线程顺序执行所有任务。该线程池适用于需要确保所有任务被顺序执行的场合public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;----------------------------------------------------------------------// newFixedThreadPool 使用固定数目的 n 个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止。和 newSingleThreadExecutor 一样，由于是无界队列，如果排队任务过多，可能会消耗非常大的内存public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;---------------------------------------------------------------------// newCachedThreadPool 的 corePoolSize 为 0，maximumPoolSize 为 Integer.MAX_VALUE，keepAliveTime 是 60 秒，队列为 SynchronousQueue// 当新任务到来时，如果正好有空闲线程在等待任务，则其中一个空闲线程接受该任务，否则就总是创建一个新线程，创建的总线程个数不受限制，对任一空闲线程，如果60秒内没有新任务，就终止public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 实际中，应该使用 newFixedThreadPool 还是 newCachedThreadPool 呢？在系统负载很高的情况下，newFixedThreadPool 可以通过队列使新任务排队，保证有足够的资源处理实际的任务，而 newCachedThreadPool 会为每个任务创建一个线程，导致创建过多的线程竞争 CPU 和内存资源，使得任何实际任务都难以完成，这时，newFixedThreadPool 更为适用。 如果系统负载不太高，单个任务的执行时间也比较短，newCachedThreadPool 的效率可能更高，因为任务可以不经排队，直接交给某一个空闲线程。 在系统负载可能极高的情况下，两者都不是好的选择，newFixedThreadPool 的问题是队列过长，而 newCachedThreadPool 的问题是线程过多，这时，应根据具体情况自定义 ThreadPoolExecutor，传递合适的参数。 8、线程的死锁关于提交给线程池的任务，需要特别注意一种情况，就是任务之间有依赖，这种情况可能会出现死锁。对于相互依赖的任务，需要特别注意，避免出现死锁。 避免死锁的策略： 替换 newFixedThreadPool 为 newCachedThreadPool，让创建线程不再受限。 使用 SynchronousQueue，它可以避免死锁。因为对于普通队列，入队只是把任务放到了队列中，而对于 SynchronousQueue 来说，入队成功就意味着已有线程接受处理，如果入队失败，可以创建更多线程直到 maximumPoolSize，如果达到了 maximumPoolSize，会触发拒绝机制，不管怎么样，都不会死锁。 9、ThreadPoolExecutor 实现了生产者/消费者模式，工作者线程就是消费者，任务提交者就是生产者，线程池自己维护任务队列。当我们碰到类似生产者/消费者问题时，应该优先考虑直接使用线程池，而非重新发明轮子，自己管理和维护消费者线程及任务队列。 10、小结：ThreadPoolExecutor 参数 corePoolSize, maximumPoolSize, keepAliveTime, unit 用于控制线程池中线程的个数，workQueue 表示任务队列，threadFactory 用于对创建的线程进行一些配置，handler 表示任务拒绝策略。 参考博客Java编程的逻辑 - 线程池]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十二)]]></title>
    <url>%2F2018%2F08%2F26%2FJava-Java-Thread-2018-08-26-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十二) —— 异步任务执行服务 1、Java 并发包提供了一套框架，大大简化了执行异步任务所需的开发。在之前的学习中，线程 Thread 既表示要执行的任务，又表示执行的机制，而这套框架引入了一个「执行服务」的概念，它将「任务的提交」和「任务的执行」相分离，「执行服务」封装了任务执行的细节，对于任务提交者而言，它可以关注于任务本身，如提交任务、获取结果、取消任务，而不需要关注任务执行的细节，如线程创建、任务调度、线程关闭等。 2、任务执行服务涉及的基本接口： Runnable 和 Callable：表示要执行的异步任务。 Executor 和 ExecutorService：表示执行服务。 Future：表示异步任务的结果。 Runnable 和 Callable 都表示任务，Runnable 没有返回结果，而 Callable 有，Runnable 不会抛出异常，而 Callable 会。 Executor 表示最简单的执行服务，其定义为：123public interface Executor &#123; void execute(Runnable command);&#125; 在未来某个时间执行给定的任务 Runnable，没有返回结果。该任务可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。 ExecutorService 扩展了 Executor，定义了更多服务，基本方法有：12345678910111213141516171819202122232425262728293031323334353637public interface ExecutorService extends Executor &#123; // 这三个 submit 都表示提交一个任务，返回值类型都是 Future，返回后，只是表示任务已提交，不代表已执行，通过 Future 可以查询异步任务的状态、获取最终结果、取消任务等 // 对于 Callable，任务最终有个返回值，而对于 Runnable 是没有返回值的 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); // 提交 Runnable 的方法可以同时提供一个结果，在异步任务结束时返回 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); // 异步任务的最终返回值为 null Future&lt;?&gt; submit(Runnable task); // shutdown 和 shutdownNow 表示关闭任务执行服务 // shutdown 表示不再接受新任务，但已提交的任务会继续执行，即使任务还未开始执行 void shutdown(); // shutdownNow 不仅不接受新任务，已提交但尚未执行的任务会被终止，对于正在执行的任务，一般会调用线程的 interrupt 方法尝试中断，不过，线程可能不响应中断，shutdownNow 会返回已提交但尚未执行的任务列表 List&lt;Runnable&gt; shutdownNow(); // shutdown 和 shutdownNow 不会阻塞等待，它们返回后不代表所有任务都已结束，不过 isShutdown 方法会返回 true boolean isShutdown(); boolean isTerminated(); // 调用者可以通过 awaitTermination 等待所有任务结束，它可以限定等待的时间，如果超时前所有任务都结束了，即 isTerminated 方法返回 true，则返回 true，否则返回 false boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; // ExecutorService 有两组批量提交任务的方法，invokeAll 和 invokeAny，它们都有两个版本，其中一个限定等待时间 // invokeAll 等待所有任务完成，返回的 Future 列表中，每个 Future 的 isDone 方法都返回 true，不过 isDone 为 true 不代表任务就执行成功了，可能是被取消了，invokeAll 可以指定等待时间，如果超时后有的任务没完成，就会被取消 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; // invokeAny 只要有一个任务在限时内成功返回了，它就会返回该任务的结果，其他任务会被取消，如果没有任务能在限时内成功返回，抛出 TimeoutException，如果限时内所有任务都结束了，但都发生了异常，抛出 ExecutionException &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 使用 ExecutorService 编写并发异步任务的代码就像写顺序程序一样，不用关心线程的创建和协调，只需要提交任务、处理结果就可以了，大大简化了开发工作。 3、Future 接口1234567891011121314151617181920// Future 表示异步计算的结果public interface Future&lt;V&gt; &#123; // cancel 用于取消异步任务，如果任务已完成、或已经取消、或由于某种原因不能取消，cancel 返回 false，否则返回 true // 如果任务还未开始或已经结束，则不再运行 // 如果任务已经在运行，则不一定能取消，参数 mayInterruptIfRunning 表示，如果任务正在执行，是否调用 interrupt 方法中断线程，如果为 false 就不会，如果为 true，就会尝试中断线程，interrupt() 不一定能取消线程 boolean cancel(boolean mayInterruptIfRunning); // isDone 和 isCancelled 用于查询任务状态 // isCancelled 表示任务是否被取消，只要 cancel 方法返回了 true，随后的 isCancelled 方法都会返回 true，即使执行任务的线程还未真正结束 boolean isCancelled(); // isDone 表示任务是否结束，不管什么原因都算，可能是任务正常结束、可能是任务抛出了异常、也可能是任务被取消 boolean isDone(); // get 用于返回异步任务最终的结果，如果任务还未执行完成，会阻塞等待 V get() throws InterruptedException, ExecutionException; // 可以限定阻塞等待的时间，如果超时任务还未结束，会抛出 TimeoutException V get(long timeout, TimeUnit unit) throws InterruptedException,ExecutionException, TimeoutException;&#125; get() 方法，任务最终大概有三个结果： 正常完成，get 方法会返回其执行结果，如果任务是 Runnable 且没有提供结果，返回 null。 任务执行抛出了异常，get 方法会将异常包装为 ExecutionException 重新抛出，通过异常的 getCause 方法可以获取原异常。 任务被取消了，get 方法会抛出异常 CancellationException。 如果调用 get 方法的线程被中断了，get 方法会抛出 InterruptedException。 Future 是一个重要的概念，是实现「任务的提交」与「任务的执行」相分离的关键，是其中的纽带，任务提交者和任务执行服务通过它隔离各自的关注点，同时进行协作。 4、ExecutorService 的主要实现类是 ThreadPoolExecutor，它是基于线程池实现的。ExecutorService 有一个抽象实现类 AbstractExecutorService，接下来简要分析下 AbstractExecutorService 的原理。12345678910111213141516// AbstractExecutorService 提供了 submit、invokeAll、invokeAny 的默认实现，子类只需要实现如下方法即可public abstract class AbstractExecutorService implements ExecutorService &#123; // 除了 execute 方法，其他方法都与执行服务的生命周期管理有关 public void shutdown() public List&lt;Runnable&gt; shutdownNow() public boolean isShutdown() public boolean isTerminated() public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException // submit/invokeAll/invokeAny 最终都会调用 execute，execute 决定了到底如何执行任务 public void execute(Runnable command)&#125; 5、AbstractExecutorService 抽象类中 submit() 方法源码解析12345678910111213141516171819202122232425public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); // 调用 newTaskFor 生成了一个 RunnableFuture，RunnableFuture 是一个接口，既扩展了 Runnable，又扩展了 Future，没有定义新方法 // 作为 Runnable，它表示要执行的任务，传递给 execute 方法进行执行 // 作为 Future，它又表示任务执行的异步结果 RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;----------------------protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; // 就是创建了一个 FutureTask 对象，FutureTask 实现了 RunnableFuture 接口 return new FutureTask&lt;T&gt;(runnable, value);&#125;----------------------public FutureTask(Runnable runnable, V result) &#123; // 如果 FutureTask 接受的是一个 Runnable 对象，它会调用 Executors.callable 转换为 Callable 对象 this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;---------------------// RunnableFuture 接口定义public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; 6、FutureTask 源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Future 的主要实现类是 FutureTaskpublic class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; // 表示状态，可取值如下 private volatile int state; private static final int NEW = 0;// 刚开始的状态，或任务在运行 private static final int COMPLETING = 1;// 临时状态，任务即将结束，在设置结果 private static final int NORMAL = 2;// 任务正常执行完成 private static final int EXCEPTIONAL = 3;// 任务执行抛出异常结束 private static final int CANCELLED = 4;// 任务被取消 private static final int INTERRUPTING = 5;// 任务在被中断 private static final int INTERRUPTED = 6;// 任务被中断 // 表示待执行的任务 private Callable&lt;V&gt; callable; // 表示最终的执行结果或异常 private Object outcome; // non-volatile, protected by state reads/writes // 表示运行任务的线程 private volatile Thread runner; // 单向链表表示等待任务执行结果的线程 private volatile WaitNode waiters; // FutureTask 的构造方法会初始化 callable 和状态，如果 FutureTask 接受的是一个 Runnable 对象，它会调用 Executors.callable 转换为 Callable 对象 public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable &#125; // 任务执行服务会使用一个线程执行 FutureTask 的 run 方法 public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125;&#125; FutureTask 的 run() 方法的基本逻辑为： 调用 callable 的 call 方法，捕获任何异常。 如果正常执行完成，调用 set 设置结果，保存到 outcome。 如果执行过程发生异常，调用 setException 设置异常，异常也是保存到 outcome，但状态不一样。 set 和 setException 除了设置结果，修改状态外，还会调用 finishCompletion ，它会唤醒所有等待结果的线程。 7、FutureTask 中 get() 方法源码解析123456789101112131415161718192021public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; if (unit == null) throw new NullPointerException(); int s = state; // 如果任务还未执行完毕，就等待 if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); // 最后调用 report 报告结果, report 根据状态返回结果或抛出异常 return report(s);&#125;-----------------------------------private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x);&#125; 8、FutureTask 中 cancel() 方法源码解析123456789101112131415161718192021222324public boolean cancel(boolean mayInterruptIfRunning) &#123; // 如果任务已结束或取消，返回 false // 如果 mayInterruptIfRunning 为 false，设置状态为 CANCELLED if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; // in case call to interrupt throws exception // 如果 mayInterruptIfRunning 为 true，调用 interrupt 中断线程，设置状态为 INTERRUPTED if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) t.interrupt(); &#125; finally &#123; // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); &#125; &#125; &#125; finally &#123; // 调用 finishCompletion 唤醒所有等待结果的线程 finishCompletion(); &#125; return true;&#125; 9、Java 并发包中任务执行服务的基本概念和原理，该服务体现了并发异步开发中「关注点分离」的思想，使用者只需要通过 ExecutorService 提交任务，通过 Future 操作任务和结果即可，不需要关注线程创建和协调的细节。 参考博客Java编程的逻辑 - 异步任务执行服务]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十一)]]></title>
    <url>%2F2018%2F08%2F26%2FJava-Java-Thread-2018-08-26-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十一) —— 各种队列]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器总结(四)]]></title>
    <url>%2F2018%2F08%2F25%2FJava-Java-Container-2018-08-26-Java%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Java 容器总结(四) —— HashSet 1、HashSet 由两个单词组成，Hash 和 Set，Set 表示接口，实现 Set 接口有多种方式，HashSet 实现的方式利用了 Hash。Set 表示的是没有重复元素、且不保证顺序的容器接口，它扩展了 Collection，但没有定义任何新的方法，不过，对于其中的一些方法，它有自己的规范。 2、Set 接口定义123456789101112131415161718192021public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); // 迭代遍历时，不要求元素之间有特别的顺序 // HashSet 的实现就是没有顺序，但有的 Set 实现可能会有特定的顺序，比如 TreeSet Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); // 如果集合中已经存在相同元素了，则不会改变集合，直接返回 false，只有不存在时，才会添加，并返回 true boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); // 重复的元素不添加，不重复的添加，如果集合有变化，返回 true，没变化返回 false boolean addAll(Collection&lt;? extends E&gt; c); boolean retainAll(Collection&lt;?&gt; c); boolean removeAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode();&#125; 3、注意：HashSet 要求元素重写 hashCode 和 equals 方法，且对两个对象，equals 相同，则 hashCode 也必须相同，如果元素是自定义的类，需要注意这一点。因为 HashSet 就是依靠 hashCode 和 equals 方法来判断对象是否相等的，所以使用 HashSet 的时候一定要注意重写这两个方法。 4、HashSet 内部组成1234567public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; // HashSet 内部是用 HashMap 实现的，它内部有一个 HashMap 实例变量 private transient HashMap&lt;E,Object&gt; map; // HashSet 相当于只有键，值都是相同的固定值 PRESENT private static final Object PRESENT = new Object();&#125; 5、HashSet 的构造方法，主要就是调用了对应的 HashMap 的构造方法。 6、add() 方法源码解析1234public boolean add(E e) &#123; // 返回值为 boolean 类型 return map.put(e, PRESENT)==null;&#125; 就是调用 map 的 put 方法，元素 e 用于键，值就是那个固定值 PRESENT，put 返回 null 表示原来没有对应的键，添加成功了。HashMap 中一个键只会保存一份，所以重复添加 HashMap 不会变化。 7、remove() 方法源码解析1234// 调用 map 的 remove 方法，返回值为 PRESENT 表示原来有对应的键且删除成功了public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 8、迭代器1234// 返回 map 的 keySet 的迭代器public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; 9、HashSet 特点分析HashSet 实现了 Set 接口，内部是通过 HashMap 实现的，这决定了它有如下特点： 没有重复元素。 可以高效的添加、删除元素、判断元素是否存在，效率都为 O(1)。 没有顺序。 10、HashSet 实现了 Set 接口，不含重复元素，内部实现利用了 HashMap，可以方便高效地实现如去重、集合运算等功能。HashSet 没有顺序，如果要保持添加的顺序，可以使用 HashSet 的一个子类 LinkedHashSet。 参考博客Java编程的逻辑 - 剖析 HashSet]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(十)]]></title>
    <url>%2F2018%2F08%2F24%2FJava-Java-Thread-2018-08-24-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[Java 线程总结(十) —— 基于 SkipList 的 Map 和 Set]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(九)]]></title>
    <url>%2F2018%2F08%2F24%2FJava-Java-Thread-2018-08-24-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[Java 线程总结(九) —— ConcurrentHashMap 1、ConcurrentHashMap，它是 HashMap 的并发版本，与 HashMap 相比，它有如下特点： 并发安全。 直接支持一些原子复合操作。 支持高并发、读操作完全并行、写操作支持一定程度的并行。 与同步容器 Collections.synchronizedMap 相比，迭代不用加锁，不会抛出 ConcurrentModificationException。 弱一致性。 2、HashMap 不是并发安全的，在并发更新的情况下，HashMap 的链表结构可能形成环，出现死循环，占满 CPU。死循环出现在多个线程同时扩容哈希表的时候，不是同时更新一个链表的时候，那种情况可能会出现更新丢失，但不会死循环。具体参考 Java HashMap 的死循环。 使用 Collections.synchronizedMap 方法可以生成一个同步容器，可以避免该问题。在 Java 中，HashMap 还有一个同步版本 Hashtable，它与使用 synchronizedMap 生成的 Map 基本是一样的，也是在每个方法调用上加了 synchronized。然而同步容器存在以下问题： 每个方法都需要同步，支持的并发度比较低。 对于迭代和复合操作，需要调用方加锁，使用比较麻烦，且容易忘记。 3、ConcurrentHashMap 没有以上那些问题，它同样实现了 Map 接口，也是基于哈希表实现的。除了 Map 接口，ConcurrentHashMap 还实现了一个接口 ConcurrentMap，接口定义了一些条件更新操作。12345678910public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; // 条件更新，如果 Map 中没有 key，设置 key 的值为 value，返回原来 key 对应的值，如果没有，返回 null V putIfAbsent(K key, V value); // 条件删除，如果 Map 中有 key，且对应的值为 value，则删除，如果删除了，返回 true，否则 false boolean remove(Object key, Object value); // 条件替换，如果 Map 中有 key，且对应的值为 oldValue，则替换为 newValue，如果替换了，返回 ture，否则 false boolean replace(K key, V oldValue, V newValue); // 条件替换，如果 Map 中有 key，则替换值为 value，返回原来 key 对应的值，如果原来没有，返回 null V replace(K key, V value);&#125; 如果使用同步容器，调用方必须加锁，而 ConcurrentMap 将它们实现为了原子操作。实际上，使用 ConcurrentMap，调用方也没有办法进行加锁，它没有暴露锁接口，也不使用 synchronized。 4、ConcurrentHashMap 是为高并发设计的，其主要思路有两点： 分段锁 读不需要锁 同步容器使用 synchronized，所有方法，竞争同一个锁，而 ConcurrentHashMap 采用分段锁技术，将数据分为多个段，而每个段有一个独立的锁，每一个段相当于一个独立的哈希表，分段的依据也是哈希值，无论是保存键值对还是根据键查找，都先根据键的哈希值映射到段，再在段对应的哈希表上进行操作。 采用分段锁，可以大大提高并发度，多个段之间可以并行读写。默认情况下，段是 16个，不过，这个数字可以通过构造方法进行设置:public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)concurrencyLevel 表示估计的并行更新的线程个数，ConcurrentHashMap 会将该数转换为2的整数次幂，比如 14 转换为 16，25 转换为 32。 在对每个段的数据进行读写时，ConcurrentHashMap 也不是简单的使用锁进行同步，内部使用了 CAS、对一些写采用原子方式，实现比较复杂，实现的效果是，对于写操作，需要获取锁，不能并行，但是读操作可以，多个读可以并行，写的同时也可以读，这使得 ConcurrentHashMap 的并行度远远大于同步容器。 5、使用同步容器，在迭代中需要加锁，否则可能会抛出 ConcurrentModificationException。ConcurrentHashMap 没有这个问题，在迭代器创建后，在迭代过程中，如果另一个线程对容器进行了修改，迭代会继续，不会抛出异常。 但是迭代器是否会反映别的线程的修改，就需要视情况而定了。这是因为 ConcurrentHashMap 的弱一致性。类似的情况还会出现在 ConcurrentHashMap 的另一个方法：public void putAll(Map&lt;? extends K, ? extends V&gt; m) 该方法并非原子操作，而是调用 put 方法逐个元素进行添加的，在该方法没有结束的时候，部分修改效果就会体现出来。 6、ConcurrentHashMap 的弱一致性ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。 7、ConcurrentHashMap 通过分段锁、CAS 等技术实现了高并发；实现了 ConcurrentMap 接口，支持原子条件更新操作；不会抛出 ConcurrentModificationException，实现了弱一致性。 8、Java 中没有并发版的 HashSet，但可以通过 Collections.newSetFromMap 方法基于 ConcurrentHashMap 构建一个。HashMap/HashSet 基于哈希，不能对元素排序，对应的可排序的容器类是 TreeMap/TreeSet，并发包中可排序的对应版本不是基于树，而是基于 Skip List（跳跃表）的，类分别是 ConcurrentSkipListMap 和 ConcurrentSkipListSet。 参考博客Java编程的逻辑 - ConcurrentHashMap]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(八)]]></title>
    <url>%2F2018%2F08%2F24%2FJava-Java-Thread-2018-08-24-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[Java 线程总结(八) —— 写时拷贝的 List 和 Set 1、Java 并发包中的容器类。注意这个是并发容器，要跟 Collections 返回的同步容器区分开。这里主要学习 CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个类，Copy-On-Write，即写时拷贝或写时复制，这是解决并发问题的一种重要思路。 2、CopyOnWriteArrayList 基本用法CopyOnWriteArrayList 实现了 List 接口，它的用法与其他 List 如 ArrayList 基本是一样的，它的区别是： 它是线程安全的，可以被多个线程并发访问。 它的迭代器不支持修改操作，但也不会抛出 ConcurrentModificationException。 它直接以原子方式支持一些复合操作。 3、基于 synchronized 的同步容器迭代时，需要对整个列表对象加锁，否则会抛出 ConcurrentModificationException。但 CopyOnWriteArrayList 没有这个问题，迭代时不需要加锁。因为 CopyOnWriteArrayList 的迭代器根本不支持修改，这也是 CopyOnWriteArrayList 思想的本质，写时拷贝，CopyOnWriteArrayList 有点像 String，一旦创建，内容不可变，变的只是引用。 在 JDK 1.8 之前的实现中，CopyOnWriteArrayList 的迭代器不支持修改操作，也不支持一些依赖迭代器修改方法的操作，比如 Collections 的 sort 方法，因为 Collections.sort 方法依赖迭代器的 set 方法。但是在 JDK 1.8 中，List 接口增加了 sort 方法，并提供了默认实现，而 CopyOnWriteArrayList 重写了该实现，从以下其源码可以看出，加锁了。12345678910111213public void sort(Comparator&lt;? super E&gt; c) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); Object[] newElements = Arrays.copyOf(elements, elements.length); @SuppressWarnings("unchecked") E[] es = (E[])newElements; Arrays.sort(es, c); setArray(newElements); &#125; finally &#123; lock.unlock(); &#125;&#125; 基于 synchronized 的同步容器的一个问题是复合操作，比如先检查再更新，也需要调用方加锁，而 CopyOnWriteArrayList 直接支持两个原子方法，其本质都是加锁了。1234// 不存在才添加，如果添加了，返回 true，否则返回 falsepublic boolean addIfAbsent(E e)// 批量添加 c 中的非重复元素，不存在才添加，返回实际添加的个数public int addAllAbsent(Collection&lt;? extends E&gt; c) 4、CopyOnWriteArrayList 的基本原理CopyOnWriteArrayList 的内部也是一个数组，但这个数组是以原子方式被整体更新的。每次修改操作，都会新建一个数组，复制原数组的内容到新数组，在新数组上进行需要的修改，然后以原子方式设置内部的数组引用，这就是写时拷贝。 所有的读操作，都是先拿到当前引用的数组，然后直接访问该数组，在读的过程中，可能内部的数组引用已经被修改了，但不会影响读操作，它依旧访问原数组内容。即数组内容是只读的，写操作都是通过新建数组，然后原子性的修改数组引用来实现的。 123456789101112131415161718public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; // 内部数组，注意，它声明为了 volatile，这是必需的，保证内存可见性，写操作更改了之后，读操作能看到。 private transient volatile Object[] array; final transient ReentrantLock lock = new ReentrantLock(); final Object[] getArray() &#123; return array; &#125; final void setArray(Object[] a) &#123; array = a; &#125; // 默认构造方法 public CopyOnWriteArrayList() &#123; setArray(new Object[0]); &#125; &#125; 在 CopyOnWriteArrayList 中，读不需要锁，可以并行，读和写也可以并行，但多个线程不能同时写，每个写操作都需要先获取锁，CopyOnWriteArrayList 内部使用 ReentrantLock。 5、add() 方法源码解析1234567891011121314151617public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获取原数组 Object[] elements = getArray(); int len = elements.length; // 拷贝到一个新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; // 调用 setArray 原子性的修改内部数组引用 setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 解析为什么 add() 方法需要加锁？内部数组 array 是被 volatile 关键字修饰的，其内存可见性是不存在问题的，但是却存在另一个问题 —— 竞态条件，所以通过加锁来解决并发写时的竞态条件问题。此处加锁的目的就是为了解决竞态条件问题。 6、indexOf() 方法源码解析12345678910111213141516171819public int indexOf(Object o) &#123; Object[] elements = getArray(); return indexOf(o, elements, 0, elements.length);&#125;-----------------------------// 这个 indexOf 方法访问的所有数据都是通过参数传递进来的，数组内容也不会被修改，不存在并发问题private static int indexOf(Object o, Object[] elements, int index, int fence) &#123; if (o == null) &#123; for (int i = index; i &lt; fence; i++) if (elements[i] == null) return i; &#125; else &#123; for (int i = index; i &lt; fence; i++) if (o.equals(elements[i])) return i; &#125; return -1;&#125; 7、iterator() 迭代器方法源码解析1234567891011121314151617public Iterator&lt;E&gt; iterator() &#123; // COWIterator 是内部类，传递给它的是不变的数组，它也只是读该数组，不支持修改 return new COWIterator&lt;E&gt;(getArray(), 0);&#125;-------------------static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; /** Snapshot of the array */ // final 修饰，表明数组的引用不可变，而写时拷贝的特性，表明数组一旦被创建其内容不会再变，所以该数组是不可变的 private final Object[] snapshot; /** Index of element to be returned by subsequent call to next. */ private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125;&#125; 8、CopyOnWriteArrayList 小结每次修改都创建一个新数组，然后复制所有内容，如果数组比较大，修改操作又比较频繁，CopyOnWriteArrayList 的性能是很低的。CopyOnWriteArrayList 不适用于数组很大，且修改频繁的场景。它是以优化读操作为目标的，读不需要同步，性能很高，但在优化读的同时就牺牲了写的性能。 保证线程安全的两种思路，一种是锁，使用 synchronized 或 ReentrantLock，另外一种是循环 CAS，写时拷贝体现了保证线程安全的另一种思路。对于绝大部分访问都是读，且有大量并发线程要求读，只有个别线程进行写，且只是偶尔写的场合，这种写时拷贝就是一种很好的解决方案。 写时拷贝是一种重要的思维，用于各种计算机程序中，比如经常用于操作系统内部的进程管理和内存管理。 9、CopyOnWriteArraySet 实现了 Set 接口，不包含重复元素，内部，它是通过 CopyOnWriteArrayList 实现的。1234567891011121314public class CopyOnWriteArraySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements java.io.Serializable &#123; // 内部实现依赖 CopyOnWriteArrayList private final CopyOnWriteArrayList&lt;E&gt; al; public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;(); &#125; // 调用了 CopyOnWriteArrayList 的 addIfAbsent 方法 public boolean add(E e) &#123; return al.addIfAbsent(e); &#125; &#125; 由于 CopyOnWriteArraySet 是基于 CopyOnWriteArrayList 实现的，所以与 Set 的实现类如 HashSet/TreeSet 相比，它的性能比较低，不适用于元素个数特别多的集合。如果元素个数比较多，可以考虑 ConcurrentHashMap 或 ConcurrentSkipListSet。 ConcurrentHashMap 与 HashMap 类似，适用于不要求排序的场景，ConcurrentSkipListSet 与 TreeSet 类似，适用于要求排序的场景。Java 并发包中没有与 HashSet 对应的并发容器，但可以很容易的基于 ConcurrentHashMap 构建一个，利用 Collections.newSetFromMap 方法即可。 参考博客Java 编程的逻辑 - 写时拷贝的 List 和 Set]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(七)]]></title>
    <url>%2F2018%2F08%2F23%2FJava-Java-Thread-2018-08-23-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[Java 线程总结(七) —— 显式条件 1、显式条件也可以被称做条件变量、条件队列、或条件。锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与 synchronzied 相对应，而显式条件与 wait/notify 相对应。wait/notify 与 synchronized 配合使用，显式条件与显式锁配合使用。条件与锁相关联，创建条件变量需要通过显式锁，Lock 接口定义了创建方法：Condition newCondition();。 2、Condition 接口表示条件变量123456789101112public interface Condition &#123; void await() throws InterruptedException; void awaitUninterruptibly(); // 等待时间也是相对时间，但参数单位是纳秒，返回值是 nanosTimeout 减去实际等待的时间，即剩余未用的等待时间 long awaitNanos(long nanosTimeout) throws InterruptedException; // 等待时间是相对时间，如果由于等待超时返回，返回值为 false，否则为 true boolean await(long time, TimeUnit unit) throws InterruptedException; // 等待时间是绝对时间，如果由于等待超时返回，返回值为 false，否则为 true boolean awaitUntil(Date deadline) throws InterruptedException; void signal(); void signalAll();&#125; 除 awaitUninterruptibly() 之外，await 方法都是响应中断的，如果发生了中断，会抛出 InterruptedException，但中断标志位会被清空。awaitUninterruptibly() 方法不会由于中断结束，但当它返回时，如果等待过程中发生了中断，中断标志位会被设置。 3、一般而言，与 Object 的 wait 方法一样，调用 await 方法前需要先获取锁，如果没有锁，会抛出异常 IllegalMonitorStateException。await 在进入等待队列后，会释放锁，释放 CPU，当其他线程将它唤醒后，或等待超时后，或发生中断异常后，它都需要重新获取锁，获取锁后，才会从 await 方法中退出。 另外，与 Object 的 wait 方法一样，await 返回后，不代表其等待的条件就一定满足了，通常要将 await 的调用放到一个循环内，只有条件满足后才退出。 一般而言，signal/signalAll 与 notify/notifyAll 一样，调用它们需要先获取锁，如果没有锁，会抛出异常 IllegalMonitorStateException。signal 与 notify 一样，挑选一个线程进行唤醒，signalAll 与 notifyAll 一样，唤醒所有等待的线程，但这些线程被唤醒后都需要重新竞争锁，获取锁后才会从 await 调用中返回。 4、显式条件与显式锁配合，wait/notify 与 synchronized 配合。 5、显示条件的实现原理1234567891011121314151617// ReentrantLock 类中的 newCondition 方法public Condition newCondition() &#123; return sync.newCondition();&#125;-------------------------// ReentrantLock 内部类 Sync 中的 newCondition 方法final ConditionObject newCondition() &#123; // ConditionObject 是 AQS 中定义的一个内部类 return new ConditionObject();&#125;-------------------------public class ConditionObject implements Condition, java.io.Serializable &#123; // 条件队列的头节点 private transient Node firstWaiter; // 条件队列的尾节点 private transient Node lastWaiter;&#125; ConditionObject 内部也有一个队列，表示条件等待队列。ConditionObject 是 AQS 的成员内部类，它可以直接访问 AQS 中的数据，比如 AQS 中定义的锁等待队列。 6、await 方法源码解析1234567891011121314151617181920212223242526public final void await() throws InterruptedException &#123; // 如果等待前中断标志位已被设置，直接抛异常 if (Thread.interrupted()) throw new InterruptedException(); // 1.为当前线程创建节点，加入条件等待队列 Node node = addConditionWaiter(); // 2.释放持有的锁 int savedState = fullyRelease(node); int interruptMode = 0; // 3.放弃CPU，进行等待，直到被中断或 isOnSyncQueue 变为 true // isOnSyncQueue 为 true 表示节点被其他线程从条件等待队列 // 移到了外部的锁等待队列,等待的条件已满足 while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; // 4.重新获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); // 5.处理中断，抛出异常或设置中断标志位 if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 7、signal 方法源码解析1234567public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125; doSignal 的代码就不列举了，其基本逻辑是：将节点从条件等待队列移到锁等待队列；调用 LockSupport.unpark 将线程唤醒。 8、总结：显示条件的本质就是一个队列，该队列提供了两个系列的方法，await 系列的方法用于条件不满足时将线程对象加入队列，signal 系列方法用于条件满足时从队列中释放线程对象。实际业务可以根据具体的条件是否满足来决定当前线程对象是加入队列等待，还是从队列中释放执行。 参考博客Java编程的逻辑 - 显式条件]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(三)]]></title>
    <url>%2F2018%2F08%2F23%2FJava-Java-Container-2018-08-23-Java%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Java 容器总结(三) —— HashMap 1、ArrayList 和 LinkedList，它们的一个共同特点是，查找元素的效率都比较低，都需要逐个进行比较，而 HashMap 它的查找效率则要高的多。Map 表示映射关系，实现 Map 接口有多种方式，HashMap 实现的方式利用了 Hash。 2、Map 接口Map 按照键存储和访问值，键不能重复，即一个键只会存储一份，给同一个键重复设值会覆盖原来的值。使用 Map 可以方便地处理需要根据键访问对象的场景。数组、ArrayList、LinkedList 可以视为一种特殊的 Map，键为索引，值为对象。1234567891011121314151617181920212223public interface Map&lt;K,V&gt; &#123; V put(K key, V value); V get(Object key); V remove(Object key); int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); interface Entry&lt;K,V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); &#125; boolean equals(Object o); int hashCode();&#125; Map 接口有两个类型参数，K 和 V，分别表示键 (Key) 和值 (Value) 的类型。在 HashMap 中，key 相同的依据是，要么都为 null，要么 equals 方法返回 true。Map.Entry 是一个嵌套接口，定义在 Map 接口内部，表示一条键值对。 注意：keySet()/values()/entrySet() 有一个共同的特点，它们返回的都是视图，不是拷贝的值，基于返回值的修改会直接修改 Map 自身。 Set 是一个接口，表示的是数学中的集合概念，即没有重复的元素集合。它扩展了 Collection，但没有定义任何新的方法，不过，它要求所有实现者都必须确保 Set 的语义约束，即不能有重复元素。Map 中的键是没有重复的，所以 ketSet() 返回了一个 Set。 3、HashMap 主要围绕以下几个变量来实现的，几乎所有的操作都是在操作以下几个变量：12345678// table 是一个 Node (单向链表) 类型的数组，数组中的每个元素都是一个单向链表，链表中的每个节点表示一个键值对，Node 是一个内部类transient Node&lt;K,V&gt;[] table;// size 表示实际键值对的个数transient int size;// 扩容的阈值int threshold;// loadFactor 是负载因子，表示整体上 table 被占用的程度，是一个浮点数，默认为 0.75，可以通过构造方法进行修改final float loadFactor; 4、HashMap 内部组成12345678910111213141516171819202122232425262728293031public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // table 是一个 Node 类型的数组，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对，Node 是一个内部类 transient Node&lt;K,V&gt;[] table; // size 表示实际键值对的个数 transient int size; int threshold; final float loadFactor; // 静态内部类，实现了 Map.Entry 接口 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // hash 是 key 的哈希值，直接存储 hash 值是为了在比较的时候加快计算 final int hash; final K key; V value; // next 指向下一个 Node 节点，即链表元素的下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; // 直接存储 hash 值是为了在比较的时候加快计算 this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; &#125;&#125; table 默认为 null，当添加键值对后，table 就不是空表了，它会随着键值对的添加进行扩展，扩展的策略类似于 ArrayList，添加第一个元素时，默认分配的大小为 16，不过，并不是 size 大于 16 时再进行扩展，下次什么时候扩展与 threshold 有关。threshold 表示阈值，当键值对个数 size 大于等于 threshold 时考虑进行扩展。一般而言，threshold 等于 table.length 乘以 loadFactor。loadFactor 是负载因子，表示整体上 table 被占用的程度，是一个浮点数，默认为 0.75，可以通过构造方法进行修改。 5、put(K key, V value) 方法源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 调用 HashMap 的 put() 方法public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;-------------------------// 获取 key 的 hash 值static final int hash(Object key) &#123; int h; // 做异或 和 无符号右移的位运算得到最后的 hash 值 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;------------------------// onlyIfAbsent：if true, don't change existing value// evict：if false, the table is in creation mode.final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table 为 null，表示第一次保存时，调用 resize() 方法进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 注意：(n - 1) &amp; hash 用来计算应该将这个键值对放到 table 的哪个位置 // HashMap 中，length 为 2 的幂次方，(n - 1) &amp; hash 等同于求模运算：h % length // 找到了保存位置 i，table[i] 指向一个单向链表，接下来，就是在这个链表中逐个查找是否已经有这个键了 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 无哈希冲突,创建新的 Node tab[i] = newNode(hash, key, value, null); else &#123; // 进到这里表明有哈希冲突了 Node&lt;K,V&gt; e; K k; // 节点 key 存在,直接覆盖 value，保证 key 的唯一性 // 而比较的时候，是先比较 hash 值，hash 相同的时候，再使用 equals 方法进行比较。注意：比较的时候先比较 hash，再比较地址值，最后才使用 equals() // 因为 hash 是整数，比较的性能一般要比 equals 比较高很多，hash 不同，就没有必要调用 equals 方法了，这样整体上可以提高比较性能 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断是否为为红黑树 else if (p instanceof TreeNode) // 是红黑树，赋值 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 是链表，并且 table 的 [i] 值相同的情况 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 如果 p 后的 Node 为空，表明当前链表只有一个结点 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 链表长度达到 8，改变链表结构为红黑树 treeifyBin(tab, hash); break; &#125; // key 相同则跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 就是移动指针方便继续取 p.next，因为前面有 e = p.next 这样的赋值 p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 根据规则选择是否覆盖value if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 扩容检测，并且此处完成对 size 加 1 if (++size &gt; threshold) // size 大于阈值则扩容 resize(); afterNodeInsertion(evict); return null;&#125;------------------------final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 扩容为原先的两倍大小 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 初始容量设为阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 零初始阈值表示使用默认值 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 扩容后的对旧数组中值的拷贝操作 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 6、get() 方法源码解析123456789101112131415161718192021222324public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;--------------------final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 7、remove() 方法源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;------------------------------final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // 要删除的结点是头结点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 不是要删除的结点头结点的情况 else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) // 红黑树节点 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; // 链表节点 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // node 表示要删除的结点，获取到 node 后，分情形删除节点 // node 不为 null 的情况下，再判断 value 是否一致，相当于双重保障吧 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) // 红黑树结点删除，牵扯到由红黑树变链表的逻辑 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 头结点 else if (node == p) tab[index] = node.next; // 非头结点，注意：node 为要删除的结点，p 为要删除结点的前一个结点 else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 8、HashMap 的主结构类似于一个数组，添加值时通过 key 确定储存位置。当发生冲突时,相同 hash 值的键值对会组成链表。在 JDK 1.8 以前，数组 + 链表的组合形式大部分情况下都能有不错的性能效果。但是在极端情况下，一组「比如经过精心设计的」键值对都发生了冲突，这时的哈希结构就会退化成一个链表，使 HashMap 性能急剧下降。所以在 JDK 1.8 之后，采用数组+链表+红黑树「链表长度大于 8 时转为红黑树」的方式对元素进行存储。 9、HashMap 实现原理小结HashMap 的基本实现原理，内部有一个数组 table，每个元素 table[i] 指向一个单向链表，根据键存取值，用键算出 hash，取模得到数组中的索引位置 buketIndex，然后操作 table[buketIndex] 指向的单向链表。 存取的时候依据键的 hash 值，只在对应的链表中操作，不会访问别的链表，在对应链表操作时也是先比较 hash 值，相同的话才用 equals 方法比较，这就要求，相同的对象其 hashCode() 返回值必须相同，如果键是自定义的类，就特别需要注意这一点。这也是hashCode和equals方法的一个关键约束。 HashMap 它实现了 Map 接口，可以方便的按照键存取值，它的实现利用了哈希，可以根据键自身直接定位，存取效率很高。 10、HashMap 特点分析HashMap 实现了 Map 接口，内部使用数组+链表+红黑树和哈希的方式进行实现，这决定了它有如下特点： 根据键保存、获取、删除操作的效率都很高，为 O(1)，每个单向链表往往只有一个或少数几个节点，根据 hash 值就可以直接快速定位。 HashMap 中的键值对没有顺序，因为 hash 值是随机的。 综上所述，HashMap 适用于不要求顺序，经常需要根据键存取值的场景。 11、根据哈希值存取对象、比较对象是计算机程序中一种重要的思维方式，它使得存取对象主要依赖于自身哈希值，而不是与其他对象进行比较，存取效率也就与集合大小无关，高达 O(1)，即使进行比较，也利用哈希值提高比较性能。 参考博客Java 编程的逻辑 - 剖析 HashMapJava8 HashMap 源码分析]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(二)]]></title>
    <url>%2F2018%2F08%2F22%2FJava-Java-Container-2018-08-22-Java%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 容器总结(二) —— LinkedList 1、LinkedList 与 ArrayList 一样，同样实现了 List 接口，而 List 接口扩展了 Collection 接口，Collection 又扩展了 Iterable 接口，所有这些接口的方法都是可以使用的。123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125; 2、队列 (Queue) LinkedList 还实现了队列接口 Queue，队列的特点就是先进先出，在尾部添加元素，从头部删除元素。 12345678 public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek();&#125; Queue 扩展了 Collection，它的主要操作有三个： 在尾部添加元素 (add, offer)。 查看头部元素 (element, peek)，返回头部元素，但不改变队列。 删除头部元素 (remove, poll)，返回头部元素，并且从队列中删除。 每种操作都有两种形式，区别在于，对于特殊情况的处理不同。特殊情况是指，队列为空或者队列为满。为满是指队列有长度大小限制，而且已经占满了。LinkedList 的实现中，队列长度没有限制，但别的 Queue 的实现可能有。 在队列为空时，element 和 remove 会抛出异常 NoSuchElementException，而 peek 和 poll 返回特殊值 null，在队列为满时，add 会抛出异常 IllegalStateException，而 offer 只是返回 false。 3、栈栈也是一种常用的数据结构，与队列相反，它的特点是先进后出、后进先出。Java 中用 Stack 类来表示栈，但这个类已经过时了，就 Stack 而言，在新的设计中，Queue 可以直接取代它。Java 中没有单独的栈接口，栈相关方法包括在了表示双端队列的接口 Deque 中。123456// push 表示入栈，在头部添加元素，栈的空间可能是有限的，如果栈满了，push 会抛出异常 IllegalStateExceptionvoid push(E e);// pop 表示出栈，返回头部元素，并且从栈中删除，如果栈为空，会抛出异常 NoSuchElementExceptionE pop();// peek 查看栈头部元素，不修改栈，如果栈为空，返回 nullE peek(); 4、双端队列 (Deque)栈和队列都是在两端进行操作，栈只操作头部，队列两端都操作，但尾部只添加、头部只查看和删除，有一个更为通用的操作两端的接口 Deque，Deque 扩展了 Queue，包括了栈的操作方法，此外，它还有更为明确的操作两端的方法。 xxxFirst 操作头部，xxxLast 操作尾部。与队列类似，每种操作有两种形式，区别也是在队列为空或满时，处理不同。为空时，getXXX/removeXXX 会抛出异常，而 peekXXX/pollXXX 会返回 null。队列满时，addXXX 会抛出异常，offerXXX 只是返回 false。 栈和队列只是双端队列的特殊情况，它们的方法都可以使用双端队列的方法替代，不过，使用不同的名称和方法，概念上更为清晰。 5、LinkedList 内部组成LinkedList 直译就是链表，确切的说，它的内部实现是双向链表，每个元素在内存都是单独存放的，元素之间通过链接连在一起。 为了表示链接关系，需要一个节点的概念，节点包括实际的元素，但同时有两个链接，分别指向前一个节点(前驱)和后一个节点(后继)，节点是一个内部类。123456789101112// Node 类表示节点private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList 内部组成中有三个实例变量：1234// size 表示链表长度，默认为 0transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; LinkedList 的所有 public 方法内部操作的都是这三个实例变量。 6、 add() 方法源码解析12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true;&#125;---------------------void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 7、根据索引访问元素 get()1234567891011121314151617181920212223242526272829public E get(int index) &#123; // 检查索引位置的有效性，如果无效，抛出异常 checkElementIndex(index); return node(index).item;&#125;------------------------private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;-------------------------private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;-------------------------Node&lt;E&gt; node(int index) &#123; // 根据 index 位置，来决定从前还是从后查找 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 8、indexOf 源码分析1234567891011121314151617public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 9、指定位置插入元素 add(int index, E element)12345678910111213141516171819202122232425262728293031323334353637383940414243public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;----------------------------private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;----------------------------private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;-----------------------------void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;----------------------------// 参数 succ 表示后继节点。变量 pred 就表示前驱节点。目标就是在 pred 和 succ 中间插入一个节点。void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 10、删除元素123456789101112131415161718192021222324252627282930public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;--------------------------E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 11、需要注意的是：对于队列、栈和双端队列接口，长度可能有限制，LinkedList 实现了这些接口，不过 LinkedList 对长度并没有限制。使用的时候需要特别留意那些限制。 12、对于 LinkedList 内部是用双向链表实现的，维护了长度、头节点和尾节点，这决定了它有如下特点： 按需分配空间，不需要预先分配很多空间。 不可以随机访问，按照索引位置访问效率比较低，必须从头或尾顺着链接找，效率为 O(N/2)。 不管列表是否已排序，只要是按照内容查找元素，效率都比较低，必须逐个比较，效率为 O(N)。 在两端添加、删除元素的效率很高，为 O(1)。 在中间插入、删除元素，要先定位，效率比较低，为 O(N)，但修改本身的效率很高，效率为 O(1)。 参考博客Java编程的逻辑 - 剖析 LinkedList]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 容器总结(一)]]></title>
    <url>%2F2018%2F08%2F22%2FJava-Java-Container-2018-08-22-Java%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java 容器总结(一) —— ArrayList 1、ArrayList 的基本原理是：内部有一个数组 elementData，一般会有一些预留的空间，有一个整数 size 记录实际的元素个数。elementData 会随着实际元素个数的增多而重新分配，而 size 则始终记录实际的元素个数。 2、add(E e) 方法源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean add(E e) &#123; // 首先调用 ensureCapacityInternal 确保数组容量是够的 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;------------------private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;-----------------private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;-----------------private void ensureExplicitCapacity(int minCapacity) &#123; // modCount 表示内部的修改次数，modCount++ 当然就是增加修改次数 modCount++; // overflow-conscious code 这里指整数运算超出其取值范围的情况 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;----------------private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 右移一位相当于除 2，所以，newCapacity 相当于 oldCapacity 的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 新建一个数组，将原先的数据拷贝到新的数组中 elementData = Arrays.copyOf(elementData, newCapacity);&#125;---------------private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 3、remove(int index) 方法源码解析12345678910111213141516171819public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;---------------private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 4、迭代foreach 适用于各种容器，比较通用。其背后的实现原理是，编译器会将 foreach 转换为类似如下代码：12345678910111213141516171819202122232425// 原先代码public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String s : list) &#123; System.out.println(s); &#125; &#125;&#125;// 编译后的 class 代码public class Test &#123; public Test() &#123; &#125; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList(); Iterator var2 = list.iterator(); while(var2.hasNext()) &#123; String s = (String)var2.next(); System.out.println(s); &#125; &#125;&#125; 迭代相关的源码：1234567891011121314// ArrayList 实现了 Iterable 接口，Iterable 表示可迭代的public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125;--------------// Iterable 中的 iterator 方法返回一个实现了 Iterator 接口的对象public interface Iterator&lt;E&gt; &#123; // hasNext() 判断是否还有元素未访问 boolean hasNext(); // next() 返回下一个元素 E next(); // remove() 删除最后返回的元素 void remove();&#125; 所以，只要对象实现了 Iterable 接口，就可以使用 foreach 语法，编译器会转换为调用 Iterable 和 Iterator 接口的方法。 5、Iterable &amp; Iterator Iterable 表示对象可以被迭代，它有一个方法 iterator()，返回 Iterator 对象，实际通过 Iterator 接口的方法进行遍历。 如果对象实现了 Iterable，就可以使用 foreach 语法。 类可以不实现 Iterable，也可以创建 Iterator 对象。 6、除了 iterator()，ArrayList 还提供了两个返回 Iterator 接口的方法：public ListIterator listIterator()public ListIterator listIterator(int index) ListIterator 扩展了 Iterator 接口，增加了一些方法，向前遍历、添加元素、修改元素、返回索引位置等。12345678public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void set(E e); void add(E e);&#125; listIterator() 方法返回的迭代器从 0 开始，而 listIterator(int index) 方法返回的迭代器从指定位置 index 开始。 7、迭代器的陷阱关于迭代器，有一种常见的误用，就是在迭代的中间调用容器的删除方法。这时候一般都会抛出 java.util.ConcurrentModificationException 异常。12345678// 调用容器的 remove 方法，会产生 ConcurrentModificationExceptionpublic void remove(ArrayList&lt;Integer&gt; list)&#123; for(Integer a : list)&#123; if(a&lt;=100)&#123; list.remove(a); &#125; &#125;&#125; 因为迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。 123456789// 而使用迭代器的 remove 方法，则不会产生异常public static void remove(ArrayList&lt;Integer&gt; list)&#123; Iterator&lt;Integer&gt; it = list.iterator(); while(it.hasNext())&#123; if(it.next()&lt;=100)&#123; it.remove(); &#125; &#125;&#125; 8、迭代器的实现原理 —— ArrayList 中 iterator 方法的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;--------------// Itr 是 ArrayList 的一个成员内部类，实现了 Iterator 接口private class Itr implements Iterator&lt;E&gt; &#123; // 表示下一个要返回的元素位置 int cursor; // index of next element to return // 表示最后一个被返回元素的索引位置，-1 表示没有返回过任何元素或者被删除了 int lastRet = -1; // index of last element returned; -1 if no such // expectedModCount 期望的修改次数，初始化为外部类当前的修改次数 modCount int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; // 每次迭代都去检查预期的 ModCount 和 现在的 ModCount 是否一致 checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 刚才判断 i &lt; size 这会 i &gt; 数组 length，中间数组结构发生改变 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; // 调用了 ArrayList 的 remove 方法，注意这里删除的是最后一个返回的元素的索引位置！！！ ArrayList.this.remove(lastRet); // 删除元素以后，后面的元素就会顶上来，所以指示下一个元素为被删除位置上的元素 cursor = lastRet; // 最后一个返回的元素删了，不存在了，所以 -1 表示 lastRet = -1; // 修改 expectedModCount，只有这样迭代的时候才不会抛异常 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;-------------- 每次发生结构性变化的时候 modCount 都会增加，而每次迭代器操作的时候都会检查 expectedModCount 是否与 modCount 相同，这样就能检测出结构性变化。 注意：使用 iterator 的 remove 方法前，必须先调用 next，从而为 lastRet 赋上正确的值，要不然是默认值 0，输出的结果很可能就是错的。而且循环删除的时候，第一次删除成功以后 lastRet 的值为 -1，再删的时候会抛异常 java.lang.IllegalStateException。 9、迭代器的好处迭代器语法更为通用，它适用于各种容器类。迭代器表示的是一种关注点分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个 Iterator 接口的引用，不需要关注数据的实际组织方式，可以使用一致和统一的方式进行访问。而提供 Iterator 接口的代码了解数据的组织方式，可以提供高效的实现。从封装的思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口。 10、Java 的各种容器类有一些共性的操作，这些共性以接口的方式体现，Iterable 接口就是如此。此外，ArrayList 还实现了三个主要的接口 Collection, List 和 RandomAccess。 11、Collection 接口Collection 表示一个数据集合，数据间没有位置或顺序的概念。boolean retainAll(Collection&lt;?&gt; c); retainAll 只保留参数容器中的元素，其他元素会进行删除。 有一个抽象类 AbstractCollection 对 Collection 接口中的很多方法都提供了默认实现，实现的方式就是利用迭代器方法逐个操作。ArrayList 继承了 AbstractList，而 AbstractList 又继承了 AbstractCollection，ArrayList 对其中一些方法进行了重写，以提供更为高效的实现。 12、List 表示有顺序或位置的数据集合，它扩展了 Collection。 13、RandomAccess 接口RandomAccess 是一个标记接口，是一个没有任何代码的接口，用于声明类的一种属性。 实现了 RandomAccess 接口的类表示可以随机访问，可随机访问就是具备类似数组那样的特性，数据在内存是连续存放的，根据索引值就可以直接定位到具体的元素，访问效率很高。 有没有声明 RandomAccess 有什么关系呢？主要用于一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现。 14、ArrayList 与 数组的相互转换1234567891011121314151617// 第一个方法返回是 Object 数组public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;-----------// 第二个方法返回对应类型的数组，如果参数数组长度足以容纳所有元素，就使用该数组，否则就新建一个数组@SuppressWarnings("unchecked")public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); // 如果指定的数组能容纳队列，并有剩余的空间（即数组的元素比队列多），那么会将数组中紧接 collection 尾部的元素设置为 null。（仅在调用者知道列表中不包含任何 null 元素时才能用此方法确定列表长度）。 if (a.length &gt; size) a[size] = null; return a;&#125; 15、Arrays 中有一个静态方法 asList 可以返回对应数组的 List。12345678public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125;--------// Arrays 类中的 ArrayList 静态内部类private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123;......&#125; 需要注意的是，这个方法返回的 List，它的实现类并不是真正的 ArrayList，而是 Arrays 类的一个内部类，在这个内部类的实现中，内部用的的数组就是传入的数组，没有拷贝，也不会动态改变大小，所以对数组的修改也会反映到 List 中。对 List 调用 add/remove 方法会抛出 java.lang.UnsupportedOperationException 异常，因为内部类中根本就不存在这些方法。 要使用 ArrayList 完整的方法，应该新建一个 ArrayList：List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(i)); 16、对于 ArrayList，它的特点是：内部采用动态数组实现，这决定了： 可以随机访问，按照索引位置进行访问效率很高，效率是 O(1)。 除非数组已排序，否则按照内容查找元素效率比较低，具体是 O(N)。 添加元素的效率还可以，重新分配和拷贝数组的开销被平摊了，具体来说，添加 N 个元素的效率为 O(N)。 插入和删除元素的效率比较低，因为需要移动元素，具体为 O(N)。 参考博客Java编程的逻辑 - 剖析 ArrayList]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(六)]]></title>
    <url>%2F2018%2F08%2F19%2FJava-Java-Thread-2018-08-19-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Java 线程总结(六) —— 显式锁 ReentrantLock 锁相关注意：在学习显示锁的时候要跟 synchronized 锁对比的学，synchronized 锁是由 JVM 去实现的，而显示锁是由我们来实现的，但是它们的功能都很类似，都可以对比着来学的。线程也会去争夺显示锁，争夺不到的时候也可能会阻塞，当前线程也会被放到等待队列中。 1、Java 并发包中的显式锁接口和类位于包 java.util.concurrent.locks 下，主要接口和类有： 锁接口 Lock，主要实现类是 ReentrantLock。读写锁接口 ReadWriteLock，主要实现类是 ReentrantReadWriteLock。 相比 synchronized，显式锁支持以非阻塞方式获取锁、可以响应中断、可以限时，这使得它灵活的多。 2、可重入锁 ReentrantLockLock 接口的主要实现类是 ReentrantLock，它的基本用法 lock/unlock 实现了与 synchronized 一样的语义，包括： 可重入，一个线程在持有一个锁的前提下，可以继续获得该锁。可以解决竞态条件问题。可以保证内存可见性。 public ReentrantLock(boolean fair)参数 fair 表示是否保证公平，不指定的情况下，默认为 false，表示不保证公平。所谓公平是指，等待时间最长的线程优先获得锁。保证公平会影响性能，一般也不需要，所以默认不保证，synchronized 锁也是不保证公平的。 使用显式锁，一定要记得调用 unlock。 一般而言，应该将 lock 之后的代码包装到 try 语句内，在 finally 语句内释放锁。 3、ReentrantLock 的实现原理在最底层，它依赖于 CAS 方法，另外，它依赖于类 LockSupport 中的一些方法。 LockSupport 锁相关4、类 LockSupport 也位于包 java.util.concurrent.locks 下。public static void park() park 方法使得当前线程放弃 CPU，进入等待状态(WAITING)，操作系统不再对它进行调度，只有其他线程对它调用了 unpark，unpark 需要指定一个线程，unpark 会使之恢复可运行状态。 LockSupport.park() 不同于 Thread.yield()，yield 只是告诉操作系统可以先让其他线程运行，但自己依然是可运行状态，而 park 会放弃调度资格，使线程进入 WAITING 状态。park 是响应中断的，当有中断发生时，park 会返回，线程的中断状态会被设置。另外，需要说明一下，park 可能会无缘无故的返回，程序应该重新检查 park 等待的条件是否满足。 park/unpark 方法的底层实现调用了 Unsafe 类中的对应方法，Unsafe 类最终调用了操作系统的 API，从程序员的角度，我们可以认为 LockSupport 中的这些方法就是基本操作。 AQS 相关AQS：AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等），JUC 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。AQS 解决了实现同步器时涉及到的大量细节问题，例如获取同步状态、FIFO 同步队列。在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。AQS 的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。AQS 的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。AbstractQueuedSynchronizer 为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件，等等）提供一个框架。 5、AQS (AbstractQueuedSynchronizer)利用 CAS 和 LockSupport 提供的基本方法，就可以用来实现 ReentrantLock 了。但 Java 中还有很多其他并发工具，如 ReentrantReadWriteLock、Semaphore、CountDownLatch，它们的实现有很多类似的地方，为了复用代码，Java 提供了一个抽象类 AbstractQueuedSynchronizer，我们简称为 AQS。 用于实现锁时，AQS 可以保存锁的当前持有线程，提供了方法进行查询和设置： private transient Thread exclusiveOwnerThread;protected final void setExclusiveOwnerThread(Thread t);protected final Thread getExclusiveOwnerThread(); AQS 内部维护了一个等待队列，借助 CAS 方法实现了无阻塞算法进行更新。等待队列是 FIFO 先进先出，只有前一个节点的状态为 SIGNAL 时，当前节点的线程才能被挂起。子类重写 tryAcquire 和 tryRelease 方法通过 CAS 指令修改状态变量 state。 6、保证公平整体性能比较低，低的原因不是这个检查慢，而是会让活跃线程得不到锁，进入等待状态，引起上下文切换，降低了整体的效率，通常情况下，谁先运行关系不大，而且长时间运行，从统计角度而言，虽然不保证公平，也基本是公平的。 需要说明是，即使 fair 参数为 true，ReentrantLock 中不带参数的 tryLock 方法也是不保证公平的，它不会检查是否有其他等待时间更长的线程。 7、ReentrantLock 对比 synchronized相比 synchronized，ReentrantLock 可以实现与 synchronized 相同的语义，但还支持以非阻塞方式获取锁、可以响应中断、可以限时等，更为灵活。不过，synchronized 的使用更为简单，写的代码更少，也更不容易出错。 synchronized 代表一种声明式编程，程序员更多的是表达一种同步声明，由 Java 系统负责具体实现，程序员不知道其实现细节，显式锁代表一种命令式编程，程序员实现所有细节。 声明式编程的好处除了简单，还在于性能，在较新版本的 JVM 上，ReentrantLock 和 synchronized 的性能是接近的，但 Java 编译器和虚拟机可以不断优化 synchronized 的实现，比如，自动分析 synchronized 的使用，对于没有锁竞争的场景，自动省略对锁获取/释放的调用。 8、显式锁 ReentrantLock 使用 CAS、LockSupport 和 AQS 实现的。 9、总结：能用 synchronized 就用 synchronized，不满足要求，再考虑 ReentrantLock。 参考博客Java编程的逻辑 - 显式锁深入浅出 Java 同步器 AQS深入学习 Java 同步器 AQS]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(五)]]></title>
    <url>%2F2018%2F08%2F18%2FJava-Java-Thread-2018-08-18-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[Java 线程总结(五) —— 原子变量和 CAS 原子变量相关1、Java 并发包中的基本原子变量类型有： AtomicBoolean：原子 Boolean 类型AtomicInteger：原子 Integer 类型AtomicLong：原子 Long 类型AtomicReference：原子引用类型 针对 Integer, Long 和 Reference 类型，还有对应的数组类型： AtomicIntegerArrayAtomicLongArrayAtomicReferenceArray 为了便于以原子方式更新对象中的字段，还有如下的类： AtomicIntegerFieldUpdaterAtomicLongFieldUpdaterAtomicReferenceFieldUpdater AtomicReference 还有两个类似的类，在某些情况下更为易用： AtomicMarkableReferenceAtomicStampedReference 2、对于 char, short, float, double 类型的原子变量，可以转为 int/long，然后使用 AtomicInteger 或 AtomicLong。eg：float 类型和 int 类型互相转换：12public static int floatToIntBits(float value)public static float intBitsToFloat(int bits); 3、之所以称为原子变量，是因为其包含一些以原子方式实现组合操作的方法。这些方法的实现都依赖另一个 public 方法：public final boolean compareAndSet(int expect, int update)比较并设置。该方法以原子方式实现了如下功能：如果当前值等于 expect，则更新为 update，否则不更新，如果更新成功，返回 true，否则返回 false。 AtomicInteger 源码解析：12345678910111213141516171819public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; // 用 volatile 关键字保证获取到的当前值是内存中的最新值 private volatile int value; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; // unsafe 中的 compareAndSwapInt 方法，用 native 声明，该方法封装了底层操作系统的硬件级别的原子操作 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);&#125; 什么是 unsafe 呢？Java 语言不像 C，C++ 那样可以直接访问底层操作系统，但是 JVM 为我们提供了一个后门，这个后门就是 unsafe。unsafe 为我们提供了硬件级别的原子操作。 至于 valueOffset 对象，是通过 unsafe.objectFieldOffset 方法得到，它是一个 native 声明的方法，所代表的是 AtomicInteger 对象的成员变量 value 在内存中的偏移量。我们可以简单地把 valueOffset 理解为 value 变量的内存地址。 CAS 的底层实现？1、用 volatile 关键字保证获取到的 value 当前值是内存中的最新值。2、使用静态代码块在类初始化的时候就获取到某个对象的成员变量 value 在内存中的偏移量 valueOffset，可以简单的理解为 value 变量的内存地址。3、compareAndSwapInt 是 native 声明的方法，封装了底层操作系统的硬件级别的原子操作。4、所谓的自旋操作实际上就是在一个死循环中不断的调用操作系统硬件级别的原子操作，直到成功为止。说到底，正是因为 unsafe 该方法封装了底层操作系统的硬件级别的原子操作，例如：compareAndSwapInt，才能有 Java 的 CAS。 什么是 ABA 问题？如何解决？所谓 ABA 问题，就是一个变量的值从 A 改成了 B，又从 B 改成了 A。虽然表面上看，某块内存里的值没有改变，但是实际上此 A 非彼 A。但是在使用 CAS 进行更新的时候，会认为两个 A 是同一个 A，从而产生问题。「当一个值从 A 更新成 B，又更新会 A，普通 CAS 机制会误判通过检测。利用版本号比较可以有效解决 ABA 问题。」 要想解决 ABA 问题，本质上就是要区分此 A 非彼 A。例如：给 A 加个版本号。真正要做到严谨的 CAS 机制，在 Compare 阶段不仅要比较期望值和地址中的实际值，还要比较变量的版本号是否一致。在 Java 当中，AtomicStampedReference 类 和 AtomicMarkableReference 类就实现了用版本号做比较的 CAS 机制。 4、synchronized VS CASsynchronized 是悲观的，它假定更新很可能冲突，所以先获取锁，得到锁后才更新。原子变量的更新逻辑是乐观的，它假定冲突比较少，但使用 CAS 更新，也就是进行冲突检测，如果确实冲突了，那也没关系，继续尝试就好了。 synchronized 代表一种阻塞式算法，得不到锁的时候，进入锁等待队列，等待其他线程唤醒，有上下文切换开销。原子变量的更新逻辑是非阻塞式的，更新冲突的时候，它就重试，不会阻塞，不会有上下文切换开销。 原子变量是比较简单的，但对于复杂一些的数据结构和算法，非阻塞方式往往难于实现和理解，幸运的是，Java 并发包中已经提供了一些非阻塞容器。 ConcurrentLinkedQueue 和 ConcurrentLinkedDeque：非阻塞并发队列。ConcurrentSkipListMap 和 ConcurrentSkipListSet：非阻塞并发 Map 和 Set。 5、AtomicReference 用来以原子方式更新复杂类型，它有一个类型参数，使用时需要指定引用的类型。 原子数组方便以原子的方式更新数组中的每个元素。public AtomicIntegerArray(int[] array) 注意：该方法接受一个已有的数组，但不会直接操作该数组，而是会创建一个新数组，只是拷贝参数数组中的内容到新数组。 FieldUpdater 方便以原子方式更新对象中的字段，字段不需要声明为原子变量，FieldUpdater 是基于反射机制实现的。 CAS 相关1、什么是 CAS？CAS 是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换。CAS 机制当中使用了 3 个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。 2、CAS 机制的缺点？CAS 虽然没有上下文切换了，但却是在消耗 CPU 不停的自旋，即 CPU 不停的重新计算。CAS 机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。ABA 问题。 3、CAS 的底层实现？什么是 unsafe 呢？Java 语言不像 C，C++ 那样可以直接访问底层操作系统，但是 JVM 为我们提供了一个后门，这个后门就是 unsafe。unsafe 为我们提供了硬件级别的原子操作。unsafe 是 Sun 的私有实现，从名字看，表示的也是”不安全”，一般应用程序不应该直接使用。原理上，一般的计算机系统都在硬件层次上直接支持 CAS 指令，而 Java 的实现都会利用这些特殊指令。从程序的角度看，我们可以将 compareAndSet 视为计算机的基本操作，直接接纳就好。 至于 valueOffset 对象，是通过 unsafe.objectFieldOffset 方法得到，所代表的是 AtomicInteger 对象 value 成员变量在内存中的偏移量。我们可以简单地把 valueOffset 理解为 value 变量的内存地址。 CAS 是 Java 并发包的基础，基于它可以实现高效的、乐观、非阻塞式数据结构和算法，它也是并发包中锁、同步工具和各种容器的基础。 123456789101112131415private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 4、CAS 中的 ABA 问题？所谓 ABA 问题，就是一个变量的值从 A 改成了 B，又从 B 改成了 A。即当一个值从 A 更新成 B，又更新会 A，普通 CAS 机制会误判通过检测。真正要做到严谨的 CAS 机制，我们在 Compare 阶段不仅要比较期望值 A 和地址 V 中的实际值，还要比较变量的版本号是否一致。在 Java 中，AtomicStampedReference 类就实现了用版本号做比较的 CAS 机制。ABA 是不是一个问题与程序的逻辑有关。 volatile 相关首先明确一点，volatile 修饰符并不是 Java 语言的首创，早在 C 和 C++ 当中就已经存在了。 注意：工作内存所做的修改不会立刻同步到主内存，所以可能会产生问题。 1、什么是 volatile 关键字？Java 内存模型简称 JMM（Java Memory Model）。线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。 volatile 关键字保证了用 volatile 修饰的变量对所有线程的可见性。可见性是指：当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。注意的是 volatile 只能保证变量的可见性，并不能保证变量的原子性。 volatile 保证可见性的特性，得益于 Java 语言的 先行发生原则（happens-before）。先行发生原则是指：在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。 2、什么是指令重排？指令重排是指JVM在编译Java代码的时候，或者 CPU 在执行 JVM 字节码的时候，对现有的指令顺序进行重新排序。指令重排是在字节码指令的层面进行重排序的。 指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。 3、什么是内存屏障？内存屏障（Memory Barrier）是一种 CPU 指令。内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使 CPU 或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。 内存屏障共分为四种类型： 1.LoadLoad 屏障抽象场景：Load1; LoadLoad; Load2Load1 和 Load2 代表两条读取指令。在 Load2 要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。 2.StoreStore 屏障抽象场景：Store1; StoreStore; Store2Store1 和 Store2 代表两条写入指令。在 Store2 写入执行前，保证 Store1 的写入操作对其它处理器可见。 3.LoadStore 屏障抽象场景：Load1; LoadStore; Store2在 Store2 被写入前，保证 Load1 要读取的数据被读取完毕。 4.StoreLoad 屏障抽象场景：Store1; StoreLoad; Load2在 Load2 读取操作执行前，保证 Store1 的写入对所有处理器可见。StoreLoad 屏障的开销是四种屏障中最大的。 4、volatile 如何使用内存屏障来保证变量在线程之间的可见性？在一个变量被 volatile 修饰后，JVM 会为我们做两件事：1.在每个 volatile 写操作前插入 StoreStore 屏障，在写操作后插入 StoreLoad 屏障。2.在每个 volatile 读操作前插入 LoadLoad 屏障，在读操作后插入 LoadStore 屏障。 5、volatile 只是保证，写的时候能够立刻从工作内存同步到主内存中，读的时候，一定读的是当前内存中的最新值，仅此而已。它不会保证原子性，如果 10 个线程同时读，它们都会读到内存中的最新值，但是，只会读一次，之后内存中的值改变了，就必须重新读了，重新读的时候，依然是当前时刻内存中的最新值。即 volatile 值负责它读的那一刻，读取到的是内存中的最新值，至于以后内存中的该值怎么变化，跟它已经没关系了。 参考博客什么是 CAS 机制？什么是 CAS 机制？(进阶篇)什么是 volatile 关键字？Java 编程的逻辑 - 原子变量和 CAS用户模式和内核模式]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(四)]]></title>
    <url>%2F2018%2F08%2F17%2FJava-Java-Thread-2018-08-17-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Java 线程总结(四) —— 线程的中断 1、在 Java 中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。 2、每个线程都有一个标志位，表示该线程是否被中断了。被中断了为 true，没有被中断或默认值为 false。 3、Thread 类定义了以下关于中断的方法： public boolean isInterrupted()：就是返回对应线程的中断标志位是否为 true。 public void interrupt()。 public static boolean interrupted() interrupted() 是静态方法，实际会调用 Thread.currentThread() 操作当前线程。返回当前线程的中断标志位是否为 true，但它还有一个重要的副作用，就是清空中断标志位，也就是说，连续两次调用 interrupted()，第一次返回的结果为 true，第二次一般就是 false「除非同时又发生了一次中断」。 4、线程对中断的反应interrupt() 对线程的影响与线程的状态和正在进行的 IO 操作有关，我们先主要考虑线程的状态： RUNNABLE：线程在运行或具备运行条件只是在等待操作系统调度。如果线程在运行中，且没有执行 IO 操作，interrupt() 只是会设置线程的中断标志位，没有任何其它作用。线程应该在运行过程中合适的位置检查中断标志位 WAITING/TIMED_WAITING：线程在等待某个条件或超时。在这些状态时，对线程对象调用 interrupt() 会使得该线程抛出 InterruptedException，需要注意的是，抛出异常后，中断标志位会被清空，而不是被设置。 BLOCKED：线程在等待锁，试图进入同步块。如果线程在等待锁，对线程对象调用 interrupt() 只是会设置线程的中断标志位，线程依然会处于 BLOCKED 状态，也就是说，interrupt() 并不能使一个在等待锁的线程真正”中断”。在使用 synchronized 关键字获取锁的过程中不响应中断请求，这是 synchronized 的局限性。 如果这对程序是一个问题，应该使用显式锁，它支持以响应中断的方式获取锁。 NEW/TERMINATED：线程还未启动或已结束。如果线程尚未启动 (NEW)，或者已经结束 (TERMINATED)，则调用 interrupt() 对它没有任何效果，中断标志位也不会被设置。 5、捕获到 InterruptedException，通常表示希望结束该线程，线程大概有两种处理方式： 1.向上传递该异常，这使得该方法也变成了一个可中断的方法，需要调用者进行处理。 2.有些情况，不能向上传递异常，比如 Thread 的 run 方法，它的声明是固定的，不能抛出任何受检异常，这时，应该捕获异常，进行合适的清理操作，清理后，一般应该调用 Thread的 interrupt 方法设置中断标志位，使得其他代码有办法知道它发生了中断。 6、IO 操作如果线程在等待 IO 操作，尤其是网络 IO，则会有一些特殊的处理： 如果 IO 通道是可中断的，即实现了 InterruptibleChannel 接口，则线程的中断标志位会被设置，同时，线程会收到异常 ClosedByInterruptException。 如果线程阻塞于 Selector 调用，则线程的中断标志位会被设置，同时，阻塞的调用会立即返回。 7、InputStream 的 read 调用，该操作是不可中断的，如果流中没有数据，read 会阻塞 (但线程状态依然是 RUNNABLE)，且不响应 interrupt()，与 synchronized 类似，调用 interrupt() 只会设置线程的中断标志，而不会真正”中断”它。 8、如何正确地取消/关闭线程？interrupt 方法不一定会真正”中断”线程，它只是一种协作机制，如果不明白线程在做什么，不应该贸然的调用线程的 interrupt 方法，以为这样就能取消线程。 对于以线程提供服务的程序模块而言，它应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用者应该调用这些方法而不是直接调用 interrupt。 在 Java 中如何取消/关闭线程，主要依赖的技术是中断，但它是一种协作机制，不会强迫终止线程。作为线程的实现者，应该提供明确的取消/关闭方法，并用文档描述清楚其行为，作为线程的调用者，应该使用其取消/关闭方法，而不是贸然调用 interrupt。 参考博客Java 编程的逻辑 - 线程的中断]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(三)]]></title>
    <url>%2F2018%2F08%2F16%2FJava-Java-Thread-2018-08-16-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Java 线程总结(三) —— 线程的基本协作机制 1、Java 中多线程协作的基本机制 wait/notify。 2、常见的线程协作场景： 生产者/消费者协作模式 同时开始 等待结束 异步结果 集合点 3、Java 在 Object 类中，定义了一些线程协作的基本方法，使得每个对象都可以调用这些方法，这些方法有两类，一类是 wait，另一类是 notify。 4、wait() 方法的原理？每个对象都有一把锁和一个锁等待队列，一个线程在进入 synchronized 代码块时，会尝试获取锁，获取不到的话会把当前线程加入到锁等待队列中。除了用于锁的等待队列，每个对象还有另一个等待队列，表示条件队列，该队列用于线程间的协作。调用 wait 就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，这个条件它自己改变不了，需要其他线程改变。当其他线程改变了条件后，应该调用 Object 的 notify 方法。wait 虽然是在 synchronzied 方法内，但调用 wait 时，线程会释放对象锁。 而 notify 做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll 和 notify 的区别是，它会移除条件队列中所有的线程并全部唤醒。wait 的具体过程是： 1.把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为 WAITING 或 TIMED_WAITING。 2.等待时间到或被其他线程调用 notify/notifyAll 从条件队列中移除，这时，要重新竞争对象锁。 如果能够获得锁，线程状态变为 RUNNABLE，并从 wait 调用中返回。 否则，该线程加入对象锁等待队列，线程状态变为 BLOCKED，只有在获得锁后才会从 wait 调用中返回。 3.线程从 wait 调用中返回后，不代表其等待的条件就一定成立了，它需要重新检查其等待的条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class WaitThread extends Thread&#123; // 协作的条件变量是 fire private volatile boolean fire = false; @Override public void run() &#123; try &#123; synchronized (this) &#123; while (!fire) &#123; System.out.println("wait......before"); wait(); System.out.println("wait......after"); &#125; &#125; System.out.println("fired"); &#125; catch (InterruptedException e) &#123; &#125; &#125; // 两个线程都要访问协作的变量 fire，容易出现竞态条件，所以相关代码都需要被 synchronized 保护 public synchronized void fire() &#123; this.fire = true; notify(); &#125; public static void main(String[] args) throws InterruptedException &#123; WaitThread t = new WaitThread(); /** * 线程启动以后，开始了 run 方法的执行，首先获取 WaitThread 的对象锁 * 然后执行 while 循环，由于「fire = false」，所以进入 while 循环体 * 执行 wait 方法，即放弃对象锁，并把单前线程 t 加入到条件等待队列中，然后线程阻塞在了 wait 方法这，不再向下执行 */ t.start(); Thread.sleep(1000); System.out.println("fire"); /** * 主线程执行 fire 方法，干了两件事：把 fire 设置为 true，调用了 WaitThread 对象的 notify 方法 * 一旦调用 notify 方法，等待的 t 线程就被唤醒了，并且把 t 线程从条件等待队列中移除 * 接下来，t 线程要尝试去获取 WaitThread 对象的锁，但是现在这把锁被主线程在 fire 方法中占用了，只有等到主线程释放它才可以获得到 * 由于 t 获取锁没有获取到，所以 t 线程加入到了 WaitThread 对象的锁等待队列中了，挪坑了！ * 当主线程释放锁以后，t 线程终于抢到了锁，然后 t 线程从 wait 调用中返回了，开始执行 wait 调用下面的语句 「System.out.println("wait......after");」 * 然后开始执行下一轮 while 循环，发现条件变了，所以不再进入 while 循环，直接执行「System.out.println("fired");」，然后 t 线程结束使命 */ t.fire(); &#125;&#125; 5、notify() 方法的原理？notify 做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒。调用 notify 会把在条件队列中等待的线程唤醒并从队列中移除，但它「这里指主线程」不会释放对象锁，也就是说，只有在包含 notify 的 synchronzied 代码块执行完后，等待的线程才会从 wait 调用中返回。 6、wait/notify 方法只能在 synchronized 代码块内被调用，如果调用 wait/notify 方法时，当前线程没有持有对象锁，会抛出异常 java.lang.IllegalMonitorStateException。 那么问题来了：为什么wait(),notify(),notifyAll() 必须在同步方法/代码块中调用？因为 wait() 和 notify() 之间的竞态条件导致必须在同步方法/代码块中调用，因为 wait 和 notify 都需要访问和操作对象的等待队列，wait 入队，notify 出队，它们对等待队列的访问顺序是敏感的，所以需要放到同步代码中，以避免竞态条件问题。 在 Java 中，所有对象都能够被作为「监视器即 Monitor」，而监视器是指：一个拥有 一个独占锁，一个入口队列和一个等待队列的 实体。对于对象的同步方法来说，在任意时刻有且仅有一个拥有该对象独占锁的线程能够调用它们。eg：一个同步方法是独占的。如果在线程调用某一对象的同步方法时，对象的独占锁被其他线程拥有，那么当前线程将处于阻塞状态，并添加到对象的入口队列中。 当一个线程正在某一个对象的同步方法中运行时调用了这个对象的 wait() 方法，那么这个线程将释放该对象的独占锁并被放入这个对象的等待队列。注意，wait() 方法强制当前线程释放对象锁。这意味着在调用某对象的 wait() 方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的 wait() 方法。 当某线程调用某对象的 notify() 或 notifyAll() 方法时，任意一个或者所有在该对象的等待队列中的线程，将被转移到该对象的入口队列。 调用 wait() 方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用 notify()或notifyAll() 方法的原因通常是，调用线程希望告诉其他等待中的线程「特殊状态已经被设置」。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。 假设 wait(),notify(),notifyAll() 方法不需要加锁就能够被调用。此时消费者线程调用 wait() 正在进入状态变量的等待队列(可能还未进入)。在同一时刻，生产者线程调用 notify() 方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞「因为该线程还没有进入到等待队列中，但是 notify 开始检查等待队列是否有线程了，检查发现没有，notify 失效，这时该线程进入到了等待队列，可能永远错过被唤醒的机会」。因此，对象的 wait(),notify(),notifyAll() 方法必须在该对象的同步方法或同步代码块中被互斥地调用。 简单总结一下，wait/notify 方法看上去很简单，但往往难以理解 wait 等的到底是什么，而 notify 通知的又是什么，我们需要知道，它们与一个共享的条件变量有关，这个条件变量是程序自己维护的，当条件不成立时，线程调用 wait 进入条件等待队列，另一个线程修改了条件变量后调用 notify，调用 wait 的线程唤醒后需要重新检查条件变量。从多线程的角度看，它们围绕共享变量进行协作，从调用 wait 的线程角度看，它阻塞等待一个条件的成立。 我们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心。 上面的代码的共享变量是 WaitThread 对象的 fire 变量，结束等待的条件是 fire 的值为 true，这是面代码协作的核心。但是，协作的核心虽然是 fire 变量，但是作用的却是 WaitThread 整个对象，是通过这个对象的条件队列进行协作的，而不是这个对象的某个变量。 7、Java 中每个对象只能有一个条件等待队列，这是 Java wait/notify 机制的局限性，这使得对于等待条件的分析变得复杂。 8、Java 提供了专门的阻塞队列实现，包括： 接口 BlockingQueue 和 BlockingDeque 基于数组的实现类 ArrayBlockingQueue 基于链表的实现类 LinkedBlockingQueue 和 LinkedBlockingDeque 基于堆的实现类 PriorityBlockingQueue 9、Java 中线程间协作的基本机制 wait/notify，协作关键要想清楚协作的共享变量和条件是什么。 参考博客Java 编程的逻辑 - 线程的基本协作机制 (上)Java 编程的逻辑 - 线程的基本协作机制 (下)为什么 wait(),notify(),notifyAll() 必须在同步方法/代码块中调用？为什么 wait 和 notify 必须在同步方法或同步块中调用]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(二)]]></title>
    <url>%2F2018%2F08%2F15%2FJava-Java-Thread-2018-08-15-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 线程总结(二) —— synchronized 关键字 1、Java 中的每一个对象都可以作为锁。具体表现为以下三种形式： 对于普通同步方法，锁是当前实例对象。对于静态同步方法，锁是当前类的 Class 对象。对于同步代码块，锁是 synchronized 括号里配置的对象。 synchronized 可以用于修饰「普通方法、静态方法、代码块」。 2、synchronized 用于「实例方法」的时候？synchronized 用于「实例方法」的时候到底做了什么呢？看上去，synchronized 使得同时只能有一个线程执行实例方法，但这个理解是不确切的。多个线程是可以同时执行同一个 synchronized 实例方法的，只要它们「访问的对象」是不同的。 synchronized 实例方法实际保护的是 同一个对象的方法调用，确保同时只能有一个线程执行。 再具体来说，synchronized 实例方法保护的是当前实例对象，即 this，this 对象有 一个锁和一个等待队列，锁只能被一个线程持有，其他试图获得同样锁的线程需要等待，加入到等待队列中。 执行 synchronized 实例方法的过程大概如下： 1.尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒。2.执行实例方法体代码。3.释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的，不保证公平性。 当前线程不能获得锁的时候，它会加入等待队列等待，线程的状态会变为 BLOCKED。 3、synchronized 保护的是对象而非代码，只要访问的是同一个对象的 synchronized 方法，即使是不同的代码，也会被同步顺序访问。 synchronized 方法不能防止非 synchronized 方法被同时执行。一般在保护变量时，需要在所有访问该变量的方法上加上 synchronized。 4、synchronized 用于「静态方法」的时候？前面我们说，synchronized 保护的是对象，对实例方法，保护的是当前实例对象 this，对静态方法，保护的是哪个对象呢？是类对象，即「类名称.class」，实际上，每个对象都有一个锁和一个等待队列，类对象也不例外。 synchronized 静态方法和 synchronized 实例方法保护的是不同的对象，不同的两个线程，可以同时，一个执行 synchronized 静态方法，另一个执行 synchronized 实例方法。 5、synchronized 用于「代码块」的时候？synchronized 括号里面的就是保护的对象，对于实例方法，就是 this，{} 里面是同步执行的代码。synchronized 同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。 6、synchronized 之可重入性synchronized 有一个重要的特征，它是可重入的，也就是说，对同一个执行线程，它在获得了锁之后，在调用其他需要 同样锁 的代码时，可以直接调用。 可重入是通过记录锁的持有线程和持有数量来实现的，当调用被 synchronized 保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。 7、synchronized 之内存可见性synchronized 除了保证原子操作外，它还有一个重要的作用，就是保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据。 不过，如果只是为了保证内存可见性，使用 synchronzied 的成本有点高，有一个更轻量级的方式，那就是给变量加修饰符 volatile。加了 volatile 之后，Java 会在操作对应变量时插入特殊的指令，保证读写到内存最新值，而非缓存的值。 8、synchronized 之解决死锁使用 synchronized 或者其他锁，要注意死锁。关于死锁解决，首先，应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁。使用显式锁接口 Lock，它支持尝试获取锁和带时间限制的获取锁方法，使用这些方法 可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。 一旦出现了死锁，Java 不会主动处理，借助一些工具，我们可以发现运行中的死锁。eg：Java 自带的 jstack 命令会报告发现的死锁。 9、同步容器Collections 的一些方法，它们可以返回线程安全的同步容器，它们是给所有容器方法都加上 synchronized 来实现安全的。这里线程安全针对的是容器对象，指的是当多个线程并发访问同一个容器对象时，不需要额外的同步操作，也不会出现错误的结果。 但是，加了 synchronized，所有方法调用变成了原子操作，客户端在调用时，是不是就绝对安全了呢？不是的，至少有以下情况需要注意： 复合操作，比如先检查再更新。对于 putIfAbsent 方法，虽然 get、put 方法是同步的，但是可能有多个线程都执行了检查者一步，然后都调用 put 方法，破坏了 putIfAbsent 方法期望保持的语义。 伪同步，即同步了不同的对象。如果给 putIfAbsent 方法加上 synchronized 关键字，虽然 putIfAbsent 方法是同步方法了，但是，put 方法没有加呢，其他线程照样可以调用该方法进行 put，同步错对象了。解决办法是要么 EnhancedMap 中的所有方法都需要加上 synchronized，要么使用 map 作为锁。 迭代，对于同步容器对象，虽然单个操作是安全的，但迭代并不是。eg：创建一个同步 List 对象，一个线程修改 List，另一个遍历，会产生 ConcurrentModificationException 异常。如果在遍历的同时容器发生了结构性变化，就会抛出该异常，同步容器并没有解决这个问题，如果要避免这个异常，需要在遍历的时候给整个容器对象加锁。 123456789101112131415161718192021public class EnhancedMap &lt;K, V&gt; &#123; Map&lt;K, V&gt; map; public EnhancedMap(Map&lt;K,V&gt; map)&#123; this.map = Collections.synchronizedMap(map); &#125; public V putIfAbsent(K key, V value)&#123; V old = map.get(key); if(old!=null)&#123; return old; &#125; // 注意这里的 put 方法是下面即本类中定义的 put 方法，不是 map 中的 put 方法 map.put(key, value); return null; &#125; public void put(K key, V value)&#123; map.put(key, value); &#125;&#125; 11、并发容器同步容器的性能是比较低的，当并发访问量比较大的时候性能很差。所幸的是，Java 中还有很多专为并发设计的容器类，比如： CopyOnWriteArrayListConcurrentHashMapConcurrentLinkedQueueConcurrentSkipListSet 这些容器类都是线程安全的，但都没有使用 synchronized、没有迭代问题、直接支持一些复合操作、性能也高得多。 参考博客Java编程的逻辑 - 理解 synchronizedsynchronized 的可重入性]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程总结(一)]]></title>
    <url>%2F2018%2F08%2F14%2FJava-Java-Thread-2018-08-14-Java%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java 线程总结(一) —— 线程的基本概念 1、并发：在程序中创建线程来启动多条执行流，从而达到并发。 2、线程：表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。 3、Java 中有两种创建线程的方式，不管用哪种方式创建线程，都有以下特征： run() 方法是线程执行的主体，run() 方法也是线程执行的入口。线程只会执行 run() 方法里面的语句「包括被 run() 方法调用的语句」。 启动线程必须通过 Thread 对象的 start() 方法进行启动，线程启动以后就会去执行对应的 run() 方法。 4、在多线程中，当所有线程都执行完毕的时候，程序才会退出「这里的线程不包括 daemon 守护线程」。即：当整个程序中剩下的都是 daemo 线程的时候，程序就会退出。 5、Java 中线程有一个优先级的概念，这个优先级会被映射到操作系统中线程的优先级，优先级映射到操作系统中时，到底有没有用，有多大用，都是未知不可控的。优先级对操作系统而言更多的是一种建议和提示，开发中，不要过于依赖优先级。 6、线程的状态 7、什么是守护线程 daemon？它一般是其他线程的辅助线程，在它辅助的主线程退出的时候，它就没有存在的意义了。例如：在我们运行一个即使最简单的 「hello world」的程序时，实际上，Java 也会创建多个线程，除了 main 线程外，至少还有一个负责垃圾回收的线程，这个线程就是 daemo 线程，在 main 线程结束的时候，垃圾回收线程也会退出。 8、Thread 的 sleep 方法：让当前线程睡眠指定的时间。睡眠期间，线程会让出 cpu，但是不会放弃对象锁。 9、Thread 的 yield 方法：让当前线程让出 cup。调用该方法，是告诉操作系统的调度器，我现在不着急占用 CPU，你可以先让其他线程运行。不过这个也仅仅只是建议，调度器如何处理是不一定的。该方法可能会让出 CPU，让出 CPU 后，它自己进入到就绪队列，接着参与下一次的 CPU 竞争，有可能再次拿到 CPU，并且该方法是不释放对象锁的。 10、Thread 的 join 方法：让调用 join 的线程等待该线程结束。123456789101112public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(); t.start(); /** * main 线程调用 t.join() 方法 * 即调用 join 的线程是 main 线程 * 即让 main 线程等到 t 线程结束 */ t.join(); &#125;&#125; join 方法的本质是调用了 wait() 方法，由于使用 wait() 方法，那么必定有一个地方在 wait() 所等待的条件满足时，唤醒该线程。这个地方就是：当线程运行结束的时候，Java 系统调用 notifyAll 来通知。 11、在分析代码执行过程时，理解代码在被哪个线程执行是很重要的。要理清执行流、内存和程序代码之间的关系。 12、当多条执行流执行相同的程序代码时，每条执行流都有自己单独的栈，方法中的参数和局部变量都有自己的一份。 当多条执行流可以操作相同的变量时，可能会出现一些意料之外的结果。 13、什么竞态条件？所谓竞态条件「race condition」是指，当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确。 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。 解决竞态条件的方法有：使用 synchronized 关键字、使用显示锁、使用原子变量。 14、什么是内存可见性问题？多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到，甚至永远也看不到。 在计算机系统中，除了内存，数据还会被缓存在 CPU 的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或 CPU 缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，而稍后才会同步更新到内存中。在单线程的程序中，这一般不是个问题，但在多线程的程序中，尤其是在有多 CPU 的情况下，这就是个严重的问题。一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。 解决内存可见性的方法有：使用 volatile 关键字、使用 synchronized 关键字、使用显示锁。 15、线程的优点：充分利用多 CPU 的计算能力；充分利用硬件资源；在用户界面「GUI」应用程序中，保持程序的响应性；简化建模及 IO 处理。 16、线程的成本：需要消耗操作系统的资源；需要创建时间；线程调度和切换。 参考博客Java编程的逻辑——线程的基本概念Java 线程 Thread.join 方法解析竞态条件与临界区]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(二)]]></title>
    <url>%2F2018%2F08%2F10%2FJava-Java-Basic-2018-08-10-Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 入门总结(二) 1、一般来说，程序的结构包含以下三种： 1.顺序结构2.选择结构3.循环结构：根据判断条件的成立与否，决定程序段落的执行次数，而这个程序段落就称为循环主体。 2、三目运算符：「变量 = 条件判断 ？ 表达式1 : 表达式2」；日常开发中，要善于利用三目运算符来减少代码量。 3、switch 语句 注意： break 表示退出整个 switch() 语句块，如果不写 break，则表示从第一个满足条件的 case 开始，之后的所有 case 中的语句都要执行，直到遇到 break 为止或 swithc() 语句块结束。所以使用时每个 case 包括 default 中都必须加上 break 语句。 12345678910111213141516171819/*** 表达式类型取值范围：* char、byte、short、int* Character、Byte、Short、Integer* String、enum*/switch (表达式) &#123; case 选择值1: 语句主体1; // break 表示退出整个 switch() 语句块 break; case 选择值2: 语句主体2; break; ...... default: 语句主体; break;&#125; 4、循环结构 while 循环，当事先不知道循环该执行多少次时使用。先判断，后循环。1234while (循环条件判断) &#123; 语句n; 循环条件更改;&#125; do…while 循环，也是用于事先未知循环执行次数的时候。先循环，后判断。 无论循环条件是否成立，至少都会执行一次循环主体。1234do &#123; 语句n; 循环条件更改;&#125; while (循环条件判断); for 循环：采用两个分号「;」，分隔了三条语句的形式。12345678910111213141516171819/*** for 循环执行流程：* 1、执行初始化指令* 2、检查循环条件是否为 true，如果为 false，跳转到第 6 步* 3、循环条件为真，执行循环体* 4、执行循环条件更改* 5、循环条件更改执行完后，跳转到第 2 步，即继续检查循环条件* 6、for循环后面的语句*/for (初始化「必须是一个声明」; 循环条件判断; 循环条件更改) &#123; 语句n;&#125;-------------------------for 循环变体「不推荐」-------------------------int i = 0;for (; i &lt; 10 ;) &#123; i ++;&#125; 4、break 语句循环中遇到 break 语句，则直接退出整个 for 循环，并且 break 之后的语句也不再执行。 5、continue 语句continue 语句可以强迫程序跳到循环的起始处，当程序运行到 continue 语句时，即会停止运行剩余的循环主体，而是回到循环的开始出继续运行。即：使用 continue 就是中断一次循环的执行。 参考博客强大的循环]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 入门总结(一)]]></title>
    <url>%2F2018%2F08%2F04%2FJava-Java-Basic-2018-08-04-Java%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java 入门总结(一) 1、在一个 *.Java 文件中，「至多有一个」 public 声明的类，「注：这里的类特指：class、interface、@interface、enum」但是允许有 0 个或多个不带 public 声明的类。如果存在 public 声明的类，则文件名称必须与 public 声明的类名称一致。如果一个 *.Java 文件中有多个 class 定义，则编译之后会自动划分为多个 *.class 文件。 2、Java 中的标识符可以由任意的字母、数字、下划线、美元符号组成，但是不能以数字开头，不能是 Java 中的保留关键字。不能用作 Java 命名的词：关键词、保留关键词「goto、const」、具有特殊意义的单词「true、false、null」。 3、变量：将内存中的某个内存块保留下来以供程序使用，里面的内容是可变的。常量：一个数字就表示常量，常量内容是不会改变的「比如：数字 1 就是常量，能改变吗？不能啊！」。 4、Java 数据类型划分 5、Java 八大基本数据类型 6、数据的溢出当「整数」的数据大小超出了可以表示的范围，而程序中又没有做数值范围的检查时，这个整数变量所「输出」的值将发生紊乱，而不是预期的运行结果。「注意：这里的整数包括：byte、short、int、long 四种类型」。 对于其他基本数据类型：char 如果超出其取值范围则什么也不会输出。float 和 double 超出其取值范围，输出的值跟其取值范围的值一样，超出部分算精度丢失了。 7、Java 中字符占 2 个字节，取值范围 0~65535，计算机将字符当成整数来处理。 8、在 Java 中，boolean 类型的值只有 true 和 false，不存在用 0 或 1 表示的情况，也不存在和 0 或 1 转换的情况。 9、Java 中，整型和浮点型（float 或 double）做运算，其结果都是浮点型，因为 Java 的自动转型机制所定，首先它们都是数字，其次浮点型表示的范围比整型大，所以向浮点型自动转型。 10、浮点型向整型做强制类型转换，采取的是丢弃小数部分，只保留整数部分的机制。 11、Java 运算符 Java 中一「单」、二、三目运算符，这里的数字指参与运算的对象「即变量」的个数。 赋值运算符：「=」 一元运算符：「+、-、!」 算术运算符：「+、-、*、/、%」 关系运算符：「&gt;、&lt;、&gt;=、&lt;=、==、！=」 逻辑运算符：「&amp;、&amp;&amp;、|、||」 括号运算符：「()」 位运算符：「&amp;、|、^、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;」 自增与自减运算符：「++、–」 12、位运算符如果要想进行位操作，则需要先将十进制的数据变为二进制数据，除 2 的形式，即除基取余。 位运算操作： 如何将一个十进制数转变为计算机中存储的二进制数123456789101112131415161718192021public class Test &#123; // 如何将一个十进制数转变为计算机中存储的二进制数「以 『int b = -3;』 为例」 if (是否是整数) &#123; // 是整数 对整数的绝对值进行除 2 取余操作，求得其二进制数，即真值。「b 的值为 -3，-3 的绝对值是 3，3 的二进制数为 11」 判断整数的类型是哪个？从而决定它的位数 「b 的类型为 int，在内存中占 4 字节，即 32 位」 if (真值的位数是否小于等于变量类型的位数) &#123; if (是否是负数) &#123; // 是负数 「1 + 29 个 0 + 11（2 位） = 32 位」 最高位为 1，其他位补零，得到其原码，然后再进行反码-&gt;补码-&gt;得到该负数在计算机中二进制的存储格式 &#125;else &#123; // 是自然数，原码 = 反码 = 补码 「30 个 0 + 11（2 位） = 32 位」 高位补 0，求得其原码也即补码，得到该整数在计算机中二进制的存储格式 &#125; &#125; &#125;else &#123; // 不是整数，直接报错 &#125;&#125; 位操作注意事项：1.位操作只能用于整型数据，对 float 和 double 类型进行位操作会被编译器报错。「这里的整型数据指的是 long、int、char、short、byte」。 2.位操作符的运算优先级比较低，所以尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。 3.位操作还有一些复合操作符，如&amp;=、|=、 ^=、&lt;&lt;=、&gt;&gt;= 。 4.short、 byte、char 在移位之前首先将数据转换为 int，然后再移位，此时移位符号作用在 32 位 bit 上，并且右操作数只有低５位有效。 5.当左操作数是 long 时，移位之后得到的类型是 long，当左操作数是其它四中类型时，移位之后得到的类型是 int，所以如果做操作数是 byte,char,short 时，你用 &gt;&gt;=,&gt;&gt;&gt;=, &lt;&lt;= 其实是将得到的 int 做低位截取得到的数值。 13、原码、反码、补码 原码：就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。 反码：正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。 补码：正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1。「即在反码的基础上 +1」。 注意：负数在计算机中是以补码的形式存储的。 参考博客Java 中 boolean 类型占用多少个字节char，byte或者short进行移位处理Java 中 8 种基本数据类型Java 位操作全面总结Java 运算符的优先级Java运算符优先级原码,反码,补码详解Java 移位操作符]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[必知的写作排版指南]]></title>
    <url>%2F2018%2F07%2F26%2FHexo-2018-07-26-%E5%BF%85%E7%9F%A5%E7%9A%84%E5%86%99%E4%BD%9C%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[必知的写作排版指南 1、空格汉字和英文、数字、符号之间都必须加一个空格。 中英文之间加空格 正例：我感觉自己 very 帅。反例：我感觉自己very帅。 汉字与数字之间加空格 正例：我永远都是 18 岁。反例：我永远都是18岁。 数字与单位之间加空格 正例：我有一只身高 120 cm 的猫。反例：我有一只身高 120cm 的猫。 全是英文的句子中，标点符号与单词之间需要加空格。 正例：Where there is a will, there is a way.反例：Where there is a will,there is a way. 全角标点与其他字符之间不加空格 正例：有志者，事竟成。反例：有志者， 事竟成。 中文与链接之间增加空格 正例：我觉得 知乎 这个网站很赞。反例：我觉得知乎这个网站很赞。 括号、引号前后加空格，中间内容无空格 示例 1：5.04 ounces (143 grams)示例 2：Did you say “I love that” ? 2、标点什么是全角、半角？全角、半角主要是针对标点符号来说的，全角占两个字节，半角占一个字节。中文标点符号是全角，英文标点符号是半角。即：中文标点符号的宽度是英文标点符号宽度的 2 倍。 中文 排版中所有的标点都应该使用 全角中文标点符号 正例：有志者，事竟成。反例：有志者,事竟成. 英文 排版中所有的标点都应该使用 半角英文标点符号 正例：Where there is a will, there is a way.反例：Where there is a will，there is a way。 使用直角引号 正例：这个是「直角引号」的效果。反例：这个是“普通引号” 的效果。 引号再使用引号使用直角双引号 正例：在「直角引号里使用『引号』的情况」。反例：在“普通引号里使用‘引号’的情况”。 不重复使用标点符号 正例：德国队竟然输给了韩国队！反例：德国队竟然输给了韩国队！！！ 注：各种输入法怎样快速打出「直角引号」符号 3、其他 英文名字首字母尽量大写 Facebook 专有名词使用正确的大小写 GitHub 首行不要缩进，改用「空出一行」代替首行缩进 空行代替缩进来区分自然段 参考博客中文文案排版指北写给大家看的中文排版指南每个人都需要的中文排版指南各种输入法怎样快速打出「」符号]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j 日志总结]]></title>
    <url>%2F2018%2F07%2F14%2FOther-2018-07-27-Log4j%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Log4j 日志总结 1.日志组件Loggers「记录器」：Logger 负责捕捉事件并将其发送给合适的 Appender。 Appenders「输出源」：也被称为 Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前， Appenders 使用 Layouts 来对事件进行格式化处理。 Layouts「布局」：也被称为 Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts 决定了数据在一条日志记录中的最终形式。 当 Logger 记录一个事件时，它将事件转发给适当的 Appender。然后 Appender 使用 Layout 来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。另外，Filters 可以让你进一步指定一个 Appender 是否可以应用在一条特定的日志记录上。在日志配置中，Filters 并不是必需的，但可以让你更灵活地控制日志消息的流动。 2.日志系统日志系统：日志的具体实现。Java 的常见的日志系统有 Log4j、jdk-jul「即：java.util.logging」、logback 等，这些日志系统各自独立，编程方式也不一致。如果你一个系统要用到多个「框架库」，而这些框架库又可能要用不同的「日志系统」，那么你一个系统中就得使用多套日志系统，那多套日志系统如何融合在一起是个很大的问题。 3.日志框架那么如何解决呢？进行抽象，抽象出一个接口层，对每个日志实现都适配或者转接，这样这些提供给别人的库都直接使用抽象层即可，不需要关注具体的日志实现。常见的日志抽象出来的框架有 Apache commons-logging 和 slf4j。抽象层可以让我们更加容易地改变项目现有的日志框架，或者集成那些使用了不同日志框架的项目。 4.日志故事这里有个故事：最新是开源社区提供了 commons-logging 抽象，被称为 JCL 日志框架「JCL，全称为”Jakarta Commons Logging”，也可称为”Apache Commons Logging”」，出色地完成了兼容主流的日志实现「log4j、JUL、simplelog」，基本一统江湖，就连顶顶大名的 spring 也是依赖了 JCL。 看起来事物确实是美好，但是美好的日子不长，接下来另一个优秀的日志框架 slf4j 的加入导致了更加混乱的场面。比较巧的是 slf4j 的作者(Ceki Gülcü)就是 log4j 的作者，他觉得 JCL 不够优秀，所以他要自己搞一套更优雅的出来，于是 slf4j 日志体系诞生了，并为 slf4j 实现了一个亲子 —— logback，确实更加优雅。 但是由于之前很多代码库已经使用 JCL，虽然出现 slf4j 和 JCL 之间的桥接转换，但是集成的时候问题依然多多，对很多新手来说确实会很懊恼，因为比单独的 log4j 时代“复杂”多了，可以关注下这个，抱怨声确实很多。到此本来应该完了，但是 Ceki Gülcü 觉得还是得回头拯救下自己的 “大阿哥” —— log4j，于是 log4j2 诞生了，同样 log4j2 也参与到了 slf4j 日志体系中。日志体系的江湖又将面临血雨腥风的混乱了。 5.Loggers 组件Loggers 组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度。12345FATAL 0 ERROR 3 WARN 4 INFO 6 DEBUG 7 Log4j 有一个规则：只输出级别不低于设定级别的日志信息，假设 Loggers 级别设定为INFO，则 INFO、WARN、ERROR 和 FATAL 级别的日志信息都会输出，而级别比 INFO 低的 DEBUG 则不会输出。 1234// 获取 Logger 对象import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Test.class); 6.Appenders 组件Appenders 为日志输出目的地，如控制台「Console」、文件「Files」等，还可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。Log4j 提供的 appenders 有以下几种：12345org.apache.log4j.ConsoleAppender「控制台」org.apache.log4j.FileAppender「文件」org.apache.log4j.DailyRollingFileAppender「每天产生一个日志文件」org.apache.log4j.RollingFileAppender「文件大小到达指定尺寸的时候产生一个新的文件」org.apache.log4j.WriterAppender「将日志信息以流格式发送到任意指定的地方」 配置模式：1234log4j.appender.appenderName = classNamelog4j.appender.appenderName.Option1 = value1......log4j.appender.appenderName.OptionN = valueN 7.Layouts 指定日志输出格式Layouts 指定日志输出格式。Layouts 提供四种日志输出样式：HTML样式、自由指定样式、包含日志级别与信息的样式、包含日志时间、线程、类别等信息的样式。 1234org.apache.log4j.HTMLLayout「以HTML表格形式布局」org.apache.log4j.PatternLayout「可以灵活地指定布局模式」org.apache.log4j.SimpleLayout「包含日志信息的级别和信息字符串」org.apache.log4j.TTCCLayout「包含日志产生的时间、线程、类别等等信息」 配置模式：1234log4j.appender.appenderName.layout = classNamelog4j.appender.appenderName.layout.Option1 = value1......log4j.appender.appenderName.layout.OptionN = valueN 8.配置详解在实际应用中，要使 Log4j 在系统中运行须事先设定配置文件。配置文件事实上也就是对 Logger、Appender 及 Layout 进行相应设定。Log4j 支持两种配置文件格式: 一种是 XML 格式的文件。 一种是 properties 属性文件。 下面以 properties 属性文件为例介绍 log4j.properties 的配置。 8.1 配置根记录器 Logger123log4j.rootLogger = [level], appenderName1, appenderName2, ...... # false：表示 Logger 不会在父 Logger 的 appender 里输出，默认为 true。log4j.additivity.org.apache = false; level：设定日志记录的最低级别，可设的值有 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL 或者自定义的级别，Log4j 建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO 级别，则应用程序中所有 DEBUG 级别的日志信息将不会被打印出来。 appendName：指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。1log4j.rootLogger＝INFO, A1, B2, C3 8.2 配置输出目的地 appender12# appenderName：自定义 appderName，在 log4j.rootLogger 设置中使用。log4j.appender.appenderName = className className 可以设如下值：12345678910111213141516171819202122232425262728293031# ConsoleAppender 选项# Threshold = WARN：指定日志信息的最低输出级别，默认为 DEBUG。# ImmediateFlush = true：表示所有消息都会被立即输出，设为 false 则不输出，默认值是 true。# Target = System.err：默认值是 System.out。org.apache.log4j.ConsoleAppender「控制台」# FileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false：true 表示消息增加到指定文件中，false 则将消息覆盖指定的文件内容，默认值是 true。# File = D:/logs/logging.log4j：指定消息输出到 D:/logs/logging.log4j 文件中。也可以使用相对路径。org.apache.log4j.FileAppender「文件」# DailyRollingFileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false「同上」# File = D:/logs/logging.log4j「同上」# encoding = UTF-8 指定输出内容所采用的字符集# DatePattern = '.'yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。org.apache.log4j.DailyRollingFileAppender「每天产生一个日志文件」# RollingFileAppender 选项# Threshold = WARN「同上」# ImmediateFlush = true「同上」# Append = false「同上」# File = D:/logs/logging.log4j「同上」# MaxFileSize = 100KB：后缀可以是 KB, MB 或者 GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到 logging.log4j.1 文件中。org.apache.log4j.RollingFileAppender「文件大小到达指定尺寸的时候产生一个新的文件」org.apache.log4j.WriterAppender「将日志信息以流格式发送到任意指定的地方」 注意：配置消息输出路径的时候，可以使用相对路径，这里的相对路径的参照点为服务器的目录。如：log4j.appender.file.File = ../logs/info.log 该日志系统运行在 Tomcat 服务器上，所以其对应的绝对地址为：服务器 Tomcat 的绝对路径 + ../logs/info.log。 8.3 配置输出格式 Layout1log4j.appender.appenderName.layout = className className 可以设如下值： 12345678910# LocationInfo = true：输出 java 文件名称和行号，默认值是 false。# Title = My Logging： 默认值是 Log4J Log Messages。org.apache.log4j.HTMLLayout「以HTML表格形式布局」# ConversionPattern = %m%n：设定以怎样的格式显示消息。org.apache.log4j.PatternLayout「可以灵活地指定布局模式」org.apache.log4j.SimpleLayout「包含日志信息的级别和信息字符串」org.apache.log4j.TTCCLayout「包含日志产生的时间、线程、类别等等信息」 参考博客Java Log 日志log4j 详细介绍日志系统和日志框架Log4j.properties 配置详解-简书log4j.properties 配置详解-CSDN为什么 logger 要声明为 static final]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的戒烟之旅]]></title>
    <url>%2F2018%2F04%2F02%2FPersonal-2018-04-02-%E6%88%91%E7%9A%84%E6%88%92%E7%83%9F%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[我的抽烟史本人男，24 岁，从 18 岁开始抽烟，到开始戒烟时大约有 5 年的烟龄。学会抽烟的条件无非就那么几种：身边的人都抽，带着你也抽了；为了装逼、装酷；再加上一些失恋啊、压力大啊、熬夜提神啊等等各种莫须有的理由，基本就把很大一部分人牢牢的栓死在吸烟的泥潭里，越陷越深，越来越无法自拔，等你想跳出来的时候，发现你的烟瘾已经大到超越你的理智和毅力的地步，想要摆脱已经很难很难了。基本上掉入这个陷阱的人，很少有能跳出来的，直至被烟折磨到死。我是属于第一种情况，身边的人都抽，跟着也抽了。 其实学习抽烟是一件很痛苦的事情，因为要克服生理上的难受，身体本能的抵抗，还要坚持去抽大约一包才能熬过痛苦的开始，没有一点毅力的人，是学不会的。学会抽烟的人当时是有点毅力了，但当时绝对是没有脑子的，事实证明没脑子真可怕，因为一旦方向错了，越多的努力就越是后退的厉害。回首我的吸烟史，从我开始自己买第一包烟的时候，我就已经陷入进去了，只是那时候不知道，等知道的时候已经晚了，烟瘾已经超越了理智。吸烟的过程中真的被很多人嫌弃过，被舍友、被朋友、被自己、被家人、被路人，我也很难过，但只有吸烟的人才能懂烟瘾来的时候不抽烟的痛苦，不是生理上的更多的是心理上的。「脑补一下非常非常口渴的时候，脑子里肯定会不顾一切的找水喝，就是那种渴望的感觉，也算是吸烟者的一种刚需，所以烟草可以卖那么贵」 随着烟龄的增长，烟瘾会越来越大，吸烟的量也会越来越多。我由一天几根发展到了一天一包甚至更多，到后来明显感觉自己抽烟抽的非常的下贱。晚上要是烟盒里面只有一根烟的时候，心里就会缺失安全感，担心不够抽，担心烟瘾来了怎么办，半夜没烟的时候去翻烟灰缸，找半截的去抽；出去游玩的时候，每隔几小时就想找个地方抽烟，然而很多景点不让随便抽烟；坐火车或者高铁的时候，中间停车几分钟，都要冲下去抽几口；平时工作学习生活，每隔一段时间就要去抽根烟；很多人会躲到厕所里抽烟；真的吸烟者被到处赶，为了吸烟，忍受着别人的歧视、厌恶，忍受着厕所的恶臭，别人的谩骂。现在回想真的觉得那时候的自己为了抽烟变得好可怜、好下贱、好可恨。现在看到还在吸烟的人，重复我以前生活的人，我都会抱以同情的目光，一群被烟奴役的人，我想帮，但又无能为力。 尝试戒烟吸烟有害健康，吸烟不仅浪费钱还伤身体等等各种大道理，吸烟者比非吸烟者应该更清楚，然而这些也就是说说，并没有什么卵用，完全的鸡汤道理。我相信每个吸烟者心里都有想戒烟的的渴望，只是烟瘾大于了理智，虽然有时候会理智一下，但最后都败在烟瘾的阵前。我也尝试过戒烟好多次，感冒严重喉咙疼的要死的时候想过这是个机会通过生理抵抗帮助自己戒烟，最后失败了；看到好多因抽烟得肺癌的新闻，想要戒烟，最后失败了；被自己在乎的人鼓励去戒烟，最后失败了；我曾经做过过很多努力去戒烟，去控烟，然而都没用。真正的戒烟是不需要准备的，是不需要挑时机的。戒烟唯一需要的是你自己能够从心底里明白一些道理，比如：你为什么要吸烟，你为什么又要戒烟难，为什么你以前每次戒烟都会失败，吸烟到底有什么好让你放不下等等一些看似简单，但是你从来没有真正搞明白答案的问题。戒烟的时候各种挑日子，挑时机的人大多都会以失败告终，因为你从心底里没有准备好戒烟，你从一开始就是在逃避的，你根本没有认识到你为什么要戒烟，你是为了戒烟而戒烟，你是为了别人所谓的吸烟有害健康的大道理而戒烟。而不是为你自己戒烟。 戒烟成功 一本书：《这本书能让你永久戒烟》 一个突入其来的下午： 2017.12.18 13：30 一个戒烟 APP： 戒烟军团 首先，如果想戒烟，真的好好看看《这本书能让你永久戒烟》，对戒烟有很大的帮助，能够解决你戒烟路上的很多困惑，用经得起逻辑推理的文字去武装你的思想，让你在戒烟路上能够不被干扰。让你站到高处，站到非吸烟者的角度去思考、去审视在吸烟泥潭中的自己。 其次你需要清晰的意识到自己在坑里，你才会挣扎，你才会往出爬，温水煮青蛙的故事大家都知道，殊不知吸烟者就是温水里的青蛙。如果把毒品比作开水，抽烟比作温水，很多人会全力抵抗毒品，却沦陷在吸烟的泥潭里深深不能自拔，让自己活活的被煮死。更可恶的是最后即使知道了自己最后会被活活煮死，也懒得往出跳了，因为当前是舒服的，尽然还找各种理由去为自己的无能和没有从烟瘾手中抢回理智的毅力去开脱。 戒烟路上肯定会有各种阻力，特别是来自于以前身边的烟友的递烟行为，对于这种情况，大声的告诉他我不会，千万不要说你在戒烟。戒烟是不需要准备的，它开始于你掐灭手中烟的那一刻，我以前每次戒烟前都要准备，最后准备了 3 年，失败了 3 年，其实每次都没有准备好，当你真正准备好的时候，就是你突然明悟吸烟的危害的那一瞬间，其实你已经完成了戒烟，以后只是拿时间去证明一下而已。 戒烟过程中你可能遇到生活工作压力大，跟朋友喝酒开心，情感生活不顺利，多年不见老友劝烟等等各种被拿来当复吸借口的理由，我看着这些理由感觉很可笑，完全是在给自己吸烟找理由。请记住生活中的各种喜怒哀乐不会因为你吸了多少烟而改变任何一丝一毫，不管你吸多少烟，它还是原来的样子，遇到问题请勇敢面对，而不是逃避。 总结当你真正的从心底里明白吸烟的害处。能站到高处看到深陷吸烟泥潭的自己，满身污泥侧身躺在那里，不仅浑然不知，还笑着往自己身上抹发臭的污泥。看着自己被控制着，被奴役着，迫使原本自由的自己每隔一段时间就要按照烟的指令去做事，你的生活、工作、学习都被它无时无刻干涉着，你竟然不愤怒，竟然还任由它在你的生活中自由的破坏，破坏你美好的旅途、好不容易集中的注意力等等。而且这其中你明明是一个受害者，但你却偏偏还要为此付出金钱的代价，即使你穷的快连饭都吃不饱了，但它还要去强迫你去为此付费。最后它还要让你付出生命的代价。 它就是抽烟，它是那么的无理蛮横，随意践踏着你，欺负你。它的唯一目标就是搞臭你的人，搞砸你的生活，最后搞死你。我是人，凭什么让它这么欺负，我不想再被这么控制着，我可怜这样的自己，我对它这样欺负我自己感到愤怒，我要反抗，戒烟是你唯一的选择，可以将它直接拍死，还你自由。 作为一个吸烟者，我渴望的无烟生活，是别人唾手可得的，已经被烟控制的我要经过很大的努力才能让自己自由。我会更加珍惜无烟的自由生活，也从心底里感觉我不会再上瘾，因为从心底里已经对烟产生了抵抗，它带给我的深深的伤痛将会一直警醒我。吸烟是一个坑，我不小心掉进去了，虽然受了很多苦难，但最终我从里面爬了出来，虽然伤痕累累，但不致命，这段经历将是我人生的一笔财富。 感谢最后，感谢一路上包容我的人。感谢那些曾经帮助我、劝说我戒烟的人，谢谢你们!]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人对写博客的一些认识]]></title>
    <url>%2F2018%2F03%2F21%2FPersonal-2018-03-21-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[个人对写博客的一些认识 博客要写吗？随着网络的发展，这两年自媒体很火，我个人关注的一些微信公众号，知识星球等里面的作者基本都提出了要写个人博客的观点。写个人博客的好处有很多，比如锻炼自己的写作能力，培养自己的第二技能，万一你要是火了还可以靠广告赚钱，可以利用写博客加深自己对某个知识或者观点的认知等等。个人实践了一段时间，认为写博客确实有不少好处，能立马看到的好处就是，把自己对某个知识点或者观点写成博客，自己对这些的认识确实会加深很多，而且博客其实还是一个很好的知识归档工具。在学习一个东西的时候，特别是做软件开发的，过段时间不用，基本忘得就跟没学过似的，所以用博客把自己当时的思考结果等记录下来，而且是用自己的语言，特别符合自己的思维习惯，以后在回顾的时候能达到超级好的效果。当然你用心思考的东西发布出去，总能遇到跟你共鸣的人，然后获得关注等，这也是一个写博客的福利吧，想着以后粉丝多了，我就出名啦，也就想想而已哈。 总结：1、写博客能帮助你梳理知识，加深对知识的认识和理解。2、写博客能记录你当时的思考过程，抵抗遗忘，方便自己以后随时查阅。3、写博客可能会让你出名，带来经济收入。 我为什么要写博客？做软件开发的知识更新很快，需要不断的去学习，如此大量的知识，如果不善于总结回顾很容易会忘记。特别是那种平时基本用不到，但偶尔还能用到那么几次的知识点，比如工具破解，开发环境搭建，这种基本很少用到，但每次用到的时候都是一通查找，你要是在自己完成这些工作以后，抽一点时间写下来，那么会节省自己大量的的时间。对！这就是我当前认为写博客的最大原因！而且总结让我加深了对知识的影响，写下来为我以后再做重复的事情节省了大量的重新回顾的时间。其实我们学习的过程就像是拿着手电筒在黑夜里寻宝，手电筒只能照亮一小块区域，当你在看到宝的时候要记得记录下来，别看到了，没带走，等用的时候还得再往回找。 个人认为写博客的一些误区1、在学习一个新东西的时候不要一边学，一边写，很容易变成抄而不是写。我刚开始在学习一个新的知识点的时候，会一边学，一边写博客，但是由于学的是我以前不知道的，所以感觉啥都有必要记录下来，结果就变成了抄别人的博客，抄别人的观点，由于你把所有的东西都记录下来了，感觉就是自己的了，而脑子有了这个想法以后就不会去深入的思考了。人在学习的时候为了记忆会把新知识跟已经学到的知识进行关联然后记忆，这种抄博客的方式变成了打包拷贝，过眼睛，不怎么过脑子了。所以在学习一个新知识的时候，不要一边学，一边写博客，否则就给了本来就有惰性的大脑思考以偷懒的机会。 总结：在学习一个新东西的时候去写博客，一边写一边学，不仅浪费大量的时间，而且基本都是抄的，逃不出作者的写作范围，而且由于拖得时间太长还容易半途而废。实际是你应该看好多相关博客，然后自己会了，懂了，觉得自己明白了，然后用自己的话写出来，这才是真正的博客。你可以写的跟别人的一样，因为真理逻辑就一个，但是输出的方式是从自己的思考中，而不是套用别人的文字。 2、不是所有的知识都有必要写成博客的，不要重复造轮子。我刚开始写博客有一个误区，就是啥都想记录下来，因为总怕自己遗忘，结果导致你会在一个很小的没要必要深究的知识点上花费大量的时间去记录，而且这个知识点别人已经写出来过。博客是要记录那些自己不会的而且自己还为此进行过深入思考的，花费大量时间去探索最后得出让自己满意答案的事，而且重点要记录自己的当时的思考，用自己的话将自己的观点写下来。写的是自己的观点，或者是在别人的观点上有了自己的思考，更或者是你对很多类似观点进行学习以后对其进行归纳总结，让其更全面系统准确。如果你的思考和认识超不出作者的范围，建议还是转载一下完事，没必要花时间造重复的轮子。 3、对待博客的态度需要转变过来，我写博客是为了自己，不是为了获得别人的关注评论。对待博客的态度：我写博客主要不是为了服务于他人，而是怕自己忘记，是自己对抗记忆遗忘曲线的手段。当然同时也服务于他人，给自己带来额外的鼓励等等，但是一定要明白自己写博客是为了服务于自己，不要把自己当成作家，浪费大量的时间在文字的推敲上，只要自己能看懂了就行，否则时间周期过长，容易半途而废。 4、 写短小而精悍的博客，更容易让别人读下去，让自己坚持写下去。我有过这样的体验，刚开始在学 Java 的时候，我是通过看视频学习的，但是视频有长有短，对于那种 30 分钟以上的视频我心里就有抵触感，比如觉得这个视频比较长，我要提前准备进入状态啥的，而且看的过程中还很容易被打断。而对于一些 10 分钟左右的视频我却很容易看下去，也很乐意看下去，而且中间也不容易被打断，其实最终的成果是一样的，但是给人的感受是不同的，这个是人大脑的正常行为，有兴趣的可以去研究一下。这个东西就启发我在写博客的时候要把大的一篇博客拆分成多个小的，写的时候容易坚持下去，看的人也容易看下去，好好利用人类大脑的这个特性。我刚开始就写一大篇，几千字，要阅读 20 多分钟，自己写着头大，看着头大。而对于一些小的短博客，不仅有动力写下去，而且还思考的更深，写的更认真仔细，因为少嘛，所以会精心去雕琢。 总结：博客内容最好短小而精辟，最好不要太长篇大论，如果非得这样的写成一个系列的文章，不要一片文章里面写上所有的内容，写博客最重要的是坚持输出，所以一开始一定要避免很多让自己坚持不下去的外在问题，如果长篇大论的文章，你会一次性写很多，容易导致放弃，最后导致失败，所以少量输出，然后及时获取少量反馈，这样更容易让自己坚持。 5、 在初期的时候写博客的时间成本是很高的。其实在初期要想写好一篇博客是需要大量的时间的，由于对排版，布局，插图，文字表达等各种问题的不熟悉，所以很多东西你是需要推敲而且边学边用的，所以初期写博客的时间成本是很高的。因为有了较高的时间成本，所以我们就要对花大量时间要去写的博客进行精挑细选，这里有几个我认为的挑选规则：在你看来比较有深度的知识，你曾花费大量的时间去思考最终自己真的弄懂了；一些工作生活学习时常要用到的，但又比较容易忘记的；接受了别人的知识输入以后，在自己的大脑里经过消化发酵有了自己的思考和观点，忍不住的想输出分享的内容。 6、 质量 VS 数量。以前看别人说，刚开始写博客，一定要先动起来，即使是抄别人的，也是一种进步。确实对于刚开始来说真的看着不断增长的博客数量有那么些成就感，感觉这些都是自己的成果，当我回头去看那些内容的时候，发现除了抄就是写的很「垃圾」，当然这也证明你成长了。我不否人这个方法确实有效。但是这个方法在初期好使，我们的观点一定是要转变过来的，即质量优先，因为你在注重质量的同时，也是你在成长的时候，从量变一定要转到质变上。集中全部精力，狠打一个点，将一个篇博经过精雕细琢然后输出，这种感觉只有你这么做了，才会有。 全文总结端正态度、认真选主题、自己思考的产物、短小而精悍的输出、尽量不要写没有思考的「垃圾」。]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 代码块]]></title>
    <url>%2F2018%2F03%2F15%2FHexo-2018-03-15-HexoNext%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Hexo Next 代码块 1、编辑主题配置文件 _config.yml「注意是主题配置文件」此处用来设置代码块的背景色。1highlight_theme: night eighties 2、编辑站点配置文件_config.yml「注意亲测会报错」：在网上 Google 的答案中要求将 auto_detect 设置为 true，但是我设置以后使用 hexo generate 生成静态代码的时候会报错 TypeError: Cannot set property ‘lastIndex’ of undefined 所以最后还是乖乖设置成了 false ，对实际效果也没有任何影响，对于该配置需谨慎使用。 「注意是站点配置文件」auto_detect 主要用来支持代码自动检测。12345highlight: enable: true line_number: true auto_detect: false tab_replace: 3、编辑 Markdown 文章注意：「```」之后需要指定你代码块中所使用的开发语言，也可以不指定，即让系统自动识别你代码块中的开发语言是哪个，系统可能会识别失败或错误，所以最好还是指定。注意：符号「```」,是 Esc 下面那个，不是单引号「’’’」。 效果图：]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 搜索功能]]></title>
    <url>%2F2018%2F03%2F14%2FHexo-2018-03-14-HexoNext%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[它侧身于生活的污泥中，虽不甘心，却又畏首畏尾 Hexo Next 添加搜索功能过程，本博客采用「Local Search」！ 对主题版本的要求要使用搜索功能对你的主题版本可能有最低要求，我采用的是 Next 主题，最近更新的，为防止后面出现各种莫名其妙的问题，建议最好把主题版本更新一下。 添加搜索功能安装 hexo-generator-searchdb ，在站点的根目录下执行以下命令：1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能：12local_search: enable: true 重新生成静态文本hexo clean -&gt; hexo generate -&gt; hexo server -&gt; 查看效果 -&gt; 收工 参考博客Hexo 博客添加搜索功能]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法笔记]]></title>
    <url>%2F2018%2F02%2F02%2FHexo-2018-02-02-Markdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Markdown 语法笔记 1.标题方式一：使用两个或两个以上 = 或 - 标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 方式二：使用 #，表示 1-6 级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 2.段落段落的前后要有空行。在段内强制换行的方式是使用两个或两个以上空格加上回车「注：引用中换行省略回车」。 3.区块引用在段落的每行或者只在第一行使用符号 &gt;，还可使用多个嵌套引用。 > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.代码区块Hexo Next 代码块 5.强调在强调内容两侧分别加上 * 或者 _。 *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 6.列表使用 *、+、- 标记无序列表。注意：标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行。 * 第一项- 第三项+ 第二项 效果： 第一项 第三项 第二项 有序列表的标记方式是将上述的符号换成数字，并辅以「.」。 1. 第一项2. 第二项3. 第三项 效果： 第一项 第二项 第三项 7.分割线分割线最常使用就是三个或以上「*」，还可以使用「-」或 「_」。 ***---___ 效果： 8.链接链接可以由两种形式生成：行内式和参考式。 行内式 [行内式展示内容](https://github.com/ “行内式鼠标悬浮展示内容”) 效果： 行内式展示内容 参考式 [参考式展示内容 1][1][参考式展示内容 2][2][1]:https://github.com/ “参考式鼠标悬浮展示内容 1”[2]:https://github.com/ “参考式鼠标悬浮展示内容 2” 效果： 参考式展示内容 1参考式展示内容 2 9.图片添加图片的形式和链接相似，只需在链接的基础上前方加一个「！」,也分为行内式和参考式。 ![图片的替代文字](/upload_image/1.jpg “图片标题”) 效果： 10.反斜杠「\」相当于反转义作用。使符号成为普通符号。即显示符号本身。 11.符号「`」起到标记作用。即加个阴影背景。 `ctrl + a` 效果： ctrl + a 12.尖括号在 Markdown 中「尖括号」会被默认为 HTML 语句，这将导致尖括号本身及尖括号中的内容都不会被显示。所以就必须得使用转义字符才能够表示出「尖括号」。使用 &amp;lt; 代替 &lt;，使用 &amp;gt; 代替 &gt;。 &amp;lt;&amp;lt;西游记&amp;gt;&amp;gt; 效果： &lt;&lt;西游记&gt;&gt; 13.键盘键 &lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt; 效果： Ctrl+[ and Ctrl+] 14.删除线 ~~删除线~~ 效果： 删除线 15.反引号一个反引号需要引用代码时，如果引用的语句只有一段，不分行，可以用「反引号」将代码包起来，它们会解释成 &lt;code&gt;标签。 两个反引号如果代码的「内容中」有反引号，请用两个反引号包裹，与前后两个反引号之间加空格。代码中的&amp;、&lt;、&gt;符号都会自动转义。 三个反引号如果引用的语句为多行，可以将三个反引号```置于这段代码的首行和末行。 16.其它「表格」列表的使用(非traditonal markdown)用 | 表示表格纵向边界，表头和表内容用 - 隔开，并可用 : 进行对齐设置，两边都有 : 则表示居中，若不加 : 则默认左对齐。 一个普通标题 一个普通标题 一个普通标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 总结Markdown 只是帮助我们排版的工具，重要的还是内容，它是一篇文章的灵魂。好看的皮囊千篇一律，有趣的灵魂万里挑一。Markdown 就是赋予你灵魂一个好看的皮囊，但如果你没有有趣的灵魂，其他的全是扯淡。所以 Markdown 看一遍就行了，大致了解，然后动手写，不会的去查然后调整一下就好了，适应一段时间你就完全脱离了。使用 Markdown 的最高境界永远都是：笔下是语法，心中格式化。你达到了吗？ 参考博客Markdown 基本语法Markdown 入门参考Markdown 语法精讲Markdown 语法介绍]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML 类图]]></title>
    <url>%2F2018%2F02%2F02%2FDesign-Pattern-2018-02-02-UML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML 类图 类的图示（Class） 类图分三层 类的名称，如果是抽象类就用斜体显示。 类的特性，通常是字段和属性。 类的操作，通常是方法或行为。 Java 四种访问权限在类图中的表示访问范围由大到小为：public、protected、default（即什么都不写）、private；‘+’表示 public，‘#’表示 protected，‘-’表示 private，什么都不写就表示 default 了。 分析图 1-1 Person 类图第一行：类的名称为：Person；如果为抽象类，则“Person”采用斜体。第二行：类的属性为：name ；“:”冒号前面表示属性的名字，后面表示属性的类型，还可以给属性赋初值。第三行：类的方法：“&lt;&lt;Getter&gt;&gt;”或“&lt;&lt;Setter&gt;&gt;”表示方法的注释，可有可无，只是起到一个标记作用而已；冒号前面是方法的名字，注意方法的名字后面都是要带括号的“()”;冒号后面是方法的返回值。 1234567891011121314151617181920public class Person &#123; private String name = "zhangsan"; private int age = 23; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 接口的图示（interface）接口的 UML 图有两种表示方法：1、名称上面 &lt;&lt;interface&gt;&gt; 用这个标识它是一个接口2、「棒棒糖」表示法，圆圈旁边为接口名称，接口方法在实现类中出现 UML 关系图 继承关系「即泛化关系」 继承关系用空心三角形 + 实线来表示注意指向：子类指向父类（即空心三角形在父类这边）助解：因为父类可以有多个子类，所以就会聚集成一个三角形，而子类则是一个线头的点 123456789// 父类public class Person &#123; private String name;&#125;// 子类 继承了 父类public class Student extends Person&#123; private String StudentNumber;&#125; 实现接口 实现接口用空心三角形 + 虚线来表示注意指向：子类指向接口（即空心三角形在接口这边）助解：因为接口可以有多个实现，所以也会聚集成一个三角形，而子类则是一个线头的点 1234567891011121314// 接口public interface Say &#123; String say();&#125;// 实现接口public class Person implements Say&#123; private String name; @Override public String say() &#123; return "person say ..."; &#125;&#125; 关联关系关联关系表示一类对象与另一类对象之间有联系，通常将一个类的对象作为另一个类的成员变量来表示关联关系 关联关系用实线箭头表示注意指向：箭头由引用类指向被引用类，表示引用类 要引用 被引用类的东西助解：比如企鹅需要知道气候，而企鹅和气候是两个类，那么现在企鹅类中用到了气候类，所以企鹅依赖气候因为企鹅需要知道气候的变化，即当一个类需要知道另一个类时，可以用关联关系关联关系有：单向关联、双向关联、自身关联、多重性关联 123456789// 气候类public class Weather &#123;&#125;// 企鹅类public class Penguin &#123; // 企鹅需要知道气候，所以这里引用了气候类，表示企鹅这个类引用了气候类,即一个类中有另一个类的引用 private Weather weather;&#125; 依赖关系依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。 依赖关系用虚线箭头表示注意指向：箭头由依赖方指向被被依赖方，表示依赖方 依赖于 被依赖方提供的东西助解：动物生存依赖氧气、水，注意这里是动物的生存依赖氧气、水，不是动物本身依赖，动物要是挂了就不需要了 12345678910111213// 汽车类public class Car &#123; public void move() &#123; System.out.println("move"); &#125;&#125;// Driver 类的方法使用了 Car 类对象作为方法的参数，即要想开车，必须先有车public class Driver &#123; public void drive(Car car) &#123; car.move(); &#125;&#125; 关联关系 vs 依赖关系依赖关系：是一种 使用关系。一个类 A 使用到了另一个类 B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是 B 类的变化会影响到 A。例如：客户使用产品需要提供者，产品的变更会影响客户的使用，但一个客户需要的产品可以有多个提供者。即一个类可能同时依赖多个类。 关联关系：是一种 结构关系。它指明一个事物的对象与另一个事物的对象之间的联系。关联关系比依赖关系更强，不存在依赖关系的偶然性，关系也不是临时性的，而一般是长期性的。例如：商品和订单，订单中包含商品信息。 小结： 依赖关系是一种 使用关系，即类 A 在做某个动作的时候依赖到了其他对象类 B。 关联关系是一种 结构关系，即类 A 中存在类 B，指明了类 A 对象和 类 B 对象之间的联系。 聚合关系聚合是一种弱的「拥有」关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分 聚合关系用空心的菱形 + 实线箭头表示注意指向：空心的菱形放在聚合的群体那边，箭头指向群体中的每个个体助解：大雁和雁群，因为大雁聚合形成雁群，则空心菱形表示聚合形成堆了，而箭头表示单个点 123456789// 大雁public class Goose &#123;&#125;// 雁群public class GooseGroup &#123; // 雁群类中有大雁的集合 private Goose[] gooseList;&#125; 合成关系「即组合关系」合成是一种强的「拥有」关系，提现了严格的部分和整体的关系，部分和整体的生命周期一样 合成关系用实心的菱形 + 实线箭头表示注意指向：实心的菱形放在合成的整体那边，箭头指向部分，即用来合成整体的部件助解：鸟和翅膀，部分和整体且生命周期一致 12345678910111213// 翅膀public class Wing &#123;&#125;// 鸟类public class Bird &#123; private Wing wing; // 生成鸟类的同时生成翅膀 public Bird() &#123; this.wing = new Wing(); &#125;&#125; 参考列表：《大话设计模式》[深入浅出UML类图]http://www.uml.org.cn/oobject/201211231.asp[UML基础系列：类图]http://www.cnblogs.com/lsgxeva/p/7720224.html 感觉不错：[Java类与类之间的5种关系及uml表示]https://blog.csdn.net/pj36536/article/details/53101764[UML类图与类的关系详解]https://blog.csdn.net/sinat_30397435/article/details/79018467]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客搭建总结]]></title>
    <url>%2F2018%2F02%2F02%2FHexo-2018-02-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo 博客搭建总结 近期终于下定决定自己搭建一个博客出来了。利用 Hexo+Github+Next， 前后历时差不多一周左右的时间吧，终于把大致框架搭建出来了，剩下的就是小的修修补补了。由于我对前端处于白痴阶段，所以很小的问题都能把我困住，基本上是踩着别人的肩膀一步步走过来的，在此分享下一个白痴搭建的过程，希望你能绕开我走过的坑，少一些为寻找某一个问题而苦苦搜寻的过程，最后祝大家都能顺利搭建成功。如果遇到其他问题留言吧，我乐意帮忙。 下面是我博客搭建过程中踩过的各位大牛的肩膀，希望对你有帮助，在此也真心的感谢他们，不管好坏对错，最后都帮到我了，在我因为一个问题苦苦挣扎寻找的时候，他们的博客或者论坛出现了，帮助我顺利走向下一步，再次谢谢他们。下面是我对他们博客论坛的一些个人过滤，每个里面都有其精华所在，供大家参考。 1、官方文档这个没得说，最最最重要的是它由简体中文版！注意右上角可以切换语言的哦。把它当成一个手册吧，全而细，但我没那个耐心读一遍，索引就跟字典的作用似的。官方文档。 2、博客框架搭建下面这两篇是关于 Hexo 从零开始到搭建完整，比较系统，但细节处理不是特别完美，适合动手搭建整体框架的时候参考，都写的大而详细，里面可能有小瑕疵，注意拉到最后面看评论区，说不定你遇到的坑别人已经踩出来了，还有结合官方文档，综合多方面信息，博主要是在命令里面少打一个空格，对于什么都不懂的你可能执行不下去了，然后就可能放弃掉了。真的很可惜，我们好不容易下次决定还就这么夭折了，那可都是生命啊，请为它们的流逝赋予意义。Hexo 从零开始到搭建完整，Hexo 搭建博客教程。 3、Next 主题搭建是当前比较好用，且被使用次数最高的主题，如果你采用的是这个主题，那么下面这个内容真的是大而全的帮你设置各种小功能，强烈推荐。Next 主题搭建。 4、这个是 Next 主题官网的一个配置参考，有些东西看官方的肯定是好的，大全而且还细，但时我没有那个耐心，所以宁愿 Google 答案，也不愿意去看一大堆的文档。主题配置参考。 5、Next 主题修缮这个对我帮助挺大的，相见恨晚啊，基本上把我踩过的坑都覆盖到了，讲的很详细，重点读一下，对于白痴的我来说，写的很好，前提是你的博客框架搭建好修缮的过程中用。Next 主题修缮。 6、添加分类及标签 7、这个是关于主题的，这个问题困扰了我好久，为什么别人的主页跟我的就是不一样的呢，而且 Next 默认的那个主题比较丑，众里寻他千百度，就是这篇博客帮我解决了这个问题，其实 Next 支持三种主题，默认的只是其中一种。Hexo 应用 NexT 主题。 8、Hexo博客添加评论、打赏、RSS 等功能 9、为文章添加热度 10、不蒜子统计无法显示的原因 11、博客主页显示文字阅读次数 12、Hexo 添加评论系统 Valine 总结：还有些我在搭建过程中参考的博客给搞丢了，不过应该都比较好找，比如添加评论区，打赏，是由统计访问点击量啥的，都可以留言问我。尽管我没有了原来的链接，但是我知道怎么去搜索，这个很关键，在搭建博客过程中，我遇到那些问题，都不到输入什么关键词去查询答案，真的很悲催，我就这么悲催过来了，不希望你们再走我悲催的老路。关键是这些弯路走的没必要。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人迷茫时刻]]></title>
    <url>%2F2018%2F02%2F02%2FPersonal-2018-02-02-%E4%B8%AA%E4%BA%BA%E8%BF%B7%E8%8C%AB%E6%97%B6%E5%88%BB%2F</url>
    <content type="text"><![CDATA[年轻人闲聊扯淡 我对于工具和框架的态度一直都是用到了查一下就好了嘛，框架和工具那么多，要是每个都系统的去学习一下那岂不累死，核心的东西要放在设计上。但是每次遇到了每次查，用的多了发现查的次数也越来多了，最后对工具和框架的认识就像漏勺，看起来会，实际上存满了漏洞，有想过系统的去学习一下，但是发现去学习这些工具和框架枯燥无味，很难坚持下去，总是虎头蛇尾，最后碰到点困难就放弃了。怎么说呢，其实还是对这些工具和框架的需求不够，没有很渴望的去接受这些东西。想象一下你很渴很渴的时候，对水的那种渴望（为此我还特意不喝水体验了一把）真的没什么能阻止你，更直接一点就是对空气的渴望，当你能抱这样的心态去学习我想你会效率很高很快。追过小说的读者应该和我有同样的一种体验，看小说就入迷了，吃饭看，走路看，坐公车看，以前坐公车上班特别怕堵车，但是迷上小说以后特别盼堵车，回家了躺那里就是看，真的跟疯了一样。我一直在想，为什么我学习技术达不到像追小说那样的状态呢，我是有潜力的，只是我所学习的东西不够吸引我罢了。但是没有追求就创造追求，在自己认为对的路上给自己造就渴望，至于怎么做，我还在探索。我相信我会成功的，但是前面的路是要一个坑一个坑的趟，会有迷茫无助，谁都帮不了你，只有自己，探索的路真的很痛苦，我知道胜利就在远方。 最要命的是胜利不仅仅只是努力和坚持就好了，想想也是，如果胜利真的只有努力和坚持这么简单，那岂不是太简单了。比努力和坚持更重要的是方向，想象一下你坐车坐成了反方向就知道有多可怕了。只有在对的方向上做对的努力和坚持才能让你成长，方向选错了，还会妨碍你的成长，其实在当今互联网时代，真的是信息洪流中，不进则退，别说选错方向了，你就是站在那不动都一直在倒退，因为大家都在埋头前进。那么什么是对的方向呢，这个只能自己去判断了，真的不能盲目的去努力，我有过一段这样的经历，到最后越来越迷茫，差距越来越大，那段时间我就停下来，什么都不干，每天看书，冥想。问自己你的目标是什么？你苦苦坚持努力，你最后想要怎样的结果？这个问题其实挺深奥的，我有想过是钱，其实并不是，每天有那么多赚钱的机会，但我并没有特别渴望去赚钱。真正的目标是那些，你心里很渴望，每天都想着努力去完成，每一天都有进步，每天都离自己的目标更近了，对于这样的一群有自己明确目标的人，明确知道要干什么去接近自己的目标，每天都看着自己离目标更进一步，他们真的很可怕，我觉得世上没有什么是难得到他们的，即使没有任何人去支持他们，我也相信他们会一往无前的走下去，成功时候的光芒万丈，耀瞎世俗的眼。 我是一个世俗的人，支持我走下去的东西有太多太多世俗，有时候是别人的一句赞赏，有时候是为了获得别人的关注，为了满足自己活着别人的虚荣心而且活着，做着自己不愿意但是强迫自己去做的事。我内心超级脆弱的，怕孤独，怕孤立，怕被世俗抛弃，怕这怕那，畏首畏尾，想想真觉得可笑。至今我都不直达我真正追求的目标是什么，唯一让我感觉到有点轻松快乐的就是写东西，把很多自己所思所想写出来，有种酣畅淋漓的感觉，会去为了更准确的表达自己内心所想而去推敲每一个字，改过来改过去，会调整格式到自己认为完美的状态会因为一个标点符号或者没有对齐而难受调整半天，而且一点也不绝得累。完事还特别有成就感，我有时候会关注有多少人看，说不在意是假的，但是真的没有那么在意，你看或者不看，我都会坚持写下去，我的读者从来只有我自己，茫茫人海，全是过客，所有的所有都是我人生不同体验的一个风景。 我们每天都会面临各种各样的选择，有选对的有选错的，但是有的人选择是经历思考的，知道自己为什么这么选，有自己明确的目的和思考，他每天的选择都会有意思的去跟自己的目标挂钩，为了自己离自己的目标更近一步，就是人家用脑子了，跟自己的主要目标稍微有些偏差他们能感觉出来，并及时做出调整，而我只会在错的路走不下去的时候才发现自己迷路了，所以我要给自己定目标，一个很明确的目标，指向我心底渴望的未来，我不会立刻给出很明确的目标，但我必须有目标，在跟随自己目标前进的过程中不断调整。 目标如下 最大的目标：提升自己的专业技能，然后找好工作，然后赚更多的钱，给自己更多的自由。1.近期坚持完成一个 SSM + Dubbo + Redis + MQ 的练手项目，做出来就好，不论过程。2.坚持每天写至少一篇博客，梳理自己每天的所思所想，帮助自己更好的调整方向。3.遇到困难了坚持下去，再难再硬也要啃下来，啃的过程就是自己进步最快的时候。]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
</search>
